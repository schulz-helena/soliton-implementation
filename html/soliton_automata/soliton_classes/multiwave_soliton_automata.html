<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>soliton_automata.soliton_classes.multiwave_soliton_automata API documentation</title>
<meta name="description" content="Multiwave soliton automata." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>soliton_automata.soliton_classes.multiwave_soliton_automata</code></h1>
</header>
<section id="section-intro">
<p>Multiwave soliton automata.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Multiwave soliton automata.
&#34;&#34;&#34;
import copy
import re

import networkx as nx
import numpy as np

from soliton_automata.soliton_classes.soliton_graph import SolitonGraph
from soliton_automata.soliton_classes.traversal import Traversal


class MultiwaveSolitonAutomata:
    &#34;&#34;&#34;Representation of a multiwave soliton automata, which finds all traversals for a burst.
    &#34;&#34;&#34;

    def __init__(self, soliton_graph: SolitonGraph, bursts: str, stop: int):
        &#34;&#34;&#34;Initializes a `MultiwaveSolitonAutomata` object by using a soliton graph, a burst and a stop number.
        &#34;&#34;&#34;
        self.soliton_graph: SolitonGraph = soliton_graph
        &#34;&#34;&#34;Soliton graph the automata is based on.&#34;&#34;&#34;
        self.bursts = bursts
        &#34;&#34;&#34;The set of input burst.&#34;&#34;&#34;
        self.stop = stop
        &#34;&#34;&#34;After how many equal soliton graph + soliton positions to stop searching for traversals on current path in search tree.&#34;&#34;&#34;
        self.bursts_dicts: list = self.build_bursts_dicts()
        &#34;&#34;&#34;List of the bursts as dictionaries (soliton number as key and a list containing exterior nodes and entry time as value).&#34;&#34;&#34;
        self.deterministic: bool
        &#34;&#34;&#34;Whether the multiwave soliton automata is deterministic.&#34;&#34;&#34;
        self.strongly_deterministic: bool
        &#34;&#34;&#34;Whether the multiwave soliton graph is strongly deterministic.&#34;&#34;&#34;
        self.states_plus_traversals: dict
        &#34;&#34;&#34;All states of the soliton automata plus all traversals that can be found in each state plus number of traversals found for each burst
        (Id/ string of the states adjacency matrix as key and state, traversals and list of numbers as values).&#34;&#34;&#34;
        self.deterministic, self.strongly_deterministic, self.states_plus_traversals = self.all_traversals()


    def build_bursts_dicts(self):
        &#34;&#34;&#34;Builds a list of burst dictionaries.

        Returns:
            list: The computed list of burst dictionaries.
        &#34;&#34;&#34;
        bursts = self.bursts.split(&#34;;&#34;)
        bursts_dicts = []
        for burst in bursts:
            burst = re.sub(r&#34;[{}]+&#34;, &#34;&#34;, burst)
            burst_dict = self.burst_dict(burst)
            bursts_dicts.append(burst_dict)

        return bursts_dicts

    def burst_dict(self, burst: str):
        &#34;&#34;&#34;Builds a dictionary as an internal representation of a burst.

        Args:
            burst (str): The burst string that should be turned into a dictionary.

        Returns:
            dict: The computed dictionary with soliton number as key and a list containing exterior nodes and entry time as value.
        &#34;&#34;&#34;
        burst_copy = copy.copy(burst)
        burst_dict = {}
        entry = 0 # entry time of the current soliton, is increased every time there is another soliton with a k_i
        soliton = 1 # number of the current soliton
        first = re.search(r&#34;[(][0-9]+[,][0-9]+[)]&#34;, burst_copy) # first soliton in burst
        nodes = re.findall(r&#34;[0-9]+&#34;, first.group()) # find the two exterior nodes
        burst_dict[soliton] = [self.soliton_graph.exterior_nodes_reverse[nodes[0]], self.soliton_graph.exterior_nodes_reverse[nodes[1]], 0] # first soliton entries at time step 0 (take node ids, not node labels)
        burst_copy = burst_copy[first.span()[1]:] # remove all the information on the first soliton from the burst
        while burst_copy != &#34;&#34;:
            found = re.search(r&#34;[||][0-9]+[(][0-9]+[,][0-9]+[)]&#34;, burst_copy)
            all_nums = re.findall(r&#34;[0-9]+&#34;, found.group())
            entry = entry + int(all_nums[0]) # add the current k_i to the entry time
            soliton += 1
            burst_dict[soliton] = [self.soliton_graph.exterior_nodes_reverse[all_nums[1]], self.soliton_graph.exterior_nodes_reverse[all_nums[2]], entry] # take node ids, not node labels
            burst_copy = burst_copy[found.span()[1]:] # remove from burst
            
        return burst_dict


    def build_traversals(self, travs: list, soliton_graph: SolitonGraph):
        &#34;&#34;&#34;Turns traversals into objects of class `Traversal`.

        Args:
            travs (list): Traversals that are represented as soliton positions and bindings for each timestep.
            soliton_graph (SolitonGraph): Soliton graph the traversal was found in.

        Returns:
            list: Traversals.
        &#34;&#34;&#34;
        traversals = []
        for trav in travs:
            if isinstance(trav[len(trav)-1], int): # if trav is not a real traversal but part of an endlessly looping traversal
                traversal = Traversal(soliton_graph, trav[0])
                traversals.append([traversal, trav[1]])
            else:
                traversal = Traversal(soliton_graph, trav)
                traversals.append(traversal)

        return traversals


    def change_bindings(self, bindings: dict, edge: tuple):
        &#34;&#34;&#34;Changes binding type of an edge (1 -&gt; 2 and 2 -&gt; 1).

        Args:
            bindings (dict): Current binding types of all edges in the graph.
            edge (tuple): Edge whose binding type should be changed.

        Returns:
            dict: Updated binding dictionary.
        &#34;&#34;&#34;
        if bindings[(edge[0], edge[1])] == 2:
            bindings[(edge[0], edge[1])] = 1
        else:
            bindings[(edge[0], edge[1])] = 2
            
        return bindings

    
    def find_all_travs_given_burst (self, graph: nx.Graph, burst_dict: dict, t: int, s_pos_all_timesteps: list, bindings_all_timesteps: list, binds_all_timesteps: list, travs: list):
        &#34;&#34;&#34;Finds all possible traversals for a given burst by using a recursive backtracking algorithm.

        Args:
            graph (nx.Graph): Graph the traversals should be found in.
            burst_dict (dict): The burst that is used. 
            t (int): Current timestep.
            s_pos_all_timesteps (list): Soliton positions for all past timesteps.
            bindings_all_timesteps (list): Binding types of all edges in the graph for all past timesteps.
            binds_all_timesteps (list): Binding type of the last edge that was traversed by each soliton for all past timesteps.
            travs (list): All currently found traversals.

        Returns:
            list: All found traversals (is empty if no traversal exists).
        &#34;&#34;&#34;
        t += 1
        akt_bindings = bindings_all_timesteps[t-1]
        akt_binds = binds_all_timesteps[t-1]
        akt_positions = s_pos_all_timesteps[t-1]

        finished = True
        for soliton in akt_positions:
            if (akt_positions[soliton] != burst_dict[soliton][1] and akt_positions[soliton] != -2) or s_pos_all_timesteps[t-2][soliton] == -1 or t &lt; 2: # if not all solitons reached their end node or already left the graph
                finished = False
                break
        # base case 1: if all solitons traversed the graph successfully
        if finished == True:
            trav = []
            for i, pos in enumerate(s_pos_all_timesteps):
                this_timestep = (pos, bindings_all_timesteps[i]) # for each timestep, add a tuple of the solitons&#39; positions and the bindings
                trav.append(this_timestep)
            travs.append(trav) # trav = traversal of all solitons through the graph
            return travs

        # base case 2: if some solitons are stuck in an endless loop
        count = 1
        for k in range(0, len(bindings_all_timesteps)-1):
            if akt_bindings == bindings_all_timesteps[k] and akt_positions == s_pos_all_timesteps[k]: # if we already had that exact graph and position map in this configuration trail
                count += 1
                if count == self.stop:
                    trav = []
                    for i, pos in enumerate(s_pos_all_timesteps):
                        this_timestep = (pos, bindings_all_timesteps[i])
                        trav.append(this_timestep)
                    travs.append([trav, k+1]) # append the found trav plus the loop point/ timestep (+1, because otherwise in animation we would display the loop point twice)
                    return travs
        

        # in this timestep find possible edges for each soliton individually
        possible_edges = {} # possible edges for each soliton in this timestep
        possible_nodes = {} # possible nodes for each soliton in this timestep
        for soliton in burst_dict:
            end = burst_dict[soliton][1] # end node for this soliton
            akt_pos = akt_positions[soliton] # current position of this soliton
            possible_edges[soliton] = []
            possible_nodes[soliton] = []
            if akt_pos == -2 or (akt_pos == end and s_pos_all_timesteps[t-2][soliton] != -1 and t &gt; 1): # if soliton already traversed the graph successfully
                possible_edges[soliton].append(-2)
                possible_nodes[soliton].append(-2)
            elif burst_dict[soliton][2] &gt; t: # if soliton&#39;s entry time has not come yet
                possible_edges[soliton].append(-1)
                possible_nodes[soliton].append(-1)
            elif burst_dict[soliton][2] == t: # if soliton enters the graph now (place it at its starting node)
                possible_edges[soliton].append(burst_dict[soliton][0])
                possible_nodes[soliton].append(burst_dict[soliton][0])
            else:
                for node in list(nx.neighbors(graph, akt_pos)): # iterate over all nodes that are adjacent to current position
                    # soliton can not go to an exterior node that is not the end node, soliton is not allowed to make a direct turnaround and edge to next node has to have the right binding type
                    if ((node not in self.soliton_graph.exterior_nodes) or (node == end)) and node != s_pos_all_timesteps[t-2][soliton] and akt_bindings[tuple(sorted((akt_pos, node)))] != akt_binds[soliton]:
                        possible_edges[soliton].append(tuple(sorted((akt_pos, node))))
                        possible_nodes[soliton].append(node)
        # find all possible combinations of the found edges 
        edges_combs = []
        nodes_combs = []
        for soliton in possible_edges:
            if possible_edges[soliton] == []: # if for one soliton there are no possible next edges, no combinations are possible
                edges_combs.clear()
                nodes_combs.clear()
            if soliton != 1 and not any(edges_combs): # if no possible edge combination exists anymore, terminate the loop (not any(edges_combs) makes sure list is empty or only contains empty lists)
                break
            for i, edge in enumerate(possible_edges[soliton]): # for all possible edges for this soliton
                if soliton == 1:
                    edges_combs.append([edge]) # simply add the edge if it&#39;s the first soliton
                    nodes_combs.append({soliton: possible_nodes[soliton][i]}) # add dictionary with node for this soliton
                else:
                    for j, comb in enumerate(edges_combs): # if it&#39;s not the first soliton loop over all existing combinations
                        if edge == -1 or edge == -2 or edge not in comb: # if edge is not already in combination (or soliton is outside the graph)
                            if len(comb) &lt; soliton:
                                edges_combs[j].append(edge) # add the edge if this combination doesn&#39;t contain an edge for this soliton already
                                nodes_combs[j][soliton] = possible_nodes[soliton][i]
                            else: # else copy the combination, remove the last edge (the edge for this soliton), add the edge and add this new combination
                                comb_copy = copy.deepcopy(comb)
                                comb_copy.pop()
                                comb_copy.append(edge)
                                edges_combs.append(comb_copy)
                                node_comb_copy = copy.deepcopy(nodes_combs[j])
                                node_comb_copy[soliton] = possible_nodes[soliton][i] # overwrite
                                nodes_combs.append(node_comb_copy)
                        if i == len(possible_edges[soliton])-1: # if we are looking at the last possible edge of this soliton
                            if len(comb) &lt; soliton: # and the combination does not contain an edge for each soliton
                                edges_combs[j] = [] # &#34;delete&#34; the combination
                                nodes_combs[j] = {}
        edges_combs = [elem for elem in edges_combs if elem != []]
        nodes_combs = [elem for elem in nodes_combs if elem]

        # iterate over all possible combinations
        for i, comb in enumerate(nodes_combs):
            s_pos_all_timesteps.append(comb)
            bindings = copy.deepcopy(akt_bindings)
            binds = copy.deepcopy(akt_binds)
            for j, edge in enumerate(edges_combs[i]): # for all edges in chosen combination
                if isinstance(edge, tuple): # binds and bindings only change if &#34;edge&#34; is actually an edge (if edge is -1, -2 or the start node, no edge is traversed)
                    binds[j+1] = bindings[tuple(sorted(edge))] # change bind to binding type of edge that was just traversed
                    bindings = self.change_bindings(bindings, tuple(sorted(edge))) # change bindings
            bindings_all_timesteps.append(bindings)
            binds_all_timesteps.append(binds)
            # call function recursively: if eventually all solitons reach their end node if we go further with the decision we just made then travs is changed (new traversal added)
            travs = self.find_all_travs_given_burst(graph, burst_dict, t, s_pos_all_timesteps, bindings_all_timesteps, binds_all_timesteps, travs)
            # try different decisions next, so we need variables in the state before the last decision
            s_pos_all_timesteps.pop()
            bindings_all_timesteps.pop()
            binds_all_timesteps.pop()

        return travs # if at some point no other traversal could be added, then all possible traversals are found


    def call_find_all_travs_given_burst (self, burst_dict: dict, soliton_graph: SolitonGraph):
        &#34;&#34;&#34;Initializes some parameters and then calls `find_all_travs_given_burst` with them.

        Args:
            burst_dict (dict): The burst that is used. 
            soliton_graph (SolitonGraph): Soliton graph the traversals should be found in.

        Returns:
            list: All found travs as traversals (returns empty list when no traversal is found).
        &#34;&#34;&#34;
        soliton_graph_copy = copy.deepcopy(soliton_graph) # working on copy of graph so no unwanted changes are made
        graph = soliton_graph_copy.graph
        t = 0
        bindings_all_timesteps = [soliton_graph_copy.bindings] # already add bindings for timestep 0
        soliton_positions = {}
        binds = {}
        for soliton in burst_dict:
            binds[soliton] = 0
            if burst_dict[soliton][2] == 0: # if soliton enters the graph at timestep 0
                soliton_positions[soliton] = burst_dict[soliton][0] # starts at its start node
            else:
                soliton_positions[soliton] = -1 # soliton is not in graph at timestep 0
        # already add positions and binds for timestep 0
        s_pos_all_timesteps = [soliton_positions]
        binds_all_timesteps = [binds]
        travs = []

        travs = self.find_all_travs_given_burst(graph, burst_dict, t, s_pos_all_timesteps, bindings_all_timesteps, binds_all_timesteps, travs)
        traversals = self.build_traversals(travs, soliton_graph)

        return traversals


    def all_traversals (self):
        &#34;&#34;&#34;Calls `call_find_all_travs_given_burst` for all states of the automata and all bursts in order to get all possible traversals in all states.

        Returns:
            bool: Whether the soliton automata is deterministic or not.
            bool: Whether the soliton automata is strongly deterministic or not.
            dict: All states of the soliton graph plus all traversals that can be found in each state plus number of traversals found for each burst.
        &#34;&#34;&#34;
        initial_matrix = nx.to_numpy_array(self.soliton_graph.graph)
        states = [self.soliton_graph] # stores all possible states as soliton graphs, needed to iterate over states 
        states_plus_traversals = {self.matrix_to_string(initial_matrix): [self.soliton_graph, [], []]} # stores all states plus all traversals that can be found in that state plus number of traversals found for each burst
        deterministic = True
        strongly_deterministic = True

        for state in states: # for all states/ soliton graphs of the automata
            state_matrix_id = self.matrix_to_string(nx.to_numpy_array(state.graph))
            all_traversals = []
            num_traversals_per_burst = []
            for burst_dict in self.bursts_dicts: # loop over all bursts
                traversals = self.call_find_all_travs_given_burst(burst_dict, state) # find soliton paths with all bursts
                num_traversals_per_burst.append(len(traversals))
                loops_num = 0
                first_real_trav = -1
                for t, traversal in enumerate(traversals):
                    all_traversals.append(traversal)
                    if isinstance(traversal, Traversal): # if traversal is a real traversal and no endless loop
                        if first_real_trav == -1:
                            first_real_trav = t
                        resulting_matrix = traversal.adjacency_matrices_list[len(traversal.adjacency_matrices_list)-1] # adjacency matrix of the soliton graph the traversal results in
                        resulting_matrix_id = self.matrix_to_string(resulting_matrix)
                        if resulting_matrix_id not in states_plus_traversals: # if we found a new state
                            states_plus_traversals[resulting_matrix_id] = [traversal.resulting_soliton_graph, [], []] # add it to the dictionary
                            states.append(traversal.resulting_soliton_graph)
                        if np.array_equal(resulting_matrix, traversals[first_real_trav].adjacency_matrices_list[len(traversals[first_real_trav].adjacency_matrices_list)-1]) == False:
                                deterministic = False # two or more different soliton graphs have emerged although the same pair of exterior nodes was used
                    else: loops_num += 1
                if (len(traversals) - loops_num) &gt; 1:
                        strongly_deterministic = False # more than one soliton path was found between one pair of exterior nodes
            states_plus_traversals[state_matrix_id][1] = all_traversals # add all found traversals in this state
            states_plus_traversals[state_matrix_id][2] = num_traversals_per_burst # add number of traversals found for each burst (in this state)

        return deterministic, strongly_deterministic, states_plus_traversals

        
    def matrix_to_string(self, matrix: np.ndarray):
        &#34;&#34;&#34;Computes an ID for a matrix.

        Args:
            matrix (np.ndarray): Matrix whos ID should be computed.

        Returns:
            str: The computed ID which is a concatination of the matrix&#39;s elements in row-wise order.
        &#34;&#34;&#34;
        matrix_id = &#34;&#34;
        for row in matrix:
            row_id = &#39;&#39;.join(str(int(elem)) for elem in row)
            matrix_id = matrix_id + row_id

        return matrix_id</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata"><code class="flex name class">
<span>class <span class="ident">MultiwaveSolitonAutomata</span></span>
<span>(</span><span>soliton_graph: <a title="soliton_automata.soliton_classes.soliton_graph.SolitonGraph" href="soliton_graph.html#soliton_automata.soliton_classes.soliton_graph.SolitonGraph">SolitonGraph</a>, bursts: str, stop: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Representation of a multiwave soliton automata, which finds all traversals for a burst.</p>
<p>Initializes a <code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata">MultiwaveSolitonAutomata</a></code> object by using a soliton graph, a burst and a stop number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiwaveSolitonAutomata:
    &#34;&#34;&#34;Representation of a multiwave soliton automata, which finds all traversals for a burst.
    &#34;&#34;&#34;

    def __init__(self, soliton_graph: SolitonGraph, bursts: str, stop: int):
        &#34;&#34;&#34;Initializes a `MultiwaveSolitonAutomata` object by using a soliton graph, a burst and a stop number.
        &#34;&#34;&#34;
        self.soliton_graph: SolitonGraph = soliton_graph
        &#34;&#34;&#34;Soliton graph the automata is based on.&#34;&#34;&#34;
        self.bursts = bursts
        &#34;&#34;&#34;The set of input burst.&#34;&#34;&#34;
        self.stop = stop
        &#34;&#34;&#34;After how many equal soliton graph + soliton positions to stop searching for traversals on current path in search tree.&#34;&#34;&#34;
        self.bursts_dicts: list = self.build_bursts_dicts()
        &#34;&#34;&#34;List of the bursts as dictionaries (soliton number as key and a list containing exterior nodes and entry time as value).&#34;&#34;&#34;
        self.deterministic: bool
        &#34;&#34;&#34;Whether the multiwave soliton automata is deterministic.&#34;&#34;&#34;
        self.strongly_deterministic: bool
        &#34;&#34;&#34;Whether the multiwave soliton graph is strongly deterministic.&#34;&#34;&#34;
        self.states_plus_traversals: dict
        &#34;&#34;&#34;All states of the soliton automata plus all traversals that can be found in each state plus number of traversals found for each burst
        (Id/ string of the states adjacency matrix as key and state, traversals and list of numbers as values).&#34;&#34;&#34;
        self.deterministic, self.strongly_deterministic, self.states_plus_traversals = self.all_traversals()


    def build_bursts_dicts(self):
        &#34;&#34;&#34;Builds a list of burst dictionaries.

        Returns:
            list: The computed list of burst dictionaries.
        &#34;&#34;&#34;
        bursts = self.bursts.split(&#34;;&#34;)
        bursts_dicts = []
        for burst in bursts:
            burst = re.sub(r&#34;[{}]+&#34;, &#34;&#34;, burst)
            burst_dict = self.burst_dict(burst)
            bursts_dicts.append(burst_dict)

        return bursts_dicts

    def burst_dict(self, burst: str):
        &#34;&#34;&#34;Builds a dictionary as an internal representation of a burst.

        Args:
            burst (str): The burst string that should be turned into a dictionary.

        Returns:
            dict: The computed dictionary with soliton number as key and a list containing exterior nodes and entry time as value.
        &#34;&#34;&#34;
        burst_copy = copy.copy(burst)
        burst_dict = {}
        entry = 0 # entry time of the current soliton, is increased every time there is another soliton with a k_i
        soliton = 1 # number of the current soliton
        first = re.search(r&#34;[(][0-9]+[,][0-9]+[)]&#34;, burst_copy) # first soliton in burst
        nodes = re.findall(r&#34;[0-9]+&#34;, first.group()) # find the two exterior nodes
        burst_dict[soliton] = [self.soliton_graph.exterior_nodes_reverse[nodes[0]], self.soliton_graph.exterior_nodes_reverse[nodes[1]], 0] # first soliton entries at time step 0 (take node ids, not node labels)
        burst_copy = burst_copy[first.span()[1]:] # remove all the information on the first soliton from the burst
        while burst_copy != &#34;&#34;:
            found = re.search(r&#34;[||][0-9]+[(][0-9]+[,][0-9]+[)]&#34;, burst_copy)
            all_nums = re.findall(r&#34;[0-9]+&#34;, found.group())
            entry = entry + int(all_nums[0]) # add the current k_i to the entry time
            soliton += 1
            burst_dict[soliton] = [self.soliton_graph.exterior_nodes_reverse[all_nums[1]], self.soliton_graph.exterior_nodes_reverse[all_nums[2]], entry] # take node ids, not node labels
            burst_copy = burst_copy[found.span()[1]:] # remove from burst
            
        return burst_dict


    def build_traversals(self, travs: list, soliton_graph: SolitonGraph):
        &#34;&#34;&#34;Turns traversals into objects of class `Traversal`.

        Args:
            travs (list): Traversals that are represented as soliton positions and bindings for each timestep.
            soliton_graph (SolitonGraph): Soliton graph the traversal was found in.

        Returns:
            list: Traversals.
        &#34;&#34;&#34;
        traversals = []
        for trav in travs:
            if isinstance(trav[len(trav)-1], int): # if trav is not a real traversal but part of an endlessly looping traversal
                traversal = Traversal(soliton_graph, trav[0])
                traversals.append([traversal, trav[1]])
            else:
                traversal = Traversal(soliton_graph, trav)
                traversals.append(traversal)

        return traversals


    def change_bindings(self, bindings: dict, edge: tuple):
        &#34;&#34;&#34;Changes binding type of an edge (1 -&gt; 2 and 2 -&gt; 1).

        Args:
            bindings (dict): Current binding types of all edges in the graph.
            edge (tuple): Edge whose binding type should be changed.

        Returns:
            dict: Updated binding dictionary.
        &#34;&#34;&#34;
        if bindings[(edge[0], edge[1])] == 2:
            bindings[(edge[0], edge[1])] = 1
        else:
            bindings[(edge[0], edge[1])] = 2
            
        return bindings

    
    def find_all_travs_given_burst (self, graph: nx.Graph, burst_dict: dict, t: int, s_pos_all_timesteps: list, bindings_all_timesteps: list, binds_all_timesteps: list, travs: list):
        &#34;&#34;&#34;Finds all possible traversals for a given burst by using a recursive backtracking algorithm.

        Args:
            graph (nx.Graph): Graph the traversals should be found in.
            burst_dict (dict): The burst that is used. 
            t (int): Current timestep.
            s_pos_all_timesteps (list): Soliton positions for all past timesteps.
            bindings_all_timesteps (list): Binding types of all edges in the graph for all past timesteps.
            binds_all_timesteps (list): Binding type of the last edge that was traversed by each soliton for all past timesteps.
            travs (list): All currently found traversals.

        Returns:
            list: All found traversals (is empty if no traversal exists).
        &#34;&#34;&#34;
        t += 1
        akt_bindings = bindings_all_timesteps[t-1]
        akt_binds = binds_all_timesteps[t-1]
        akt_positions = s_pos_all_timesteps[t-1]

        finished = True
        for soliton in akt_positions:
            if (akt_positions[soliton] != burst_dict[soliton][1] and akt_positions[soliton] != -2) or s_pos_all_timesteps[t-2][soliton] == -1 or t &lt; 2: # if not all solitons reached their end node or already left the graph
                finished = False
                break
        # base case 1: if all solitons traversed the graph successfully
        if finished == True:
            trav = []
            for i, pos in enumerate(s_pos_all_timesteps):
                this_timestep = (pos, bindings_all_timesteps[i]) # for each timestep, add a tuple of the solitons&#39; positions and the bindings
                trav.append(this_timestep)
            travs.append(trav) # trav = traversal of all solitons through the graph
            return travs

        # base case 2: if some solitons are stuck in an endless loop
        count = 1
        for k in range(0, len(bindings_all_timesteps)-1):
            if akt_bindings == bindings_all_timesteps[k] and akt_positions == s_pos_all_timesteps[k]: # if we already had that exact graph and position map in this configuration trail
                count += 1
                if count == self.stop:
                    trav = []
                    for i, pos in enumerate(s_pos_all_timesteps):
                        this_timestep = (pos, bindings_all_timesteps[i])
                        trav.append(this_timestep)
                    travs.append([trav, k+1]) # append the found trav plus the loop point/ timestep (+1, because otherwise in animation we would display the loop point twice)
                    return travs
        

        # in this timestep find possible edges for each soliton individually
        possible_edges = {} # possible edges for each soliton in this timestep
        possible_nodes = {} # possible nodes for each soliton in this timestep
        for soliton in burst_dict:
            end = burst_dict[soliton][1] # end node for this soliton
            akt_pos = akt_positions[soliton] # current position of this soliton
            possible_edges[soliton] = []
            possible_nodes[soliton] = []
            if akt_pos == -2 or (akt_pos == end and s_pos_all_timesteps[t-2][soliton] != -1 and t &gt; 1): # if soliton already traversed the graph successfully
                possible_edges[soliton].append(-2)
                possible_nodes[soliton].append(-2)
            elif burst_dict[soliton][2] &gt; t: # if soliton&#39;s entry time has not come yet
                possible_edges[soliton].append(-1)
                possible_nodes[soliton].append(-1)
            elif burst_dict[soliton][2] == t: # if soliton enters the graph now (place it at its starting node)
                possible_edges[soliton].append(burst_dict[soliton][0])
                possible_nodes[soliton].append(burst_dict[soliton][0])
            else:
                for node in list(nx.neighbors(graph, akt_pos)): # iterate over all nodes that are adjacent to current position
                    # soliton can not go to an exterior node that is not the end node, soliton is not allowed to make a direct turnaround and edge to next node has to have the right binding type
                    if ((node not in self.soliton_graph.exterior_nodes) or (node == end)) and node != s_pos_all_timesteps[t-2][soliton] and akt_bindings[tuple(sorted((akt_pos, node)))] != akt_binds[soliton]:
                        possible_edges[soliton].append(tuple(sorted((akt_pos, node))))
                        possible_nodes[soliton].append(node)
        # find all possible combinations of the found edges 
        edges_combs = []
        nodes_combs = []
        for soliton in possible_edges:
            if possible_edges[soliton] == []: # if for one soliton there are no possible next edges, no combinations are possible
                edges_combs.clear()
                nodes_combs.clear()
            if soliton != 1 and not any(edges_combs): # if no possible edge combination exists anymore, terminate the loop (not any(edges_combs) makes sure list is empty or only contains empty lists)
                break
            for i, edge in enumerate(possible_edges[soliton]): # for all possible edges for this soliton
                if soliton == 1:
                    edges_combs.append([edge]) # simply add the edge if it&#39;s the first soliton
                    nodes_combs.append({soliton: possible_nodes[soliton][i]}) # add dictionary with node for this soliton
                else:
                    for j, comb in enumerate(edges_combs): # if it&#39;s not the first soliton loop over all existing combinations
                        if edge == -1 or edge == -2 or edge not in comb: # if edge is not already in combination (or soliton is outside the graph)
                            if len(comb) &lt; soliton:
                                edges_combs[j].append(edge) # add the edge if this combination doesn&#39;t contain an edge for this soliton already
                                nodes_combs[j][soliton] = possible_nodes[soliton][i]
                            else: # else copy the combination, remove the last edge (the edge for this soliton), add the edge and add this new combination
                                comb_copy = copy.deepcopy(comb)
                                comb_copy.pop()
                                comb_copy.append(edge)
                                edges_combs.append(comb_copy)
                                node_comb_copy = copy.deepcopy(nodes_combs[j])
                                node_comb_copy[soliton] = possible_nodes[soliton][i] # overwrite
                                nodes_combs.append(node_comb_copy)
                        if i == len(possible_edges[soliton])-1: # if we are looking at the last possible edge of this soliton
                            if len(comb) &lt; soliton: # and the combination does not contain an edge for each soliton
                                edges_combs[j] = [] # &#34;delete&#34; the combination
                                nodes_combs[j] = {}
        edges_combs = [elem for elem in edges_combs if elem != []]
        nodes_combs = [elem for elem in nodes_combs if elem]

        # iterate over all possible combinations
        for i, comb in enumerate(nodes_combs):
            s_pos_all_timesteps.append(comb)
            bindings = copy.deepcopy(akt_bindings)
            binds = copy.deepcopy(akt_binds)
            for j, edge in enumerate(edges_combs[i]): # for all edges in chosen combination
                if isinstance(edge, tuple): # binds and bindings only change if &#34;edge&#34; is actually an edge (if edge is -1, -2 or the start node, no edge is traversed)
                    binds[j+1] = bindings[tuple(sorted(edge))] # change bind to binding type of edge that was just traversed
                    bindings = self.change_bindings(bindings, tuple(sorted(edge))) # change bindings
            bindings_all_timesteps.append(bindings)
            binds_all_timesteps.append(binds)
            # call function recursively: if eventually all solitons reach their end node if we go further with the decision we just made then travs is changed (new traversal added)
            travs = self.find_all_travs_given_burst(graph, burst_dict, t, s_pos_all_timesteps, bindings_all_timesteps, binds_all_timesteps, travs)
            # try different decisions next, so we need variables in the state before the last decision
            s_pos_all_timesteps.pop()
            bindings_all_timesteps.pop()
            binds_all_timesteps.pop()

        return travs # if at some point no other traversal could be added, then all possible traversals are found


    def call_find_all_travs_given_burst (self, burst_dict: dict, soliton_graph: SolitonGraph):
        &#34;&#34;&#34;Initializes some parameters and then calls `find_all_travs_given_burst` with them.

        Args:
            burst_dict (dict): The burst that is used. 
            soliton_graph (SolitonGraph): Soliton graph the traversals should be found in.

        Returns:
            list: All found travs as traversals (returns empty list when no traversal is found).
        &#34;&#34;&#34;
        soliton_graph_copy = copy.deepcopy(soliton_graph) # working on copy of graph so no unwanted changes are made
        graph = soliton_graph_copy.graph
        t = 0
        bindings_all_timesteps = [soliton_graph_copy.bindings] # already add bindings for timestep 0
        soliton_positions = {}
        binds = {}
        for soliton in burst_dict:
            binds[soliton] = 0
            if burst_dict[soliton][2] == 0: # if soliton enters the graph at timestep 0
                soliton_positions[soliton] = burst_dict[soliton][0] # starts at its start node
            else:
                soliton_positions[soliton] = -1 # soliton is not in graph at timestep 0
        # already add positions and binds for timestep 0
        s_pos_all_timesteps = [soliton_positions]
        binds_all_timesteps = [binds]
        travs = []

        travs = self.find_all_travs_given_burst(graph, burst_dict, t, s_pos_all_timesteps, bindings_all_timesteps, binds_all_timesteps, travs)
        traversals = self.build_traversals(travs, soliton_graph)

        return traversals


    def all_traversals (self):
        &#34;&#34;&#34;Calls `call_find_all_travs_given_burst` for all states of the automata and all bursts in order to get all possible traversals in all states.

        Returns:
            bool: Whether the soliton automata is deterministic or not.
            bool: Whether the soliton automata is strongly deterministic or not.
            dict: All states of the soliton graph plus all traversals that can be found in each state plus number of traversals found for each burst.
        &#34;&#34;&#34;
        initial_matrix = nx.to_numpy_array(self.soliton_graph.graph)
        states = [self.soliton_graph] # stores all possible states as soliton graphs, needed to iterate over states 
        states_plus_traversals = {self.matrix_to_string(initial_matrix): [self.soliton_graph, [], []]} # stores all states plus all traversals that can be found in that state plus number of traversals found for each burst
        deterministic = True
        strongly_deterministic = True

        for state in states: # for all states/ soliton graphs of the automata
            state_matrix_id = self.matrix_to_string(nx.to_numpy_array(state.graph))
            all_traversals = []
            num_traversals_per_burst = []
            for burst_dict in self.bursts_dicts: # loop over all bursts
                traversals = self.call_find_all_travs_given_burst(burst_dict, state) # find soliton paths with all bursts
                num_traversals_per_burst.append(len(traversals))
                loops_num = 0
                first_real_trav = -1
                for t, traversal in enumerate(traversals):
                    all_traversals.append(traversal)
                    if isinstance(traversal, Traversal): # if traversal is a real traversal and no endless loop
                        if first_real_trav == -1:
                            first_real_trav = t
                        resulting_matrix = traversal.adjacency_matrices_list[len(traversal.adjacency_matrices_list)-1] # adjacency matrix of the soliton graph the traversal results in
                        resulting_matrix_id = self.matrix_to_string(resulting_matrix)
                        if resulting_matrix_id not in states_plus_traversals: # if we found a new state
                            states_plus_traversals[resulting_matrix_id] = [traversal.resulting_soliton_graph, [], []] # add it to the dictionary
                            states.append(traversal.resulting_soliton_graph)
                        if np.array_equal(resulting_matrix, traversals[first_real_trav].adjacency_matrices_list[len(traversals[first_real_trav].adjacency_matrices_list)-1]) == False:
                                deterministic = False # two or more different soliton graphs have emerged although the same pair of exterior nodes was used
                    else: loops_num += 1
                if (len(traversals) - loops_num) &gt; 1:
                        strongly_deterministic = False # more than one soliton path was found between one pair of exterior nodes
            states_plus_traversals[state_matrix_id][1] = all_traversals # add all found traversals in this state
            states_plus_traversals[state_matrix_id][2] = num_traversals_per_burst # add number of traversals found for each burst (in this state)

        return deterministic, strongly_deterministic, states_plus_traversals

        
    def matrix_to_string(self, matrix: np.ndarray):
        &#34;&#34;&#34;Computes an ID for a matrix.

        Args:
            matrix (np.ndarray): Matrix whos ID should be computed.

        Returns:
            str: The computed ID which is a concatination of the matrix&#39;s elements in row-wise order.
        &#34;&#34;&#34;
        matrix_id = &#34;&#34;
        for row in matrix:
            row_id = &#39;&#39;.join(str(int(elem)) for elem in row)
            matrix_id = matrix_id + row_id

        return matrix_id</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.bursts"><code class="name">var <span class="ident">bursts</span></code></dt>
<dd>
<div class="desc"><p>The set of input burst.</p></div>
</dd>
<dt id="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.bursts_dicts"><code class="name">var <span class="ident">bursts_dicts</span></code></dt>
<dd>
<div class="desc"><p>List of the bursts as dictionaries (soliton number as key and a list containing exterior nodes and entry time as value).</p></div>
</dd>
<dt id="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.deterministic"><code class="name">var <span class="ident">deterministic</span></code></dt>
<dd>
<div class="desc"><p>Whether the multiwave soliton automata is deterministic.</p></div>
</dd>
<dt id="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.soliton_graph"><code class="name">var <span class="ident">soliton_graph</span></code></dt>
<dd>
<div class="desc"><p>Soliton graph the automata is based on.</p></div>
</dd>
<dt id="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.states_plus_traversals"><code class="name">var <span class="ident">states_plus_traversals</span></code></dt>
<dd>
<div class="desc"><p>All states of the soliton automata plus all traversals that can be found in each state plus number of traversals found for each burst
(Id/ string of the states adjacency matrix as key and state, traversals and list of numbers as values).</p></div>
</dd>
<dt id="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.stop"><code class="name">var <span class="ident">stop</span></code></dt>
<dd>
<div class="desc"><p>After how many equal soliton graph + soliton positions to stop searching for traversals on current path in search tree.</p></div>
</dd>
<dt id="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.strongly_deterministic"><code class="name">var <span class="ident">strongly_deterministic</span></code></dt>
<dd>
<div class="desc"><p>Whether the multiwave soliton graph is strongly deterministic.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.all_traversals"><code class="name flex">
<span>def <span class="ident">all_traversals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls <code>call_find_all_travs_given_burst</code> for all states of the automata and all bursts in order to get all possible traversals in all states.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the soliton automata is deterministic or not.</dd>
<dt><code>bool</code></dt>
<dd>Whether the soliton automata is strongly deterministic or not.</dd>
<dt><code>dict</code></dt>
<dd>All states of the soliton graph plus all traversals that can be found in each state plus number of traversals found for each burst.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_traversals (self):
    &#34;&#34;&#34;Calls `call_find_all_travs_given_burst` for all states of the automata and all bursts in order to get all possible traversals in all states.

    Returns:
        bool: Whether the soliton automata is deterministic or not.
        bool: Whether the soliton automata is strongly deterministic or not.
        dict: All states of the soliton graph plus all traversals that can be found in each state plus number of traversals found for each burst.
    &#34;&#34;&#34;
    initial_matrix = nx.to_numpy_array(self.soliton_graph.graph)
    states = [self.soliton_graph] # stores all possible states as soliton graphs, needed to iterate over states 
    states_plus_traversals = {self.matrix_to_string(initial_matrix): [self.soliton_graph, [], []]} # stores all states plus all traversals that can be found in that state plus number of traversals found for each burst
    deterministic = True
    strongly_deterministic = True

    for state in states: # for all states/ soliton graphs of the automata
        state_matrix_id = self.matrix_to_string(nx.to_numpy_array(state.graph))
        all_traversals = []
        num_traversals_per_burst = []
        for burst_dict in self.bursts_dicts: # loop over all bursts
            traversals = self.call_find_all_travs_given_burst(burst_dict, state) # find soliton paths with all bursts
            num_traversals_per_burst.append(len(traversals))
            loops_num = 0
            first_real_trav = -1
            for t, traversal in enumerate(traversals):
                all_traversals.append(traversal)
                if isinstance(traversal, Traversal): # if traversal is a real traversal and no endless loop
                    if first_real_trav == -1:
                        first_real_trav = t
                    resulting_matrix = traversal.adjacency_matrices_list[len(traversal.adjacency_matrices_list)-1] # adjacency matrix of the soliton graph the traversal results in
                    resulting_matrix_id = self.matrix_to_string(resulting_matrix)
                    if resulting_matrix_id not in states_plus_traversals: # if we found a new state
                        states_plus_traversals[resulting_matrix_id] = [traversal.resulting_soliton_graph, [], []] # add it to the dictionary
                        states.append(traversal.resulting_soliton_graph)
                    if np.array_equal(resulting_matrix, traversals[first_real_trav].adjacency_matrices_list[len(traversals[first_real_trav].adjacency_matrices_list)-1]) == False:
                            deterministic = False # two or more different soliton graphs have emerged although the same pair of exterior nodes was used
                else: loops_num += 1
            if (len(traversals) - loops_num) &gt; 1:
                    strongly_deterministic = False # more than one soliton path was found between one pair of exterior nodes
        states_plus_traversals[state_matrix_id][1] = all_traversals # add all found traversals in this state
        states_plus_traversals[state_matrix_id][2] = num_traversals_per_burst # add number of traversals found for each burst (in this state)

    return deterministic, strongly_deterministic, states_plus_traversals</code></pre>
</details>
</dd>
<dt id="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.build_bursts_dicts"><code class="name flex">
<span>def <span class="ident">build_bursts_dicts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds a list of burst dictionaries.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>The computed list of burst dictionaries.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_bursts_dicts(self):
    &#34;&#34;&#34;Builds a list of burst dictionaries.

    Returns:
        list: The computed list of burst dictionaries.
    &#34;&#34;&#34;
    bursts = self.bursts.split(&#34;;&#34;)
    bursts_dicts = []
    for burst in bursts:
        burst = re.sub(r&#34;[{}]+&#34;, &#34;&#34;, burst)
        burst_dict = self.burst_dict(burst)
        bursts_dicts.append(burst_dict)

    return bursts_dicts</code></pre>
</details>
</dd>
<dt id="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.build_traversals"><code class="name flex">
<span>def <span class="ident">build_traversals</span></span>(<span>self, travs: list, soliton_graph: <a title="soliton_automata.soliton_classes.soliton_graph.SolitonGraph" href="soliton_graph.html#soliton_automata.soliton_classes.soliton_graph.SolitonGraph">SolitonGraph</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Turns traversals into objects of class <code>Traversal</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>travs</code></strong> :&ensp;<code>list</code></dt>
<dd>Traversals that are represented as soliton positions and bindings for each timestep.</dd>
<dt><strong><code>soliton_graph</code></strong> :&ensp;<code>SolitonGraph</code></dt>
<dd>Soliton graph the traversal was found in.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Traversals.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_traversals(self, travs: list, soliton_graph: SolitonGraph):
    &#34;&#34;&#34;Turns traversals into objects of class `Traversal`.

    Args:
        travs (list): Traversals that are represented as soliton positions and bindings for each timestep.
        soliton_graph (SolitonGraph): Soliton graph the traversal was found in.

    Returns:
        list: Traversals.
    &#34;&#34;&#34;
    traversals = []
    for trav in travs:
        if isinstance(trav[len(trav)-1], int): # if trav is not a real traversal but part of an endlessly looping traversal
            traversal = Traversal(soliton_graph, trav[0])
            traversals.append([traversal, trav[1]])
        else:
            traversal = Traversal(soliton_graph, trav)
            traversals.append(traversal)

    return traversals</code></pre>
</details>
</dd>
<dt id="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.burst_dict"><code class="name flex">
<span>def <span class="ident">burst_dict</span></span>(<span>self, burst: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds a dictionary as an internal representation of a burst.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>burst</code></strong> :&ensp;<code>str</code></dt>
<dd>The burst string that should be turned into a dictionary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>The computed dictionary with soliton number as key and a list containing exterior nodes and entry time as value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def burst_dict(self, burst: str):
    &#34;&#34;&#34;Builds a dictionary as an internal representation of a burst.

    Args:
        burst (str): The burst string that should be turned into a dictionary.

    Returns:
        dict: The computed dictionary with soliton number as key and a list containing exterior nodes and entry time as value.
    &#34;&#34;&#34;
    burst_copy = copy.copy(burst)
    burst_dict = {}
    entry = 0 # entry time of the current soliton, is increased every time there is another soliton with a k_i
    soliton = 1 # number of the current soliton
    first = re.search(r&#34;[(][0-9]+[,][0-9]+[)]&#34;, burst_copy) # first soliton in burst
    nodes = re.findall(r&#34;[0-9]+&#34;, first.group()) # find the two exterior nodes
    burst_dict[soliton] = [self.soliton_graph.exterior_nodes_reverse[nodes[0]], self.soliton_graph.exterior_nodes_reverse[nodes[1]], 0] # first soliton entries at time step 0 (take node ids, not node labels)
    burst_copy = burst_copy[first.span()[1]:] # remove all the information on the first soliton from the burst
    while burst_copy != &#34;&#34;:
        found = re.search(r&#34;[||][0-9]+[(][0-9]+[,][0-9]+[)]&#34;, burst_copy)
        all_nums = re.findall(r&#34;[0-9]+&#34;, found.group())
        entry = entry + int(all_nums[0]) # add the current k_i to the entry time
        soliton += 1
        burst_dict[soliton] = [self.soliton_graph.exterior_nodes_reverse[all_nums[1]], self.soliton_graph.exterior_nodes_reverse[all_nums[2]], entry] # take node ids, not node labels
        burst_copy = burst_copy[found.span()[1]:] # remove from burst
        
    return burst_dict</code></pre>
</details>
</dd>
<dt id="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.call_find_all_travs_given_burst"><code class="name flex">
<span>def <span class="ident">call_find_all_travs_given_burst</span></span>(<span>self, burst_dict: dict, soliton_graph: <a title="soliton_automata.soliton_classes.soliton_graph.SolitonGraph" href="soliton_graph.html#soliton_automata.soliton_classes.soliton_graph.SolitonGraph">SolitonGraph</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes some parameters and then calls <code>find_all_travs_given_burst</code> with them.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>burst_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>The burst that is used. </dd>
<dt><strong><code>soliton_graph</code></strong> :&ensp;<code>SolitonGraph</code></dt>
<dd>Soliton graph the traversals should be found in.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>All found travs as traversals (returns empty list when no traversal is found).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_find_all_travs_given_burst (self, burst_dict: dict, soliton_graph: SolitonGraph):
    &#34;&#34;&#34;Initializes some parameters and then calls `find_all_travs_given_burst` with them.

    Args:
        burst_dict (dict): The burst that is used. 
        soliton_graph (SolitonGraph): Soliton graph the traversals should be found in.

    Returns:
        list: All found travs as traversals (returns empty list when no traversal is found).
    &#34;&#34;&#34;
    soliton_graph_copy = copy.deepcopy(soliton_graph) # working on copy of graph so no unwanted changes are made
    graph = soliton_graph_copy.graph
    t = 0
    bindings_all_timesteps = [soliton_graph_copy.bindings] # already add bindings for timestep 0
    soliton_positions = {}
    binds = {}
    for soliton in burst_dict:
        binds[soliton] = 0
        if burst_dict[soliton][2] == 0: # if soliton enters the graph at timestep 0
            soliton_positions[soliton] = burst_dict[soliton][0] # starts at its start node
        else:
            soliton_positions[soliton] = -1 # soliton is not in graph at timestep 0
    # already add positions and binds for timestep 0
    s_pos_all_timesteps = [soliton_positions]
    binds_all_timesteps = [binds]
    travs = []

    travs = self.find_all_travs_given_burst(graph, burst_dict, t, s_pos_all_timesteps, bindings_all_timesteps, binds_all_timesteps, travs)
    traversals = self.build_traversals(travs, soliton_graph)

    return traversals</code></pre>
</details>
</dd>
<dt id="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.change_bindings"><code class="name flex">
<span>def <span class="ident">change_bindings</span></span>(<span>self, bindings: dict, edge: tuple)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes binding type of an edge (1 -&gt; 2 and 2 -&gt; 1).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bindings</code></strong> :&ensp;<code>dict</code></dt>
<dd>Current binding types of all edges in the graph.</dd>
<dt><strong><code>edge</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Edge whose binding type should be changed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Updated binding dictionary.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_bindings(self, bindings: dict, edge: tuple):
    &#34;&#34;&#34;Changes binding type of an edge (1 -&gt; 2 and 2 -&gt; 1).

    Args:
        bindings (dict): Current binding types of all edges in the graph.
        edge (tuple): Edge whose binding type should be changed.

    Returns:
        dict: Updated binding dictionary.
    &#34;&#34;&#34;
    if bindings[(edge[0], edge[1])] == 2:
        bindings[(edge[0], edge[1])] = 1
    else:
        bindings[(edge[0], edge[1])] = 2
        
    return bindings</code></pre>
</details>
</dd>
<dt id="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.find_all_travs_given_burst"><code class="name flex">
<span>def <span class="ident">find_all_travs_given_burst</span></span>(<span>self, graph: networkx.classes.graph.Graph, burst_dict: dict, t: int, s_pos_all_timesteps: list, bindings_all_timesteps: list, binds_all_timesteps: list, travs: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds all possible traversals for a given burst by using a recursive backtracking algorithm.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>nx.Graph</code></dt>
<dd>Graph the traversals should be found in.</dd>
<dt><strong><code>burst_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>The burst that is used. </dd>
<dt><strong><code>t</code></strong> :&ensp;<code>int</code></dt>
<dd>Current timestep.</dd>
<dt><strong><code>s_pos_all_timesteps</code></strong> :&ensp;<code>list</code></dt>
<dd>Soliton positions for all past timesteps.</dd>
<dt><strong><code>bindings_all_timesteps</code></strong> :&ensp;<code>list</code></dt>
<dd>Binding types of all edges in the graph for all past timesteps.</dd>
<dt><strong><code>binds_all_timesteps</code></strong> :&ensp;<code>list</code></dt>
<dd>Binding type of the last edge that was traversed by each soliton for all past timesteps.</dd>
<dt><strong><code>travs</code></strong> :&ensp;<code>list</code></dt>
<dd>All currently found traversals.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>All found traversals (is empty if no traversal exists).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_all_travs_given_burst (self, graph: nx.Graph, burst_dict: dict, t: int, s_pos_all_timesteps: list, bindings_all_timesteps: list, binds_all_timesteps: list, travs: list):
    &#34;&#34;&#34;Finds all possible traversals for a given burst by using a recursive backtracking algorithm.

    Args:
        graph (nx.Graph): Graph the traversals should be found in.
        burst_dict (dict): The burst that is used. 
        t (int): Current timestep.
        s_pos_all_timesteps (list): Soliton positions for all past timesteps.
        bindings_all_timesteps (list): Binding types of all edges in the graph for all past timesteps.
        binds_all_timesteps (list): Binding type of the last edge that was traversed by each soliton for all past timesteps.
        travs (list): All currently found traversals.

    Returns:
        list: All found traversals (is empty if no traversal exists).
    &#34;&#34;&#34;
    t += 1
    akt_bindings = bindings_all_timesteps[t-1]
    akt_binds = binds_all_timesteps[t-1]
    akt_positions = s_pos_all_timesteps[t-1]

    finished = True
    for soliton in akt_positions:
        if (akt_positions[soliton] != burst_dict[soliton][1] and akt_positions[soliton] != -2) or s_pos_all_timesteps[t-2][soliton] == -1 or t &lt; 2: # if not all solitons reached their end node or already left the graph
            finished = False
            break
    # base case 1: if all solitons traversed the graph successfully
    if finished == True:
        trav = []
        for i, pos in enumerate(s_pos_all_timesteps):
            this_timestep = (pos, bindings_all_timesteps[i]) # for each timestep, add a tuple of the solitons&#39; positions and the bindings
            trav.append(this_timestep)
        travs.append(trav) # trav = traversal of all solitons through the graph
        return travs

    # base case 2: if some solitons are stuck in an endless loop
    count = 1
    for k in range(0, len(bindings_all_timesteps)-1):
        if akt_bindings == bindings_all_timesteps[k] and akt_positions == s_pos_all_timesteps[k]: # if we already had that exact graph and position map in this configuration trail
            count += 1
            if count == self.stop:
                trav = []
                for i, pos in enumerate(s_pos_all_timesteps):
                    this_timestep = (pos, bindings_all_timesteps[i])
                    trav.append(this_timestep)
                travs.append([trav, k+1]) # append the found trav plus the loop point/ timestep (+1, because otherwise in animation we would display the loop point twice)
                return travs
    

    # in this timestep find possible edges for each soliton individually
    possible_edges = {} # possible edges for each soliton in this timestep
    possible_nodes = {} # possible nodes for each soliton in this timestep
    for soliton in burst_dict:
        end = burst_dict[soliton][1] # end node for this soliton
        akt_pos = akt_positions[soliton] # current position of this soliton
        possible_edges[soliton] = []
        possible_nodes[soliton] = []
        if akt_pos == -2 or (akt_pos == end and s_pos_all_timesteps[t-2][soliton] != -1 and t &gt; 1): # if soliton already traversed the graph successfully
            possible_edges[soliton].append(-2)
            possible_nodes[soliton].append(-2)
        elif burst_dict[soliton][2] &gt; t: # if soliton&#39;s entry time has not come yet
            possible_edges[soliton].append(-1)
            possible_nodes[soliton].append(-1)
        elif burst_dict[soliton][2] == t: # if soliton enters the graph now (place it at its starting node)
            possible_edges[soliton].append(burst_dict[soliton][0])
            possible_nodes[soliton].append(burst_dict[soliton][0])
        else:
            for node in list(nx.neighbors(graph, akt_pos)): # iterate over all nodes that are adjacent to current position
                # soliton can not go to an exterior node that is not the end node, soliton is not allowed to make a direct turnaround and edge to next node has to have the right binding type
                if ((node not in self.soliton_graph.exterior_nodes) or (node == end)) and node != s_pos_all_timesteps[t-2][soliton] and akt_bindings[tuple(sorted((akt_pos, node)))] != akt_binds[soliton]:
                    possible_edges[soliton].append(tuple(sorted((akt_pos, node))))
                    possible_nodes[soliton].append(node)
    # find all possible combinations of the found edges 
    edges_combs = []
    nodes_combs = []
    for soliton in possible_edges:
        if possible_edges[soliton] == []: # if for one soliton there are no possible next edges, no combinations are possible
            edges_combs.clear()
            nodes_combs.clear()
        if soliton != 1 and not any(edges_combs): # if no possible edge combination exists anymore, terminate the loop (not any(edges_combs) makes sure list is empty or only contains empty lists)
            break
        for i, edge in enumerate(possible_edges[soliton]): # for all possible edges for this soliton
            if soliton == 1:
                edges_combs.append([edge]) # simply add the edge if it&#39;s the first soliton
                nodes_combs.append({soliton: possible_nodes[soliton][i]}) # add dictionary with node for this soliton
            else:
                for j, comb in enumerate(edges_combs): # if it&#39;s not the first soliton loop over all existing combinations
                    if edge == -1 or edge == -2 or edge not in comb: # if edge is not already in combination (or soliton is outside the graph)
                        if len(comb) &lt; soliton:
                            edges_combs[j].append(edge) # add the edge if this combination doesn&#39;t contain an edge for this soliton already
                            nodes_combs[j][soliton] = possible_nodes[soliton][i]
                        else: # else copy the combination, remove the last edge (the edge for this soliton), add the edge and add this new combination
                            comb_copy = copy.deepcopy(comb)
                            comb_copy.pop()
                            comb_copy.append(edge)
                            edges_combs.append(comb_copy)
                            node_comb_copy = copy.deepcopy(nodes_combs[j])
                            node_comb_copy[soliton] = possible_nodes[soliton][i] # overwrite
                            nodes_combs.append(node_comb_copy)
                    if i == len(possible_edges[soliton])-1: # if we are looking at the last possible edge of this soliton
                        if len(comb) &lt; soliton: # and the combination does not contain an edge for each soliton
                            edges_combs[j] = [] # &#34;delete&#34; the combination
                            nodes_combs[j] = {}
    edges_combs = [elem for elem in edges_combs if elem != []]
    nodes_combs = [elem for elem in nodes_combs if elem]

    # iterate over all possible combinations
    for i, comb in enumerate(nodes_combs):
        s_pos_all_timesteps.append(comb)
        bindings = copy.deepcopy(akt_bindings)
        binds = copy.deepcopy(akt_binds)
        for j, edge in enumerate(edges_combs[i]): # for all edges in chosen combination
            if isinstance(edge, tuple): # binds and bindings only change if &#34;edge&#34; is actually an edge (if edge is -1, -2 or the start node, no edge is traversed)
                binds[j+1] = bindings[tuple(sorted(edge))] # change bind to binding type of edge that was just traversed
                bindings = self.change_bindings(bindings, tuple(sorted(edge))) # change bindings
        bindings_all_timesteps.append(bindings)
        binds_all_timesteps.append(binds)
        # call function recursively: if eventually all solitons reach their end node if we go further with the decision we just made then travs is changed (new traversal added)
        travs = self.find_all_travs_given_burst(graph, burst_dict, t, s_pos_all_timesteps, bindings_all_timesteps, binds_all_timesteps, travs)
        # try different decisions next, so we need variables in the state before the last decision
        s_pos_all_timesteps.pop()
        bindings_all_timesteps.pop()
        binds_all_timesteps.pop()

    return travs # if at some point no other traversal could be added, then all possible traversals are found</code></pre>
</details>
</dd>
<dt id="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.matrix_to_string"><code class="name flex">
<span>def <span class="ident">matrix_to_string</span></span>(<span>self, matrix: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes an ID for a matrix.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>matrix</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Matrix whos ID should be computed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The computed ID which is a concatination of the matrix's elements in row-wise order.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matrix_to_string(self, matrix: np.ndarray):
    &#34;&#34;&#34;Computes an ID for a matrix.

    Args:
        matrix (np.ndarray): Matrix whos ID should be computed.

    Returns:
        str: The computed ID which is a concatination of the matrix&#39;s elements in row-wise order.
    &#34;&#34;&#34;
    matrix_id = &#34;&#34;
    for row in matrix:
        row_id = &#39;&#39;.join(str(int(elem)) for elem in row)
        matrix_id = matrix_id + row_id

    return matrix_id</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="soliton_automata.soliton_classes" href="index.html">soliton_automata.soliton_classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata">MultiwaveSolitonAutomata</a></code></h4>
<ul class="">
<li><code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.all_traversals" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.all_traversals">all_traversals</a></code></li>
<li><code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.build_bursts_dicts" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.build_bursts_dicts">build_bursts_dicts</a></code></li>
<li><code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.build_traversals" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.build_traversals">build_traversals</a></code></li>
<li><code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.burst_dict" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.burst_dict">burst_dict</a></code></li>
<li><code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.bursts" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.bursts">bursts</a></code></li>
<li><code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.bursts_dicts" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.bursts_dicts">bursts_dicts</a></code></li>
<li><code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.call_find_all_travs_given_burst" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.call_find_all_travs_given_burst">call_find_all_travs_given_burst</a></code></li>
<li><code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.change_bindings" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.change_bindings">change_bindings</a></code></li>
<li><code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.deterministic" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.deterministic">deterministic</a></code></li>
<li><code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.find_all_travs_given_burst" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.find_all_travs_given_burst">find_all_travs_given_burst</a></code></li>
<li><code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.matrix_to_string" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.matrix_to_string">matrix_to_string</a></code></li>
<li><code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.soliton_graph" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.soliton_graph">soliton_graph</a></code></li>
<li><code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.states_plus_traversals" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.states_plus_traversals">states_plus_traversals</a></code></li>
<li><code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.stop" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.stop">stop</a></code></li>
<li><code><a title="soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.strongly_deterministic" href="#soliton_automata.soliton_classes.multiwave_soliton_automata.MultiwaveSolitonAutomata.strongly_deterministic">strongly_deterministic</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>