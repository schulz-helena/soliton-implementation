<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>soliton_automata.gui.main_window_ba API documentation</title>
<meta name="description" content="GUI of the software." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>soliton_automata.gui.main_window_ba</code></h1>
</header>
<section id="section-intro">
<p>GUI of the software.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;GUI of the software.
 &#34;&#34;&#34;
import copy
import io
import math
import os
import re

import networkx as nx
from PIL.ImageQt import ImageQt
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QDialog, QMainWindow, QMessageBox, QScrollArea

import soliton_automata.res.resources
from soliton_automata.gui.startscreen import Startscreen
from soliton_automata.soliton_classes.multiwave_soliton_automata import \
    MultiwaveSolitonAutomata
from soliton_automata.soliton_classes.soliton_automata import SolitonAutomata
from soliton_automata.soliton_classes.soliton_graph import SolitonGraph
from soliton_automata.soliton_classes.soliton_path import SolitonPath
from soliton_automata.soliton_classes.traversal import Traversal
from soliton_automata.visualisations.animation import Animation
from soliton_automata.visualisations.visualisation import Visualisation


class MainWindow(QMainWindow):
    &#34;&#34;&#34;Main Window of the GUI. Inherits from class `QMainWindow`.
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;Initializes the main window.
        Main window contains a stacked layout with one window for single soliton case and one window for multi soliton case.
        Both display a welcoming text and all necessary widgets for the user to specify and submit a soliton graph.
        All other widgets are hidden for now and are revealed step by step, so user is guided through the use of the application.
        &#34;&#34;&#34;
        super(MainWindow, self).__init__()
        self.setObjectName(&#34;MainWindow&#34;)
        # central widget is a stacked layout (so user can switch between the two different windows)
        self.central_wid = QtWidgets.QWidget()
        self.layout_for_wids = QtWidgets.QStackedLayout()
        self.central_wid.setStyleSheet(&#34;&#34;&#34;background: white;&#34;&#34;&#34;)
        # move window to the top of the screen + to the center horizontally
        qt_rectangle = self.frameGeometry()
        center_point = QtWidgets.QDesktopWidget().availableGeometry().center()
        qt_rectangle.moveCenter(center_point)
        self.move(qt_rectangle.topLeft().x(), 0)
        self.resize(QtCore.QSize(600, 650))


        # SOLITON AUTOMATA WIDGET
        self.wid_single = QtWidgets.QWidget()
        self.gridLayout = QtWidgets.QGridLayout(self.wid_single)
        # Row 0:
        # Rectangle that displays the molecule
        self.display_molecule = QtWidgets.QLabel(self.wid_single)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Ignored)
        self.display_molecule.setSizePolicy(sizePolicy)
        self.display_molecule.setMinimumSize(QtCore.QSize(50, 37))
        startscreen = Startscreen().image
        self.qim = ImageQt(startscreen)
        self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(self.display_molecule.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
        self.gridLayout.addWidget(self.display_molecule, 0, 0, 2, 5, alignment = QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter)
        # Button that changes between the two windows
        self.change_window_button = QtWidgets.QPushButton(&#34;Switch Mode&#34;)
        self.change_window_button.setMinimumSize(QtCore.QSize(0, 20))
        self.gridLayout.addWidget(self.change_window_button, 0, 0, 1, 1)
        self.change_window_button.setStyleSheet(&#34;QPushButton {border-radius: 10px;}&#34;)
        # Row 1: -
        # Row 2:
        # &#34;Traversal Mode&#34; Checkbox
        self.traversal_mode = QtWidgets.QCheckBox(&#34;Traversal Mode&#34;)
        self.traversal_mode.setChecked(False)
        self.gridLayout.addWidget(self.traversal_mode, 2, 0, 1, 1)
        # Groupbox containg last two elements of row 2
        self.row2 = QtWidgets.QGroupBox()
        self.minigrid2 = QtWidgets.QGridLayout(self.row2)
        self.minigrid2.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.addWidget(self.row2, 2, 3, 1, 1)
        # Info button
        self.mol_info = QtWidgets.QPushButton(self.wid_single)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.mol_info.setSizePolicy(sizePolicy)
        self.mol_info.setMinimumSize(QtCore.QSize(0, 32))
        self.minigrid2.addWidget(self.mol_info, 2, 0, 1, 1)
        # Save button for the molecule
        self.save = QtWidgets.QPushButton(self.wid_single)
        self.save.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.save.setSizePolicy(sizePolicy)
        self.save.setMaximumSize(QtCore.QSize(16777215, 32))
        self.save.setMinimumSize(QtCore.QSize(0, 32))
        self.minigrid2.addWidget(self.save, 2, 1, 1, 1)
        # Row 3:
        # &#34;Molecule&#34; label
        self.molecule_label = QtWidgets.QLabel(self.wid_single)
        self.gridLayout.addWidget(self.molecule_label, 3, 0, 1, 1)
        # Groupbox containg middle two elements of row 3
        self.row3 = QtWidgets.QGroupBox()
        self.minigrid3 = QtWidgets.QGridLayout(self.row3)
        self.minigrid3.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.addWidget(self.row3, 3, 1, 1, 2)
        # Text field for molecule
        self.molecule_lineedit = QtWidgets.QLineEdit(self.row3)
        self.minigrid3.addWidget(self.molecule_lineedit, 0, 0, 1, 1)
        # Groupbox containg &#34;stop number&#34; widgets
        self.row3_2 = QtWidgets.QGroupBox()
        self.minigrid3_2 = QtWidgets.QGridLayout(self.row3_2)
        self.minigrid3_2.setContentsMargins(0, 0, 0, 0)
        self.minigrid3.addWidget(self.row3_2, 0, 1, 1, 1)
        # &#34;Stop number&#34; label
        self.stop_number_label = QtWidgets.QLabel(self.row3_2)
        self.minigrid3_2.addWidget(self.stop_number_label, 0, 0, 1, 1)
        # Spinbox for &#34;stop number&#34;
        self.stop_number_spinbox = QtWidgets.QSpinBox(self.row3_2)
        self.stop_number_spinbox.setValue(3)
        self.stop_number_spinbox.setMinimum(2)
        self.minigrid3_2.addWidget(self.stop_number_spinbox, 0, 1, 1, 1)
        # Submit button for molecule
        self.submit_molecule = QtWidgets.QPushButton(self.wid_single)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.submit_molecule.setSizePolicy(sizePolicy)
        self.submit_molecule.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout.addWidget(self.submit_molecule, 3, 3, 1, 1)
        # Row 4: 
        # &#34;Exterior nodes&#34; label
        self.exterior_nodes_label = QtWidgets.QLabel(self.wid_single)
        self.gridLayout.addWidget(self.exterior_nodes_label, 4, 0, 1, 1)
        # Groupbox containg middle elements of row 4
        self.row4 = QtWidgets.QGroupBox()
        self.minigrid4 = QtWidgets.QGridLayout(self.row4)
        self.minigrid4.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.addWidget(self.row4, 4, 1, 1, 2)
        # &#34;All&#34; Checkbox
        self.all_exterior_nodes = QtWidgets.QCheckBox(&#34;All&#34;)
        self.all_exterior_nodes.setChecked(False)
        self.minigrid4.addWidget(self.all_exterior_nodes, 4, 0, 1, 1)
        # Combobox to choose first exterior node
        self.node_1 = QtWidgets.QComboBox(self.row4)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.node_1.setSizePolicy(sizePolicy)
        self.minigrid4.addWidget(self.node_1, 4, 1, 1, 1)
        # &#34;&amp;&#34; label
        self.exterior_nodes_label2 = QtWidgets.QLabel(self.row4)
        self.minigrid4.addWidget(self.exterior_nodes_label2, 4, 2, 1, 1)
        # Combobox to choose second exterior node
        self.node_2 = QtWidgets.QComboBox(self.row4)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.node_2.setSizePolicy(sizePolicy)
        self.minigrid4.addWidget(self.node_2, 4, 3, 1, 1)
        # Submit button for exterior nodes
        self.submit_exterior_nodes = QtWidgets.QPushButton(self.wid_single)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.submit_exterior_nodes.setSizePolicy(sizePolicy)
        self.submit_exterior_nodes.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout.addWidget(self.submit_exterior_nodes, 4, 3, 1, 1)
        # Row 5:
        # &#34;Soliton paths&#34; label
        self.soliton_paths_label = QtWidgets.QLabel(self.wid_single)
        self.gridLayout.addWidget(self.soliton_paths_label, 5, 0, 1, 1)
        # Groupbox containg middle elements of row 5
        self.row5 = QtWidgets.QGroupBox()
        self.minigrid5 = QtWidgets.QGridLayout(self.row5)
        self.minigrid5.setContentsMargins(0, 0, 0, 0)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.row5.setSizePolicy(sizePolicy)
        self.row5.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout.addWidget(self.row5, 5, 1, 1, 3)
        # &#34;Loops&#34; checkbox
        self.if_loops = QtWidgets.QCheckBox(&#34;Loops&#34;)
        self.if_loops.setChecked(True)
        self.if_loops.setFixedWidth(68)
        self.minigrid5.addWidget(self.if_loops, 5, 0, 1, 1)
        # Combobox to choose a soliton path
        self.paths = QtWidgets.QComboBox(self.row5)
        self.minigrid5.addWidget(self.paths, 5, 1, 1, 2)
        # Row 6:
        # &#34;Show matrices&#34; button
        self.show_matrices = QtWidgets.QPushButton(self.wid_single)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.show_matrices.setSizePolicy(sizePolicy)
        self.show_matrices.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout.addWidget(self.show_matrices, 6, 1, 1, 1)
        # &#34;Show end result&#34; button
        self.show_end_result = QtWidgets.QPushButton(self.wid_single)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.show_end_result.setSizePolicy(sizePolicy)
        self.show_end_result.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout.addWidget(self.show_end_result, 6, 2, 1, 1)
        # &#34;Show animation&#34; button
        self.show_animation = QtWidgets.QPushButton(self.wid_single)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.show_animation.setSizePolicy(sizePolicy)
        self.show_animation.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout.addWidget(self.show_animation, 6, 3, 1, 1)
        # Menubar:
        self.menubar = QtWidgets.QMenuBar(self)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 564, 24))
        self.setMenuBar(self.menubar)

        # Function connections of different widgets:
        self.change_window_button.clicked.connect(self.change_window)
        self.traversal_mode.stateChanged.connect(lambda:self.change_mode(self.traversal_mode))
        self.mol_info.clicked.connect(self.mol_info_clicked)
        self.save.clicked.connect(self.save_clicked)
        self.submit_molecule.clicked.connect(self.submit_molecule_clicked)
        self.all_exterior_nodes.stateChanged.connect(self.all_exterior_nodes_statechanged)
        self.submit_exterior_nodes.clicked.connect(self.submit_exterior_nodes_clicked)
        self.if_loops.stateChanged.connect(lambda:self.loops_onoff(self.if_loops))
        self.paths.currentIndexChanged.connect(lambda: self.endless_loop_picked(self.paths))
        self.show_matrices.clicked.connect(self.show_matrices_clicked)
        self.show_end_result.clicked.connect(self.show_end_result_clicked)
        self.show_animation.clicked.connect(lambda:self.show_animation_clicked(self.show_animation))
        # Hide most widgets at the beginning (while retaining space) 
        self.hide_retain_space([self.traversal_mode, self.row2, self.exterior_nodes_label, self.row4, self.submit_exterior_nodes, self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
        self.hide_multiple([self.traversal_mode, self.row2, self.exterior_nodes_label, self.row4, self.submit_exterior_nodes, self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
        # Stylesheet:
        readme_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), &#39;../styles.css&#39;)
        with open(readme_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as fh:
            self.style = fh.read()
        self.wid_single.setStyleSheet(self.style)


        # MULTI-WAVE SOLITON AUTOMATA WIDGET
        self.wid_mult = QtWidgets.QWidget()
        self.gridLayout_m = QtWidgets.QGridLayout(self.wid_mult)
        # Row 0:
        # Rectangle that displays the molecule
        self.display_molecule_m = QtWidgets.QLabel(self.wid_mult)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Ignored)
        self.display_molecule_m.setSizePolicy(sizePolicy)
        self.display_molecule_m.setMinimumSize(QtCore.QSize(50, 37))
        startscreen_m = Startscreen().image
        self.qim_m = ImageQt(startscreen_m)
        self.display_molecule_m.setPixmap(QtGui.QPixmap.fromImage(self.qim_m).scaled(self.display_molecule_m.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
        self.gridLayout_m.addWidget(self.display_molecule_m, 0, 0, 2, 5, alignment = QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter)
        # Button that changes between the two windows
        self.change_window_button_m = QtWidgets.QPushButton(&#34;Switch Mode&#34;)
        self.change_window_button_m.setMinimumSize(QtCore.QSize(0, 20))
        self.gridLayout_m.addWidget(self.change_window_button_m, 0, 0, 1, 1)
        self.change_window_button_m.setStyleSheet(&#34;QPushButton {border-radius: 10px;}&#34;)
        # Row 1: -
        # Row 2:
        # &#34;Traversal Mode&#34; Checkbox
        self.traversal_mode_m = QtWidgets.QCheckBox(&#34;Traversal Mode&#34;)
        self.traversal_mode_m.setChecked(False)
        self.gridLayout_m.addWidget(self.traversal_mode_m, 2, 0, 1, 1)
        # Groupbox containg last two elements of row 2
        self.row2_m = QtWidgets.QGroupBox()
        self.minigrid2_m = QtWidgets.QGridLayout(self.row2_m)
        self.minigrid2_m.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_m.addWidget(self.row2_m, 2, 3, 1, 1)
        # Info button
        self.mol_info_m = QtWidgets.QPushButton(self.row2_m)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.mol_info_m.setSizePolicy(sizePolicy)
        self.mol_info_m.setMinimumSize(QtCore.QSize(0, 32))
        self.minigrid2_m.addWidget(self.mol_info_m, 2, 0, 1, 1)
        # Save button for the molecule
        self.save_m = QtWidgets.QPushButton(self.row2_m)
        self.save_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.save_m.setSizePolicy(sizePolicy)
        self.save_m.setMaximumSize(QtCore.QSize(16777215, 32))
        self.save_m.setMinimumSize(QtCore.QSize(0, 32))
        self.minigrid2_m.addWidget(self.save_m, 2, 1, 1, 1)
        # Row 3:
        # &#34;Molecule&#34; label
        self.molecule_label_m = QtWidgets.QLabel(self.wid_mult)
        self.gridLayout_m.addWidget(self.molecule_label_m, 3, 0, 1, 1)
        # Text field for molecule
        self.molecule_lineedit_m = QtWidgets.QLineEdit(self.wid_mult)
        self.gridLayout_m.addWidget(self.molecule_lineedit_m, 3, 1, 1, 2)
        # Submit button for molecule
        self.submit_molecule_m = QtWidgets.QPushButton(self.wid_mult)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.submit_molecule_m.setSizePolicy(sizePolicy)
        self.submit_molecule_m.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout_m.addWidget(self.submit_molecule_m, 3, 3, 1, 1)
        # Row 4: 
        # &#34;Set of bursts&#34; label
        self.set_of_bursts_label = QtWidgets.QLabel(self.wid_mult)
        self.gridLayout_m.addWidget(self.set_of_bursts_label, 4, 0, 1, 1)
        # Groupbox containg middle two elements of row 4
        self.row4_m = QtWidgets.QGroupBox()
        self.minigrid4_m = QtWidgets.QGridLayout(self.row4_m)
        self.minigrid4_m.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_m.addWidget(self.row4_m, 4, 1, 1, 2)
        # Text field for set of bursts
        self.set_of_bursts_lineedit = QtWidgets.QLineEdit(self.row4_m)
        self.minigrid4_m.addWidget(self.set_of_bursts_lineedit, 0, 0, 1, 1)
        # Groupbox containg &#34;stop number&#34; widgets
        self.row4_2_m = QtWidgets.QGroupBox()
        self.minigrid4_2_m = QtWidgets.QGridLayout(self.row4_2_m)
        self.minigrid4_2_m.setContentsMargins(0, 0, 0, 0)
        self.minigrid4_m.addWidget(self.row4_2_m, 0, 1, 1, 1)
        # &#34;Stop number&#34; label
        self.stop_number_label_m = QtWidgets.QLabel(self.row4_2_m)
        self.minigrid4_2_m.addWidget(self.stop_number_label_m, 0, 0, 1, 1)
        # Spinbox for &#34;stop number&#34;
        self.stop_number_spinbox_m = QtWidgets.QSpinBox(self.row4_2_m)
        self.stop_number_spinbox_m.setValue(3)
        self.stop_number_spinbox_m.setMinimum(2)
        self.minigrid4_2_m.addWidget(self.stop_number_spinbox_m, 0, 1, 1, 1)
        # Submit button for set of bursts
        self.submit_set_of_bursts = QtWidgets.QPushButton(self.wid_mult)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.submit_set_of_bursts.setSizePolicy(sizePolicy)
        self.submit_set_of_bursts.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout_m.addWidget(self.submit_set_of_bursts, 4, 3, 1, 1)
        # Row 5:
        # &#34;Bursts&#34; label
        self.bursts_label = QtWidgets.QLabel(self.wid_mult)
        self.gridLayout_m.addWidget(self.bursts_label, 5, 0, 1, 1)
        # Groupbox containg middle elements of row 5
        self.row5_m = QtWidgets.QGroupBox()
        self.minigrid4_m = QtWidgets.QGridLayout(self.row5_m)
        self.minigrid4_m.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_m.addWidget(self.row5_m, 5, 1, 1, 2)
        # &#34;All&#34; checkbox
        self.all_bursts = QtWidgets.QCheckBox(&#34;All&#34;)
        self.all_bursts.setChecked(False)
        self.minigrid4_m.addWidget(self.all_bursts, 5, 0, 1, 1)
        # Combobox to choose burst
        self.burst = QtWidgets.QComboBox(self.row5_m)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.burst.setSizePolicy(sizePolicy)
        self.minigrid4_m.addWidget(self.burst, 5, 1, 1, 1)
        # Submit button for burst
        self.submit_burst = QtWidgets.QPushButton(self.wid_mult)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.submit_burst.setSizePolicy(sizePolicy)
        self.submit_burst.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout_m.addWidget(self.submit_burst, 5, 3, 1, 1)
        # Row 6:
        # &#34;Traversals&#34; label
        self.traversals_label = QtWidgets.QLabel(self.wid_mult)
        self.gridLayout_m.addWidget(self.traversals_label, 6, 0, 1, 1)
        # Groupbox containg middle elements of row 6
        self.row6_m = QtWidgets.QGroupBox()
        self.minigrid6_m = QtWidgets.QGridLayout(self.row6_m)
        self.minigrid6_m.setContentsMargins(0, 0, 0, 0)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.row6_m.setSizePolicy(sizePolicy)
        self.row6_m.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout_m.addWidget(self.row6_m, 6, 1, 1, 3)
        # &#34;Loops&#34; Checkbox
        self.if_loops_m = QtWidgets.QCheckBox(&#34;Loops&#34;)
        self.if_loops_m.setChecked(True)
        self.if_loops_m.setFixedWidth(68)
        self.minigrid6_m.addWidget(self.if_loops_m, 6, 0, 1, 1)
        # Combobox to choose a traversal
        self.traversals = QtWidgets.QComboBox(self.row6_m)
        self.minigrid6_m.addWidget(self.traversals, 6, 1, 1, 2)
        # Row 7:
        # &#34;Show matrices&#34; button
        self.show_matrices_m = QtWidgets.QPushButton(self.wid_mult)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.show_matrices_m.setSizePolicy(sizePolicy)
        self.show_matrices_m.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout_m.addWidget(self.show_matrices_m, 7, 1, 1, 1)
        # &#34;Show end result&#34; button
        self.show_end_result_m = QtWidgets.QPushButton(self.wid_mult)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.show_end_result_m.setSizePolicy(sizePolicy)
        self.show_end_result_m.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout_m.addWidget(self.show_end_result_m, 7, 2, 1, 1)
        # &#34;Show animation&#34; button
        self.show_animation_m = QtWidgets.QPushButton(self.wid_mult)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.show_animation_m.setSizePolicy(sizePolicy)
        self.show_animation_m.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout_m.addWidget(self.show_animation_m, 7, 3, 1, 1)

        # Function connections of different widgets:
        self.change_window_button_m.clicked.connect(self.change_window)
        self.traversal_mode_m.stateChanged.connect(lambda:self.change_mode_m(self.traversal_mode_m))
        self.mol_info_m.clicked.connect(self.mol_info_clicked_m)
        self.save_m.clicked.connect(self.save_clicked_m)
        self.all_bursts.stateChanged.connect(self.all_bursts_statechanged)
        self.submit_molecule_m.clicked.connect(self.submit_molecule_clicked_m)
        self.submit_set_of_bursts.clicked.connect(self.submit_set_of_bursts_clicked)
        self.submit_burst.clicked.connect(self.submit_burst_clicked)
        self.if_loops_m.stateChanged.connect(lambda:self.loops_onoff_m(self.if_loops_m))
        self.traversals.currentIndexChanged.connect(lambda: self.endless_loop_picked_m(self.traversals))
        self.show_matrices_m.clicked.connect(self.show_matrices_clicked_m)
        self.show_end_result_m.clicked.connect(self.show_end_result_clicked_m)
        self.show_animation_m.clicked.connect(lambda:self.show_animation_clicked(self.show_animation_m))
        # Hide most widgets at the beginning (while retaining space)
        self.hide_retain_space([self.traversal_mode_m, self.save_m, self.mol_info_m, self.set_of_bursts_label, self.row4_m, self.row4_2_m, self.submit_set_of_bursts, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
        self.hide_multiple([self.traversal_mode_m, self.save_m, self.mol_info_m, self.set_of_bursts_label, self.row4_m, self.row4_2_m, self.submit_set_of_bursts, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
        # Stylesheet:
        readme_path_m = os.path.join(os.path.dirname(os.path.abspath(__file__)), &#39;../styles_m.css&#39;)
        with open(readme_path_m, &#34;r&#34;, encoding=&#34;utf-8&#34;) as fh_m:
            self.style_m = fh_m.read()
        self.wid_mult.setStyleSheet(self.style_m)


        # Add both widgets to stacked layout, default widget when starting the software is single soliton case widget
        self.layout_for_wids.addWidget(self.wid_single)
        self.layout_for_wids.addWidget(self.wid_mult)
        self.central_wid.setLayout(self.layout_for_wids)
        self.setCentralWidget(self.central_wid)
        self.front_wid = 1
        self.retranslateUi()
        QtCore.QMetaObject.connectSlotsByName(self)


    def retranslateUi(self):
        &#34;&#34;&#34;Implements multi-language suppport. Is generated automatically when using PyQt5 UI code generator.
        &#34;&#34;&#34;
        _translate = QtCore.QCoreApplication.translate
        self.setWindowTitle(_translate(&#34;MainWindow&#34;, &#34;Soliton Automata Software&#34;))
        self.mol_info.setText(_translate(&#34;MainWindow&#34;, &#34;Info&#34;))
        self.molecule_label.setText(_translate(&#34;MainWindow&#34;, &#34;Molecule:&#34;))
        self.stop_number_label.setText(_translate(&#34;MainWindow&#34;, &#34;Stop:&#34;))
        self.submit_molecule.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
        self.exterior_nodes_label.setText(_translate(&#34;MainWindow&#34;, &#34;Exterior nodes:&#34;))
        self.exterior_nodes_label2.setText(_translate(&#34;MainWindow&#34;, &#34;&amp;&#34;))
        self.submit_exterior_nodes.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
        self.soliton_paths_label.setText(_translate(&#34;MainWindow&#34;, &#34;Soliton paths:&#34;))
        self.show_matrices.setText(_translate(&#34;MainWindow&#34;, &#34;Show matrices&#34;))
        self.show_end_result.setText(_translate(&#34;MainWindow&#34;, &#34;Show end result&#34;))
        self.show_animation.setText(_translate(&#34;MainWindow&#34;, &#34;Show animation&#34;))

        self.mol_info_m.setText(_translate(&#34;MainWindow&#34;, &#34;Info&#34;))
        self.molecule_label_m.setText(_translate(&#34;MainWindow&#34;, &#34;Molecule:&#34;))
        self.submit_molecule_m.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
        self.set_of_bursts_label.setText(_translate(&#34;MainWindow&#34;, &#34;Set of bursts:&#34;))
        self.submit_set_of_bursts.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
        self.bursts_label.setText(_translate(&#34;MainWindow&#34;, &#34;Bursts:&#34;))
        self.stop_number_label_m.setText(_translate(&#34;MainWindow&#34;, &#34;Stop:&#34;))
        self.submit_burst.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
        self.traversals_label.setText(_translate(&#34;MainWindow&#34;, &#34;Sets of paths:&#34;))
        self.show_matrices_m.setText(_translate(&#34;MainWindow&#34;, &#34;Show matrices&#34;))
        self.show_end_result_m.setText(_translate(&#34;MainWindow&#34;, &#34;Show end result&#34;))
        self.show_animation_m.setText(_translate(&#34;MainWindow&#34;, &#34;Show animation&#34;))


    def change_window(self):
        &#34;&#34;&#34;Is called when &#34;Change Mode&#34; button is clicked. Changes between the two widgets of the stacked layout.
        &#34;&#34;&#34;
        if self.front_wid == 1:
            self.layout_for_wids.setCurrentIndex(1)
            self.front_wid = 2
        else:
            self.layout_for_wids.setCurrentIndex(0)
            self.front_wid = 1


    def change_mode(self, checkbox: QtWidgets.QCheckBox):
        &#34;&#34;&#34;Realizes the change between being in traversal mode and not being in traversal mode in single soliton widget.
        In traversal mode, a soliton automata can be traversed by using an end result as the new soliton graph.
        When in traversal mode, the input molecule and stop number can&#39;t be edited.

        Args:
            checkbox (QtWidgets.QCheckBox): The checkbox that changes the mode.
        &#34;&#34;&#34;
        if checkbox.isChecked() == True:
            # make text field uneditable and button unclickable, turn both objects grey to make those properties visually recognizable
            self.submit_molecule.clicked.disconnect()
            self.submit_molecule.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
            self.molecule_lineedit.setReadOnly(True)
            self.molecule_lineedit.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(230, 230, 230);border-radius: 10px;padding: 0 8px;}&#34;)
            self.molecule_label.setText(&#34;Original molecule:&#34;)
            self.stop_number_spinbox.setReadOnly(True)
            self.stop_number_spinbox.setStyleSheet(&#34;QSpinBox {border: 1px solid rgb(230, 230, 230);border-radius: 10px;padding-right: 15px;}&#34;)
        else:
            self.submit_molecule.clicked.connect(self.submit_molecule_clicked)
            self.submit_molecule.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
            self.molecule_lineedit.setReadOnly(False)
            self.molecule_lineedit.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(191, 207, 255);border-radius: 10px;padding: 0 8px;}&#34;)
            self.molecule_label.setText(&#34;Molecule:&#34;)
            self.submit_molecule_clicked()
            self.stop_number_spinbox.setReadOnly(False)
            self.stop_number_spinbox.setStyleSheet(&#34;QSpinBox {border: 1px solid rgb(191, 207, 255);border-radius: 10px;padding-right: 15px;}&#34;)

    
    def change_mode_m(self, checkbox: QtWidgets.QCheckBox):
        &#34;&#34;&#34;Realizes the change between being in traversal mode and not being in traversal mode in multi soliton widget.
        In traversal mode, a soliton automata can be traversed by using an end result as the new soliton graph.
        When in traversal mode, the input molecule can&#39;t be edited.

        Args:
            checkbox (QtWidgets.QCheckBox): The checkbox that changes the mode.
        &#34;&#34;&#34;
        if checkbox.isChecked() == True:
            # make text field uneditable and button unclickable, turn both objects grey to make those properties visually recognizable
            self.submit_molecule_m.clicked.disconnect()
            self.submit_molecule_m.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
            self.molecule_lineedit_m.setReadOnly(True)
            self.molecule_lineedit_m.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(230, 230, 230);border-radius: 10px;padding: 0 8px;}&#34;)
            self.molecule_label_m.setText(&#34;Original molecule:&#34;)
            self.submit_set_of_bursts.clicked.disconnect()
            self.submit_set_of_bursts.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
            self.set_of_bursts_lineedit.setReadOnly(True)
            self.set_of_bursts_lineedit.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(230, 230, 230);border-radius: 10px;padding: 0 8px;}&#34;)
            self.stop_number_spinbox_m.setReadOnly(True)
            self.stop_number_spinbox_m.setStyleSheet(&#34;QSpinBox {border: 1px solid rgb(230, 230, 230);border-radius: 10px;padding-right: 15px;}&#34;)
        else:
            self.submit_molecule_m.clicked.connect(self.submit_molecule_clicked_m)
            self.submit_molecule_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            self.molecule_lineedit_m.setReadOnly(False)
            self.molecule_lineedit_m.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(149, 221, 185);border-radius: 10px;padding: 0 8px;}&#34;)
            self.molecule_label_m.setText(&#34;Molecule:&#34;)
            self.submit_molecule_clicked_m()
            self.submit_set_of_bursts.clicked.connect(self.submit_set_of_bursts_clicked)
            self.submit_set_of_bursts.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            self.set_of_bursts_lineedit.setReadOnly(False)
            self.set_of_bursts_lineedit.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(149, 221, 185);border-radius: 10px;padding: 0 8px;}&#34;)
            self.stop_number_spinbox_m.setReadOnly(False)
            self.stop_number_spinbox_m.setStyleSheet(&#34;QSpinBox {border: 1px solid rgb(149, 221, 185);border-radius: 10px;padding-right: 15px;}&#34;)


    def submit_molecule_clicked(self):
        &#34;&#34;&#34;Is called when user clicks button to submit the specified molecule in single soliton widget.
        Catches errors if user used the wrong syntax or specified a molecule that does not fulfill the requirements of a soliton graph.
        If the user&#39;s molecule is valid it displays the graph of the molecule. It then also reveals a save button for the graph visualisation,
        an info button and all the necessary widgets for the user to choose exterior nodes.
        &#34;&#34;&#34;
        self.node_1.clear()
        self.node_2.clear()
        self.smiles_string = self.molecule_lineedit.text()
        self.stop_number = self.stop_number_spinbox.value()
        try:
            self.my_graph = SolitonGraph(self.smiles_string)
            errors = self.my_graph.validate_soliton_graph()
            self.automata = SolitonAutomata(self.my_graph, self.stop_number)
            self.graph_pic = Visualisation.visualize_soliton_graph(self.my_graph, self.my_graph.bindings, False, True)
            self.qim = ImageQt(self.graph_pic)
            self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(self.display_molecule.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
            if errors != []:
                self.hide_multiple([self.traversal_mode, self.row2, self.exterior_nodes_label, self.row4, self.submit_exterior_nodes, self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
                msg = QMessageBox(self.wid_single)
                msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px;}&#34;)
                msg.setWindowTitle(&#34;No soliton graph&#34;)
                msg.setText(&#34;You specified a molecule that does not fulfill the requirements of a soliton graph.&#34;)
                msg.setIcon(QMessageBox.Warning)
                msg.setStandardButtons(QMessageBox.Retry)
                msg.setInformativeText(&#34;See details for all incorrect parts of your molecule.&#34;)
                details = &#34;&#34;
                for i, error in enumerate(errors):
                    if i == len(errors) - 1:
                        details = details + f&#34;- {error}&#34;
                    else:
                        details = details + f&#34;- {error}&#34; + &#34;\n&#34;
                msg.setDetailedText(details)
                x = msg.exec_() # show messagebox
            elif self.my_graph.exterior_nodes_name_collision() == True:
                self.hide_multiple([self.traversal_mode, self.row2, self.exterior_nodes_label, self.row4, self.submit_exterior_nodes, self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
                msg = QMessageBox(self.wid_single)
                msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
                msg.setWindowTitle(&#34;Name collision&#34;)
                msg.setText(&#34;You specified two or more exterior nodes with the same name.&#34;)
                msg.setIcon(QMessageBox.Warning)
                msg.setStandardButtons(QMessageBox.Retry)
                x = msg.exec_()
            else:
                self.show_multiple([self.traversal_mode, self.row2, self.exterior_nodes_label, self.row4, self.submit_exterior_nodes])
                self.hide_multiple([self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
                for key in self.my_graph.exterior_nodes_reverse:
                    self.node_1.addItem(key)
                    self.node_2.addItem(key)
        except:
            self.hide_multiple([self.traversal_mode, self.row2, self.exterior_nodes_label, self.row4, self.submit_exterior_nodes, self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
            msg = QMessageBox(self.wid_single)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
            msg.setWindowTitle(&#34;Incorrect input&#34;)
            msg.setText(&#34;The syntax of your input is not correct.&#34;)
            msg.setIcon(QMessageBox.Warning)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;Please try again with another input string.&#34;)
            details = f&#34;Reminder - this is how you define a molecule: \n&#34;
            details = details + f&#34;- Carbon atoms are marked with &#39;C&#39; \n&#34;
            details = details + f&#34;- Single bonds are marked with &#39;-&#39; or no character at all \n&#34;
            details = details + f&#34;- Double bonds are marked with &#39;=&#39; \n&#34;
            details = details + f&#34;- Branches are embedded in round brackets (e.g. &#39;C(=CC=C)C&#39;)\n&#34;
            details = details + f&#34;- The two connecting atoms of a ring are marked with the same number (e.g. &#39;C1&#39; and &#39;C1&#39;) \n&#34;
            details = details + &#34;- Exterior nodes are marked with braces and a number (e.g. &#39;{=1}&#39;)&#34;
            msg.setDetailedText(details)
            x = msg.exec_()


    def submit_molecule_clicked_m(self):
        &#34;&#34;&#34;Is called when user clicks button to submit the specified molecule in multi soliton widget.
        Catches errors if user used the wrong syntax or specified a molecule that does not fulfill the requirements of a soliton graph.
        If the user&#39;s molecule is valid it displays the graph of the molecule. It then also reveals a save button for the graph visualisation,
        an info button and all the necessary widgets for the user to specify a set of bursts and a stop number.
        &#34;&#34;&#34;
        self.smiles_string_m = self.molecule_lineedit_m.text()
        try:
            self.my_graph_m = SolitonGraph(self.smiles_string_m)
            errors = self.my_graph_m.validate_soliton_graph()
            self.graph_pic_m = Visualisation.visualize_soliton_graph(self.my_graph_m, self.my_graph_m.bindings, False, True)
            self.qim_m = ImageQt(self.graph_pic_m)
            self.display_molecule_m.setPixmap(QtGui.QPixmap.fromImage(self.qim_m).scaled(self.display_molecule_m.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
            self.set_of_bursts_lineedit.clear()
            if errors != []:
                self.hide_multiple([self.traversal_mode_m, self.save_m, self.mol_info_m, self.set_of_bursts_label, self.row4_m, self.row4_2_m, self.submit_set_of_bursts, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
                msg = QMessageBox(self.wid_mult)
                msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
                msg.setWindowTitle(&#34;No soliton graph&#34;)
                msg.setText(&#34;You specified a molecule that does not fulfill the requirements of a soliton graph.&#34;)
                msg.setIcon(QMessageBox.Warning)
                msg.setStandardButtons(QMessageBox.Retry)
                msg.setInformativeText(&#34;See details for all incorrect parts of your molecule.&#34;)
                details = &#34;&#34;
                for i, error in enumerate(errors):
                    if i == len(errors) - 1:
                        details = details + f&#34;- {error}&#34;
                    else:
                        details = details + f&#34;- {error}&#34; + &#34;\n&#34;
                msg.setDetailedText(details)
                x = msg.exec_() # show messagebox
            elif self.my_graph_m.exterior_nodes_name_collision() == True:
                self.hide_multiple([self.traversal_mode_m, self.save_m, self.mol_info_m, self.set_of_bursts_label, self.row4_m, self.row4_2_m, self.submit_set_of_bursts, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
                msg = QMessageBox(self.wid_mult)
                msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
                msg.setWindowTitle(&#34;Name collision&#34;)
                msg.setText(&#34;You specified two or more exterior nodes with the same name.&#34;)
                msg.setIcon(QMessageBox.Warning)
                msg.setStandardButtons(QMessageBox.Retry)
                x = msg.exec_()
            else:
                self.show_multiple([self.traversal_mode_m, self.save_m, self.set_of_bursts_label, self.row4_m, self.row4_2_m, self.submit_set_of_bursts])
                self.hide_multiple([self.mol_info_m, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
        except:
            self.hide_multiple([self.traversal_mode_m, self.save_m, self.mol_info_m, self.set_of_bursts_label, self.row4_m, self.row4_2_m, self.submit_set_of_bursts, self.mol_info_m, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
            msg = QMessageBox(self.wid_mult)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
            msg.setWindowTitle(&#34;Incorrect input&#34;)
            msg.setText(&#34;The syntax of your input is not correct.&#34;)
            msg.setIcon(QMessageBox.Warning)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;Please try again with another input string.&#34;)
            details = f&#34;Reminder - this is how you define a molecule: \n&#34;
            details = details + f&#34;- Carbon atoms are marked with &#39;C&#39; \n&#34;
            details = details + f&#34;- Single bonds are marked with &#39;-&#39; or no character at all \n&#34;
            details = details + f&#34;- Double bonds are marked with &#39;=&#39; \n&#34;
            details = details + f&#34;- Branches are embedded in round brackets (e.g. &#39;C(=CC=C)C&#39;)\n&#34;
            details = details + f&#34;- The two connecting atoms of a ring are marked with the same number (e.g. &#39;C1&#39; and &#39;C1&#39;) \n&#34;
            details = details + &#34;- Exterior nodes are marked with braces and a number (e.g. &#39;{=1}&#39;)&#34;
            msg.setDetailedText(details)
            x = msg.exec_()


    def mol_info_clicked(self):
        &#34;&#34;&#34;Is called when &#34;Info&#34; button in single soliton widget is clicked. Opens a dialog window showing whether
        the automata is deterministic and strongly deterministic and displaying all impervious paths.
        &#34;&#34;&#34;

        def save_info():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where a text file with all info on soliton automata/ soliton graph should be saved.
            Text file also contains the input string representing the molecule.
            Only allows `.txt` file suffix.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.wid_single, &#39;Save File&#39;, &#39;info.txt&#39;, &#39;Text files (*.txt)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;): # only do the following if user clicked on save button (without this line the application closes with an error if save action is cancelled)
                path = name[0]
                file = open(path, &#34;w&#34;)
                file.write(txt_text)
                file.close()
        
        txt_text = f&#34;Soliton graph: {self.smiles_string} \n&#34;
        txt_text = txt_text + f&#34;Stop number: {self.stop_number} \n\n&#34;
        dlg = QDialog(self.wid_single)
        grid = QtWidgets.QGridLayout(dlg)
        label_det = QtWidgets.QLabel(dlg)
        label_det.setText(&#34;Deterministic:&#34;)
        txt_text = txt_text + f&#34;Deterministic: &#34;
        grid.addWidget(label_det, 0, 0, 1, 1)
        det_bool = QtWidgets.QLabel(dlg)
        if self.automata.deterministic:
            det_bool.setText(&#34;Yes&#34;)
            txt_text = txt_text + f&#34;Yes \n&#34;
        else: 
            det_bool.setText(&#34;No&#34;)
            txt_text = txt_text + f&#34;No \n&#34;
        grid.addWidget(det_bool, 0, 1, 1, 1)
        label_strong_det = QtWidgets.QLabel(dlg)
        label_strong_det.setText(&#34;Strongly deterministic:&#34;)
        txt_text = txt_text + f&#34;Strongly deterministic: &#34;
        grid.addWidget(label_strong_det, 1, 0, 1, 1)
        strong_det_bool = QtWidgets.QLabel(dlg)
        if self.automata.strongly_deterministic:
            strong_det_bool.setText(&#34;Yes&#34;)
            txt_text = txt_text + f&#34;Yes \n&#34;
        else: 
            strong_det_bool.setText(&#34;No&#34;)
            txt_text = txt_text + f&#34;No \n&#34;
        grid.addWidget(strong_det_bool, 1, 1, 1, 1)
        label_imp_paths = QtWidgets.QLabel(dlg)
        label_imp_paths.setText(&#34;Impervious path(s):&#34;)
        txt_text = txt_text + f&#34;Impervious path(s): &#34;
        grid.addWidget(label_imp_paths, 2, 0, 1, 1, alignment = QtCore.Qt.AlignTop)
        save_button = QtWidgets.QPushButton(dlg)
        save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
        save_button.setMinimumSize(QtCore.QSize(0, 32))
        grid.addWidget(save_button, 3, 1, 1, 1)
        save_button.clicked.connect(save_info)
        group = QtWidgets.QGroupBox()
        layout = QtWidgets.QGridLayout(group)
        layout.setContentsMargins(0, 0, 0, 0)
        impervs = self.automata.find_impervious_paths()
        if impervs == []:
            layout.addWidget(QtWidgets.QLabel(&#34;-&#34;))
            txt_text = txt_text + f&#34;-&#34;
        for i, path in enumerate(impervs):
            layout.addWidget(QtWidgets.QLabel(path), i, 0, 1, 1, alignment = QtCore.Qt.AlignTop)
            txt_text = txt_text + f&#34;{path}&#34;
            if i != len(impervs)-1:
                txt_text = txt_text + f&#34;, &#34;
        grid.addWidget(group, 2, 1, 1, 1, alignment = QtCore.Qt.AlignTop)
        dlg.setWindowTitle(&#34;Info&#34;)
        dlg.exec_()

    
    def mol_info_clicked_m(self):
        &#34;&#34;&#34;Is called when &#34;Info&#34; button in multi soliton widget is clicked. Opens a dialog window showing whether
        the automata is deterministic and strongly deterministic.
        &#34;&#34;&#34;

        def save_info():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where a text file with all info on soliton automata/ soliton graph should be saved.
            Text file also contains the input string representing the molecule.
            Only allows `.txt` file suffix.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.wid_single, &#39;Save File&#39;, &#39;info.txt&#39;, &#39;Text files (*.txt)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;): # only do the following if user clicked on save button (without this line the application closes with an error if save action is cancelled)
                path = name[0]
                file = open(path, &#34;w&#34;)
                file.write(txt_text)
                file.close()
        
        dlg = QDialog(self.wid_single)
        grid = QtWidgets.QGridLayout(dlg)
        label_det = QtWidgets.QLabel(dlg)
        txt_text = f&#34;Soliton graph: {self.smiles_string_m} \n&#34;
        txt_text = txt_text + f&#34;Set of bursts: {self.bursts} \n&#34;
        txt_text = txt_text + f&#34;Stop number: {self.stop_number_m} \n\n&#34;
        label_det.setText(&#34;Deterministic:&#34;)
        txt_text = txt_text + f&#34;Deterministic: &#34;
        grid.addWidget(label_det, 0, 0, 1, 1)
        det_bool = QtWidgets.QLabel(dlg)
        if self.multi_automata.deterministic:
            det_bool.setText(&#34;Yes&#34;)
            txt_text = txt_text + f&#34;Yes \n&#34;
        else: 
            det_bool.setText(&#34;No&#34;)
            txt_text = txt_text + f&#34;No \n&#34;
        grid.addWidget(det_bool, 0, 1, 1, 1)
        label_strong_det = QtWidgets.QLabel(dlg)
        label_strong_det.setText(&#34;Strongly deterministic:&#34;)
        txt_text = txt_text + f&#34;Strongly deterministic: &#34;
        grid.addWidget(label_strong_det, 1, 0, 1, 1)
        strong_det_bool = QtWidgets.QLabel(dlg)
        if self.multi_automata.strongly_deterministic:
            strong_det_bool.setText(&#34;Yes&#34;)
            txt_text = txt_text + f&#34;Yes \n&#34;
        else: 
            strong_det_bool.setText(&#34;No&#34;)
            txt_text = txt_text + f&#34;No \n&#34;
        grid.addWidget(strong_det_bool, 1, 1, 1, 1)
        save_button = QtWidgets.QPushButton(dlg)
        save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
        save_button.setMinimumSize(QtCore.QSize(0, 32))
        grid.addWidget(save_button, 3, 1, 1, 1)
        save_button.clicked.connect(save_info)
        dlg.setWindowTitle(&#34;Info&#34;)
        dlg.exec_()


    def save_clicked(self):
        &#34;&#34;&#34;Is called when user clicks button to save the graph visualisation in single soliton widget.
        Opens a file dialog in which user can specify a path where the image should be saved.
        Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
        &#34;&#34;&#34;
        option = QtWidgets.QFileDialog.Options()
        name = QtWidgets.QFileDialog.getSaveFileName(self.wid_single, &#39;Save File&#39;, &#39;graph.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
        if name != (&#39;&#39;, &#39;&#39;):
            path = name[0]
            # turn PIL Image into byte array 
            imgByteArr = io.BytesIO()
            self.graph_pic.save(imgByteArr, format=&#39;PNG&#39;)
            imgByteArr = imgByteArr.getvalue()
            # save image at specified path
            file = open(path, &#34;wb&#34;)
            file.write(imgByteArr)
            file.close()


    def save_clicked_m(self):
        &#34;&#34;&#34;Is called when user clicks button to save the graph visualisation in multi soliton widget.
        Opens a file dialog in which user can specify a path where the image should be saved.
        Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
        &#34;&#34;&#34;
        option = QtWidgets.QFileDialog.Options()
        name = QtWidgets.QFileDialog.getSaveFileName(self.wid_mult, &#39;Save File&#39;, &#39;graph.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
        if name != (&#39;&#39;, &#39;&#39;):
            path = name[0] 
            imgByteArr = io.BytesIO()
            self.graph_pic_m.save(imgByteArr, format=&#39;PNG&#39;)
            imgByteArr = imgByteArr.getvalue()
            file = open(path, &#34;wb&#34;)
            file.write(imgByteArr)
            file.close()

    
    def submit_set_of_bursts_clicked(self):
        &#34;&#34;&#34;Method that is called when user clicks button to submit a set of bursts.
        Catches errors if user used the wrong syntax.
        If the user&#39;s set of bursts is valid it all the necessary widgets for the user to choose a burst.
        &#34;&#34;&#34;
        bursts = self.set_of_bursts_lineedit.text()
        self.bursts = bursts
        self.burst.clear()
        self.stop_number_m = self.stop_number_spinbox_m.value()
        try:
            self.multi_automata = MultiwaveSolitonAutomata(self.my_graph_m, bursts, self.stop_number_m)
            bursts = bursts.split(&#34;;&#34;)
            for burst in bursts:
                burst = re.sub(r&#34;[{}]+&#34;, &#34;&#34;, burst)
                self.burst.addItem(burst)
            self.show_multiple([self.mol_info_m, self.bursts_label, self.row5_m, self.submit_burst])
            self.hide_multiple([self.traversals_label, self.traversals, self.if_loops_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
        except:
            self.hide_multiple([self.mol_info_m, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
            msg = QMessageBox(self.wid_mult)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px;}&#34;)
            msg.setWindowTitle(&#34;Incorrect input&#34;)
            msg.setText(&#34;The syntax of your input is not correct.&#34;)
            msg.setIcon(QMessageBox.Warning)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;Please try again with another input string.&#34;)
            details = f&#34;Reminder - this is how you define a set of bursts: \n&#34;
            details = details + f&#34;- Starting and end node of a soliton are embedded in round brackets (e.g. (3, 2))\n&#34;
            details = details + f&#34;- Solitons are seperated by &#39;||&#39;\n&#34;
            details = details + f&#34;- The number in front of a soliton&#39;s pair of exterior nodes defines how many timesteps later than the previous soliton this soliton enters the graph\n&#34;
            details = details + f&#34;- A set of bursts is embedded in braces, where individual bursts are seperated by &#39;;&#39;\n&#34;
            details = details + &#34;- Example: &#34; + &#34;{(3,1)||1(1,2); (3,2)||4(2,1)}\n&#34;
            msg.setDetailedText(details)
            x = msg.exec_()


    def all_exterior_nodes_statechanged(self):
        &#34;&#34;&#34;Is called when &#34;All&#34; checkbox in single soliton widget is checked/ unchecked.
        Hides/ unhides widgets to choose a pair of exterior nodes.
        &#34;&#34;&#34;
        if self.all_exterior_nodes.isChecked():
            self.hide_multiple([self.node_1, self.exterior_nodes_label2, self.node_2])
        else: self.show_multiple([self.node_1, self.exterior_nodes_label2, self.node_2])


    def all_bursts_statechanged(self):
        &#34;&#34;&#34;Is called when &#34;All&#34; checkbox in multi soliton widget is checked/ unchecked.
        Hides/ unhides widgets to choose a burst.
        &#34;&#34;&#34;
        if self.all_bursts.isChecked():
            self.burst.hide()
        else: self.burst.show()


    def submit_exterior_nodes_clicked(self):
        &#34;&#34;&#34;Is called when user clicks button to submit exterior nodes.
        Displays all possible soliton paths between the two chosen nodes/ all pairs of exterior nodes.
        Informs the user if no soliton path exists between them.
        Otherwise all the necessary widgets for the user to choose a computed soliton path and look at further information on it are revealed.
        &#34;&#34;&#34;
        self.path_index = None # we need this variable later in show_animation_clicked
        self.paths.clear()
        self.if_loops.setChecked(True)
        if self.all_exterior_nodes.isChecked():
            key = self.automata.matrix_to_string(nx.to_numpy_array(self.my_graph.graph))
            self.found_paths = self.automata.states_plus_soliton_paths[key][1]
        else:
            node1 = self.my_graph.exterior_nodes_reverse[self.node_1.currentText()]
            node2 = self.my_graph.exterior_nodes_reverse[self.node_2.currentText()]
            self.found_paths = self.automata.call_find_all_paths_given_nodes(node1, node2, self.my_graph)
        if self.found_paths == []:
            self.hide_multiple([self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
            msg = QMessageBox(self.wid_single)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px;}&#34;)
            msg.setWindowTitle(&#34;No path found&#34;)
            msg.setText(&#34;There exists no soliton path between these exterior nodes.&#34;)
            msg.setIcon(QMessageBox.Information)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;Please try again with different exterior nodes or a different soliton automata.&#34;)
            x = msg.exec_()
        else:
            endless_loops = 0
            self.loops_indices = []
            for p, soliton_path in enumerate(self.found_paths):
                if isinstance(soliton_path, SolitonPath): # if soliton path is a real soliton path and no endless loop
                    self.paths.addItem(str(soliton_path.path_for_user))
                else:
                    this_path = &#34;[!] &#34;
                    this_path = this_path + soliton_path[0].path_for_user + &#34; ...&#34;
                    self.paths.addItem(this_path)
                    endless_loops += 1
                    self.loops_indices.append(p)
            self.soliton_paths_label.setText(f&#34;Soliton paths ({len(self.found_paths) - endless_loops}):&#34;)
            self.show_multiple([self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])

    
    def submit_burst_clicked(self):
        &#34;&#34;&#34;Is called when user clicks button to submit burst(s).
        Displays all possible traversals for the chosen burst/ all bursts.
        Informs the user if no traversals exists for it/ them.
        Otherwise all the necessary widgets for the user to choose a computed traversals and look at further information on it are revealed.
        &#34;&#34;&#34;
        self.traversal_index = None # we need this variable later in show_animation_clicked
        self.traversals.clear()
        self.if_loops_m.setChecked(True)
        if self.all_bursts.isChecked():
            key = self.multi_automata.matrix_to_string(nx.to_numpy_array(self.my_graph_m.graph))
            self.found_traversals = self.multi_automata.states_plus_traversals[key][1]
            self.num_traversals_per_burst = self.multi_automata.states_plus_traversals[key][2]
        else:
            burst_index = int(self.burst.currentIndex())
            self.found_traversals = self.multi_automata.call_find_all_travs_given_burst(self.multi_automata.bursts_dicts[burst_index], self.my_graph_m)
            self.num_traversals_per_burst = None
        if self.found_traversals == []:
            self.hide_multiple([self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
            msg = QMessageBox(self.wid_mult)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px;}&#34;)
            msg.setWindowTitle(&#34;No soliton paths found&#34;)
            msg.setText(&#34;With this burst(s), not all solitons can traverse the soliton graph successfully.&#34;)
            msg.setIcon(QMessageBox.Information)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;Please try again with different bursts.&#34;)
            x = msg.exec_()
        else:
            endless_loops = 0
            self.loops_indices_m = []
            for t, traversal in enumerate(self.found_traversals):
                if isinstance(traversal, Traversal): # if traversal is a real traversal and no endless loop
                    this_traversal = &#34;&#34;
                    for i, path in enumerate(traversal.traversal_for_user):
                        this_traversal = this_traversal + path
                        if i != len(traversal.traversal_for_user)-1:
                            this_traversal = this_traversal + &#34;, &#34;
                    self.traversals.addItem(this_traversal)
                else:
                    this_traversal = &#34;[!] &#34;
                    for i, path in enumerate(traversal[0].traversal_for_user):
                        this_traversal = this_traversal + path + &#34; ...&#34;
                        if i != len(traversal[0].traversal_for_user)-1:
                            this_traversal = this_traversal + &#34;, &#34;
                    self.traversals.addItem(this_traversal)
                    endless_loops += 1
                    self.loops_indices_m.append(t)
            self.traversals_label.setText(f&#34;Sets of paths ({len(self.found_traversals) - endless_loops}):&#34;)
            self.show_multiple([self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
            sep_index = 0
            if self.num_traversals_per_burst:
                for n, num in enumerate(self.num_traversals_per_burst): # add seperators to distinct which traversals resulted from which burst
                    if num != 0 and n != len(self.num_traversals_per_burst)-1: # don&#39;t add if there is no traversal for this burst of if it&#39;s the last burst
                        sep_index += num
                        self.traversals.insertSeparator(sep_index)
                        self.found_traversals.insert(sep_index, None) # so the indices in found_traversals correspond with the indices of the combobox items
                        self.loops_indices_m = [(index + 1) if (index &gt;= sep_index) else index for index in self.loops_indices_m]
                        sep_index += 1 # indices got shifted by one because seperator was added


    def loops_onoff(self, checkbox: QtWidgets.QCheckBox):
        &#34;&#34;&#34;Is called when &#34;loops&#34; checkbox in single soliton widget is checked/ unchecked.
        Hides &#34;loop paths&#34;/ unhides them.

        Args:
            checkbox (QtWidgets.QCheckBox): &#34;Loops&#34; checkbox.
        &#34;&#34;&#34;
        if checkbox.isChecked() == True:
            for index in self.loops_indices:
                if index &lt; self.paths.count():
                    view = self.paths.view()
                    view.setRowHidden(index, False)
                    model = self.paths.model()
                    item = model.item(index)
                    item.setFlags(item.flags() | Qt.ItemIsEnabled)
            self.paths.setCurrentIndex(0)
        else:
            for index in self.loops_indices:
                if index &lt; self.paths.count():
                    view = self.paths.view()
                    view.setRowHidden(index, True)
                    model = self.paths.model()
                    item = model.item(index)
                    item.setFlags(item.flags() &amp; ~Qt.ItemIsEnabled)
            curIndex = 0
            for i in range (0, len(self.found_paths)):
                if curIndex not in self.loops_indices:
                    break
                else:
                    curIndex += 1
            self.paths.setCurrentIndex(curIndex)


    def loops_onoff_m(self, checkbox: QtWidgets.QCheckBox):
        &#34;&#34;&#34;Is called when &#34;loops&#34; checkbox in multi soliton widget is checked/ unchecked.
        Hides &#34;loop traversals&#34;/ unhides them.

        Args:
            checkbox (QtWidgets.QCheckBox): &#34;Loops&#34; checkbox.
        &#34;&#34;&#34;
        if checkbox.isChecked() == True:
            for index in self.loops_indices_m:
                if index &lt; self.traversals.count():
                    view = self.traversals.view()
                    view.setRowHidden(index, False)
                    model = self.traversals.model()
                    item = model.item(index)
                    item.setFlags(item.flags() | Qt.ItemIsEnabled)
            self.traversals.setCurrentIndex(0)
        else:
            for index in self.loops_indices_m:
                if index &lt; self.traversals.count():
                    view = self.traversals.view()
                    view.setRowHidden(index, True)
                    model = self.traversals.model()
                    item = model.item(index)
                    item.setFlags(item.flags() &amp; ~Qt.ItemIsEnabled)
            curIndex = 0
            for i in range (0, len(self.found_traversals)):
                if curIndex not in self.loops_indices_m:
                    break
                else:
                    curIndex += 1
            self.traversals.setCurrentIndex(curIndex)

    
    def endless_loop_picked(self, combobox: QtWidgets.QComboBox):
        &#34;&#34;&#34;Is called when an element of combobox containing found paths is picked in single soliton widget. Disables &#34;show matrices&#34;
        and &#34;show end result&#34; buttons if &#34;loop path&#34; is picked/ enables them again if valid soliton path is picked.

        Args:
            combobox (QtWidgets.QComboBox): Contains all found soliton paths and &#34;loop paths&#34;.
        &#34;&#34;&#34;
        if not isinstance(self.found_paths[combobox.currentIndex()], SolitonPath): # disable
            try:
                self.show_matrices.clicked.disconnect()
                self.show_matrices.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
                self.show_end_result.clicked.disconnect()
                self.show_end_result.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
            except:
                pass
        else: # enable
            try:
                self.show_matrices.clicked.disconnect()
                self.show_matrices.clicked.connect(self.show_matrices_clicked)
                self.show_matrices.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
                self.show_end_result.clicked.disconnect()
                self.show_end_result.clicked.connect(self.show_end_result_clicked)
                self.show_end_result.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
            except:
                self.show_matrices.clicked.connect(self.show_matrices_clicked)
                self.show_matrices.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
                self.show_end_result.clicked.connect(self.show_end_result_clicked)
                self.show_end_result.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)


    def endless_loop_picked_m(self, combobox: QtWidgets.QComboBox):
        &#34;&#34;&#34;Is called when an element of combobox containing found traversals is picked in multi soliton widget. Disables &#34;show matrices&#34;
        and &#34;show end result&#34; buttons if &#34;loop traversal&#34; is picked/ enables them again if traversal is picked.

        Args:
            combobox (QtWidgets.QComboBox): Contains all found traversals and &#34;loop traversals&#34;.
        &#34;&#34;&#34;
        if not isinstance(self.found_traversals[combobox.currentIndex()], Traversal):
            try:
                self.show_matrices_m.clicked.disconnect()
                self.show_matrices_m.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
                self.show_end_result_m.clicked.disconnect()
                self.show_end_result_m.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
            except:
                pass
        else:
            try:
                self.show_matrices_m.clicked.disconnect()
                self.show_matrices_m.clicked.connect(self.show_matrices_clicked_m)
                self.show_matrices_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
                self.show_end_result_m.clicked.disconnect()
                self.show_end_result_m.clicked.connect(self.show_end_result_clicked_m)
                self.show_end_result_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            except:
                self.show_matrices_m.clicked.connect(self.show_matrices_clicked_m)
                self.show_matrices_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
                self.show_end_result_m.clicked.connect(self.show_end_result_clicked_m)
                self.show_end_result_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)


    def show_matrices_clicked(self):
        &#34;&#34;&#34;Is called when user clicks button to have the adjacency matrices of every timestep in single soliton widget displayed.
        Makes a small window pop up that shows the labelled adjacency matrices and provides a save button.
        &#34;&#34;&#34;

        def save_matrices():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where a text file with all adjacency matrices should be saved.
            Text file also contains the input string representing the molecule and the soliton path.
            Only allows `.txt` file suffix.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.wid_single, &#39;Save File&#39;, &#39;matrices.txt&#39;, &#39;Text files (*.txt)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;): # only do the following if user clicked on save button (without this line the application closes with an error if save action is cancelled)
                path = name[0]
                file = open(path, &#34;w&#34;)
                file.write(txt_text)
                file.close()

        index = self.paths.currentIndex()
        desired_path = self.found_paths[index]

        dlg = QDialog(self.wid_single)
        scrollArea = QScrollArea(dlg)
        scrollArea.setStyleSheet(&#34;font: 13pt Courier;&#34;)
        widget = QtWidgets.QWidget()
        vbox = QtWidgets.QVBoxLayout()
        if re.search(&#39;,&#39;, self.my_graph.way) is not None:
            txt_text = f&#34;Way to soliton graph: {self.my_graph.way} \n&#34;
        else:
            txt_text = f&#34;Soliton graph: {self.my_graph.way} \n&#34;
        txt_text = txt_text + f&#34;Soliton path: {desired_path.path_for_user} \n \n&#34;
        # labelling of matrix depends on wether we have long node labels (&#34;aa&#34;, &#34;ab&#34;, ...) or short ones (&#34;a&#34;, &#34;b&#34;, ...)
        if (len(self.my_graph.labels) - len(self.my_graph.exterior_nodes)) &gt; 26:
            matrix_label_horizontal = &#34;    &#34;
            long_labels = True
        else:
            matrix_label_horizontal = &#34;   &#34;
            long_labels = False
        for key in self.my_graph.labels:
            if long_labels:
                if self.my_graph.labels[key] in self.my_graph.exterior_nodes_reverse and int(self.my_graph.labels[key]) &lt; 10:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]}  &#34;
                else:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]} &#34;
            else:
                if self.my_graph.labels[key] in self.my_graph.exterior_nodes_reverse and int(self.my_graph.labels[key]) &gt;= 10:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]} &#34;
                else:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]}  &#34;
        # for show-matrices-window the node labels are added to the matrix string and this labelled matrix is added to scroll area
        # for matrices.txt we add everything (horizontal label and every row of matrix) line by line
        for i in range(len(desired_path.adjacency_matrices_list)):
            txt_text = txt_text + f&#34;Timestep {i}: \n&#34;
            txt_text = txt_text + f&#34;{matrix_label_horizontal} \n&#34;
            matrix_labelled = &#34;&#34;
            matrix_labelled = matrix_labelled + f&#34;{matrix_label_horizontal}\n&#34;
            matrix = str(desired_path.adjacency_matrices_list[i])
            matrix = re.sub(r&#34;[matrix(]&#34;, &#34;&#34;, matrix)
            matrix = re.sub(r&#34;[)]&#34;, &#34;&#34;, matrix)
            for j in range(len(matrix.splitlines())):
                if long_labels:
                    if self.my_graph.labels[j] in self.my_graph.exterior_nodes_reverse and int(self.my_graph.labels[j]) &lt; 10:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]} {matrix.splitlines()[j]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph.labels[j]} {matrix.splitlines()[j]} \n&#34;
                    else:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
                else:
                    if self.my_graph.labels[j] in self.my_graph.exterior_nodes_reverse and int(self.my_graph.labels[j]) &gt;= 10:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j][1:]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j][1:]} \n&#34;
                    else:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
            txt_text = txt_text + f&#34;\n&#34;
            vbox.addWidget(QtWidgets.QLabel(matrix_labelled))
        widget.setLayout(vbox)
        scrollArea.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        scrollArea.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        scrollArea.setWidgetResizable(True)
        scrollArea.setWidget(widget)
        scrollArea.setFixedSize(540, 405)
        save_button = QtWidgets.QPushButton(dlg)
        save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
        save_button.setGeometry(QtCore.QRect(454, 359, 70, 30))
        save_button.clicked.connect(save_matrices)

        dlg.setWindowTitle(&#34;Adjacency Matrices&#34;)
        dlg.setFixedSize(545, 410)
        dlg.exec_()


    def show_matrices_clicked_m(self):
        &#34;&#34;&#34;Is called when user clicks button to have the adjacency matrices of every timestep in multi soliton widget displayed.
        Makes a small window pop up that shows the labelled adjacency matrices and provides a save button.
        &#34;&#34;&#34;

        def save_matrices():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where a text file with all adjacency matrices should be saved.
            Text file also contains the input string representing the molecule and the soliton path.
            Only allows `.txt` file suffix.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.wid_mult, &#39;Save File&#39;, &#39;matrices.txt&#39;, &#39;Text files (*.txt)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;): # only do the following if user clicked on save button (without this line the application closes with an error if save action is cancelled)
                path = name[0]
                file = open(path, &#34;w&#34;)
                file.write(txt_text)
                file.close()

        index = self.traversals.currentIndex()
        desired_traversal = self.found_traversals[index]

        dlg = QDialog(self.wid_mult)
        scrollArea = QScrollArea(dlg)
        scrollArea.setStyleSheet(&#34;font: 13pt Courier;&#34;)
        widget = QtWidgets.QWidget()
        vbox = QtWidgets.QVBoxLayout()
        if re.search(&#39;,&#39;, self.my_graph_m.way) is not None:
            txt_text = f&#34;Way to soliton graph: {self.my_graph_m.way} \n&#34;
        else:
            txt_text = f&#34;Soliton graph: {self.my_graph_m.way} \n&#34;
        txt_text = txt_text + f&#34;Set of bursts: {self.bursts} \n&#34;
        this_traversal = &#34;&#34;
        for i, path in enumerate(desired_traversal.traversal_for_user):
            this_traversal = this_traversal + path
            if i != len(desired_traversal.traversal_for_user)-1:
                this_traversal = this_traversal + &#34;, &#34;
        txt_text = txt_text + f&#34;Traversal: {this_traversal} \n \n&#34;
        if (len(self.my_graph_m.labels) - len(self.my_graph_m.exterior_nodes)) &gt; 26:
            matrix_label_horizontal = &#34;    &#34;
            long_labels = True
        else:
            matrix_label_horizontal = &#34;   &#34;
            long_labels = False
        for key in self.my_graph_m.labels:
            if long_labels:
                if self.my_graph_m.labels[key] in self.my_graph_m.exterior_nodes_reverse and int(self.my_graph_m.labels[key]) &lt; 10:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph_m.labels[key]}  &#34;
                else:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph_m.labels[key]} &#34;
            else:
                if self.my_graph_m.labels[key] in self.my_graph_m.exterior_nodes_reverse and int(self.my_graph_m.labels[key]) &gt;= 10:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph_m.labels[key]} &#34;
                else:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph_m.labels[key]}  &#34;
        for i in range(len(desired_traversal.adjacency_matrices_list)):
            txt_text = txt_text + f&#34;Timestep {i}: \n&#34;
            txt_text = txt_text + f&#34;{matrix_label_horizontal} \n&#34;
            matrix_labelled = &#34;&#34;
            matrix_labelled = matrix_labelled + f&#34;{matrix_label_horizontal}\n&#34;
            matrix = str(desired_traversal.adjacency_matrices_list[i])
            matrix = re.sub(r&#34;[matrix(]&#34;, &#34;&#34;, matrix)
            matrix = re.sub(r&#34;[)]&#34;, &#34;&#34;, matrix)
            for j in range(len(matrix.splitlines())):
                if long_labels:
                    if self.my_graph_m.labels[j] in self.my_graph_m.exterior_nodes_reverse and int(self.my_graph_m.labels[j]) &lt; 10:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph_m.labels[j]} {matrix.splitlines()[j]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph_m.labels[j]} {matrix.splitlines()[j]} \n&#34;
                    else:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j]} \n&#34;
                else:
                    if self.my_graph_m.labels[j] in self.my_graph_m.exterior_nodes_reverse and int(self.my_graph_m.labels[j]) &gt;= 10:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j][1:]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j][1:]} \n&#34;
                    else:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j]} \n&#34;
            txt_text = txt_text + f&#34;\n&#34;
            vbox.addWidget(QtWidgets.QLabel(matrix_labelled))
        widget.setLayout(vbox)
        scrollArea.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        scrollArea.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        scrollArea.setWidgetResizable(True)
        scrollArea.setWidget(widget)
        scrollArea.setFixedSize(540, 405)
        save_button = QtWidgets.QPushButton(dlg)
        save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
        save_button.setGeometry(QtCore.QRect(454, 359, 70, 30))
        save_button.clicked.connect(save_matrices)

        dlg.setWindowTitle(&#34;Adjacency Matrices&#34;)
        dlg.setFixedSize(545, 410)
        dlg.exec_()
    

    def show_end_result_clicked(self):
        &#34;&#34;&#34;Is called when user clicks button to have the resulting graph (after soliton path is traversed) in single soliton widget displayed.
        Makes a small window pop up that shows the graph visualisation and provides a save button.
        &#34;&#34;&#34;

        def save_end_result():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where the resulting graph should be saved.
            Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.wid_single, &#39;Save File&#39;, &#39;result.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;):
                path = name[0]
                imgByteArr = io.BytesIO()
                result_pic.save(imgByteArr, format=&#39;PNG&#39;)
                imgByteArr = imgByteArr.getvalue()
                file = open(path, &#34;wb&#34;)
                file.write(imgByteArr)
                file.close()

        def use_as_new_soliton_graph(dlg: QDialog):
            &#34;&#34;&#34;Uses the end result of the selected path as the new soliton graph. Puts the software in traversal mode.

            Args:
                dlg (QDialog): The dialog window that shows the end result.
            &#34;&#34;&#34;
            current_way = self.my_graph.way
            new_soliton_graph = copy.deepcopy(self.desired_path.resulting_soliton_graph)
            self.my_graph = new_soliton_graph
            self.my_graph.way = f&#34;{current_way}, {self.desired_path.path_for_user}&#34;
            self.graph_pic = Visualisation.visualize_soliton_graph(self.my_graph, self.my_graph.bindings, False, True)
            self.qim = ImageQt(self.graph_pic)
            self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(self.display_molecule.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))

            self.traversal_mode.setChecked(True)
            self.hide_multiple([self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
            self.node_1.setCurrentIndex(0)
            self.node_2.setCurrentIndex(0)
            dlg.close()

        index = self.paths.currentIndex()
        self.desired_path = self.found_paths[index]
        bindings_index = len(self.desired_path.path) - 1
        result_pic = Visualisation.visualize_soliton_graph(self.my_graph, self.desired_path.bindings_list[bindings_index], False, True)
        qim = ImageQt(result_pic)

        dlg = QDialog(self.wid_single)
        label = QtWidgets.QLabel(dlg)
        label.setGeometry(QtCore.QRect(0, 0, 540, 405))
        label.setPixmap(QtGui.QPixmap.fromImage(qim))
        label.setScaledContents(True)
        save_button = QtWidgets.QPushButton(dlg)
        save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
        save_button.setGeometry(QtCore.QRect(470, 375, 70, 30))
        save_button.clicked.connect(save_end_result)
        use_button = QtWidgets.QPushButton(&#34;Use&#34;, dlg)
        use_button.clicked.connect(lambda: use_as_new_soliton_graph(dlg))
        use_button.setGeometry(QtCore.QRect(395, 375, 70, 30))

        dlg.setWindowTitle(&#34;End result&#34;)
        dlg.setFixedSize(545, 410)
        dlg.exec_()

    
    def show_end_result_clicked_m(self):
        &#34;&#34;&#34;Is called when user clicks button to have the resulting graph (after soliton path is traversed) in multi soliton widget displayed.
        Makes a small window pop up that shows the graph visualisation and provides a save button.
        &#34;&#34;&#34;

        def save_end_result():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where the resulting graph should be saved.
            Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.wid_mult, &#39;Save File&#39;, &#39;result.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;):
                path = name[0]
                imgByteArr = io.BytesIO()
                result_pic.save(imgByteArr, format=&#39;PNG&#39;)
                imgByteArr = imgByteArr.getvalue()
                file = open(path, &#34;wb&#34;)
                file.write(imgByteArr)
                file.close()

        def use_as_new_soliton_graph(dlg: QDialog):
            &#34;&#34;&#34;Uses the end result of the selected path as the new soliton graph. Puts the software in traversal mode.

            Args:
                dlg (QDialog): The dialog window that shows the end result.
            &#34;&#34;&#34;
            current_way = self.my_graph_m.way
            new_soliton_graph = copy.deepcopy(self.desired_traversal.resulting_soliton_graph)
            self.my_graph_m = new_soliton_graph
            self.my_graph_m.way = f&#34;{current_way}, {self.desired_traversal.traversal_for_user}&#34;
            self.graph_pic = Visualisation.visualize_soliton_graph(self.my_graph_m, self.my_graph_m.bindings, False, True)
            self.qim_m = ImageQt(self.graph_pic)
            self.display_molecule_m.setPixmap(QtGui.QPixmap.fromImage(self.qim_m).scaled(self.display_molecule_m.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))

            self.traversal_mode_m.setChecked(True)
            self.hide_multiple([self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
            self.burst.setCurrentIndex(0)
            dlg.close()

        index = self.traversals.currentIndex()
        self.desired_traversal = self.found_traversals[index]
        result_pic = Visualisation.visualize_soliton_graph(self.desired_traversal.resulting_soliton_graph, self.desired_traversal.resulting_soliton_graph.bindings, False, True)
        qim = ImageQt(result_pic)

        dlg = QDialog(self.wid_mult)
        label = QtWidgets.QLabel(dlg)
        label.setGeometry(QtCore.QRect(0, 0, 540, 405))
        label.setPixmap(QtGui.QPixmap.fromImage(qim))
        label.setScaledContents(True)
        save_button = QtWidgets.QPushButton(dlg)
        save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
        save_button.setGeometry(QtCore.QRect(470, 375, 70, 30))
        save_button.clicked.connect(save_end_result)
        use_button = QtWidgets.QPushButton(&#34;Use&#34;, dlg)
        use_button.clicked.connect(lambda: use_as_new_soliton_graph(dlg))
        use_button.setGeometry(QtCore.QRect(395, 375, 70, 30))

        dlg.setWindowTitle(&#34;End result&#34;)
        dlg.setFixedSize(545, 410)
        dlg.exec_()


    def show_animation_clicked(self, button: QtWidgets.QPushButton):
        &#34;&#34;&#34;Is called when user clicks button to have the animation of the soliton traversing the graph displayed.
        Makes a small window pop up that shows the animation and provides a &#34;pause&#34;/ &#34;play&#34; button, a &#34;back&#34; and a &#34;forward&#34; button and a save button.
        Instead of displaying the `gif` it uses a sequence of `PIL` images and always shows the next image after a certain time.
        Calls different animation functions depending on whether application is in single or multi soliton widget.
        If a &#34;loop path&#34;/ &#34;loop traversal&#34; was chosen, save button is disabled and animation loops after loop point is reached.

        Args:
            button (QtWidgets.QPushButton): Button that called the function (either button in single or in multi soliton widget).
        &#34;&#34;&#34;

        def save_animation():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where the animation should be saved.
            Only allows `.gif` file suffix.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(wid, &#39;Save File&#39;, &#39;animation.gif&#39;, &#39;Images (*.gif)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;):
                path = name[0]
                if button == self.show_animation: # single soliton animation
                    ani = Animation.graph_animation(self.my_graph, self.desired_path)
                else: ani = Animation.graph_animation_multiwave(self.my_graph_m, self.desired_traversal) # multi soliton animation
                ani.save(path, writer=&#39;pillow&#39;, dpi = 600)

        def update_image():
            &#34;&#34;&#34;Displays next image of animation.
            &#34;&#34;&#34;
            self.step += 1
            if button == self.show_animation:
                if isinstance(self.desired_path, SolitonPath):
                    if self.step == len(self.desired_path.path): # start animation all over again as soon as end is reached (endless loop)
                        self.step = 0
                else:
                    if self.step == len(self.desired_path[0].path):
                        self.over_looppoint_count += 1 # another &#34;round&#34; of loop made
                        self.step = self.desired_path[1] # we reached the &#34;end&#34; (which in reality is the point where we noticed we are stuck in a loop) so we have to continue at the loop point now
            else:
                if isinstance(self.desired_traversal, Traversal):
                    if self.step == len(self.desired_traversal.pos):
                        self.step = 0
                else:
                    if self.step == len(self.desired_traversal[0].pos):
                        self.over_looppoint_count += 1
                        self.step = self.desired_traversal[1]
            im = self.pil_images[self.step]
            qim = ImageQt(im)
            self.label.setPixmap(QtGui.QPixmap.fromImage(qim.copy()))
            self.label.setScaledContents(True)

        def update_image_reverse():
            &#34;&#34;&#34;Displays previous image of animation.
            &#34;&#34;&#34;
            self.step -= 1
            if button == self.show_animation:
                if isinstance(self.desired_path, SolitonPath):
                    if self.step == -1: # if start of animation was reached in the step before then continue at end of animation
                        self.step = len(self.desired_path.path) - 1
                else:
                    if self.step == -1:
                        self.step = 0 # we can&#39;t go back to the end of the animation because it has no end, instead we stay at the beginning
                    elif self.step == self.desired_path[1] - 1 and self.over_looppoint_count != 0: # before we go back to before the loop point we have to dismantle all &#34;rounds&#34; of loop that we made
                        self.step = len(self.desired_path[0].path) - 1 # continue again at the &#34;end&#34;
                        self.over_looppoint_count -= 1 # dismantle
            else:
                if isinstance(self.desired_traversal, Traversal):
                    if self.step == -1:
                        self.step = len(self.desired_traversal.pos) - 1
                else:
                    if self.step == -1:
                        self.step = 0 
                    elif self.step == self.desired_traversal[1] - 1 and self.over_looppoint_count != 0:
                        self.step = len(self.desired_traversal[0].pos) - 1
                        self.over_looppoint_count -= 1
            im = self.pil_images[self.step]
            qim = ImageQt(im)
            self.label.setPixmap(QtGui.QPixmap.fromImage(qim.copy()))
            self.label.setScaledContents(True)
            
        def pause_animation(button: QtWidgets.QPushButton):
            &#34;&#34;&#34;Is called when &#34;pause&#34;/ &#34;play&#34; button is pressed.
            Pauses/ plays animation by stopping the timer/ starting the timer.

            Args:
                button (QtWidgets.QPushButton): Button that called the function (either button in single or in multi soliton widget).
            &#34;&#34;&#34;
            if self.timer.isActive(): # pause
                self.timer.stop()
                if button.parentWidget().parentWidget() == self.wid_single:
                    button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
                else: button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            else: # play
                update_image()
                self.timer.start(800)
                if button.parentWidget().parentWidget() == self.wid_single:
                    button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/pause.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
                else: button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/pause.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)

        def next_img(button: QtWidgets.QPushButton):
            &#34;&#34;&#34;Is called when &#34;forward&#34; button is pressed.
            Stops the timer if it is still active and calls `update_image` function.

            Args:
                button (QtWidgets.QPushButton): Button that called the function (either button in single or in multi soliton widget).
            &#34;&#34;&#34;
            if self.timer.isActive():
                self.timer.stop()
                if button.parentWidget().parentWidget() == self.wid_single:
                    button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
                else: button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            update_image()

        def prev_img(button: QtWidgets.QPushButton):
            &#34;&#34;&#34;Is called when &#34;back&#34; button is pressed.
            Stops the timer if it is still active and calls `update_image_reverse` function.

            Args:
                button (QtWidgets.QPushButton): Button that called the function (either button in single or in multi soliton widget).
            &#34;&#34;&#34;
            if self.timer.isActive():
                self.timer.stop()
                if button.parentWidget().parentWidget() == self.wid_single:
                    button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
                else: button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            update_image_reverse()
            
        if button == self.show_animation:
            dlg = QDialog(self.wid_single)
        else: dlg = QDialog(self.wid_mult)
        self.label = QtWidgets.QLabel(dlg)
        self.label.setGeometry(QtCore.QRect(0, 0, 540, 405))
        
        if button == self.show_animation:
            wid = self.wid_single
        else:
            wid = self.wid_mult
        
        if button == self.show_animation:
            if self.path_index != self.paths.currentIndex():
                self.path_index = self.paths.currentIndex()
                self.desired_path = self.found_paths[self.path_index]
                if isinstance(self.desired_path, SolitonPath): # soliton path
                    plots_and_arrays = Animation.list_of_plots_and_arrays(self.my_graph, self.desired_path)
                else: # &#34;loop path&#34;
                    plots_and_arrays = Animation.list_of_plots_and_arrays(self.my_graph, self.desired_path[0])
                self.pil_images = Animation.list_of_pil_images(plots_and_arrays)
        else:
            if self.traversal_index != self.traversals.currentIndex():
                self.traversal_index = self.traversals.currentIndex()
                self.desired_traversal = self.found_traversals[self.traversal_index]
                if isinstance(self.desired_traversal, Traversal):
                    plots_and_arrays = Animation.list_of_plots_and_arrays_multiwave(self.my_graph_m, self.desired_traversal)
                else: 
                    plots_and_arrays = Animation.list_of_plots_and_arrays_multiwave(self.my_graph_m, self.desired_traversal[0])
                self.pil_images = Animation.list_of_pil_images(plots_and_arrays)

        save_button = QtWidgets.QPushButton(dlg)
        save_button.setGeometry(QtCore.QRect(470, 375, 70, 30))
        pause_button = QtWidgets.QPushButton(dlg)
        pause_button.setGeometry(QtCore.QRect(240, 375, 30, 30))
        pause_button.clicked.connect(lambda: pause_animation(pause_button))
        next_button = QtWidgets.QPushButton(dlg)
        next_button.setGeometry(QtCore.QRect(275, 375, 30, 30))
        next_button.clicked.connect(lambda: next_img(pause_button))
        prev_button = QtWidgets.QPushButton(dlg)
        prev_button.setGeometry(QtCore.QRect(205, 375, 30, 30))
        prev_button.clicked.connect(lambda: prev_img(pause_button))
        if button == self.show_animation:
            if isinstance(self.desired_path, SolitonPath):
                save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
                save_button.clicked.connect(save_animation)
            else:
                self.over_looppoint_count = 0 # how many times we passed the loop point
                save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230); image: url(:/icons/save.svg);}&#34;)
            pause_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/pause.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
            next_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/right-arrow.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
            prev_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/left-arrow.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193)}&#34;)
        else:
            if isinstance(self.desired_traversal, Traversal):
                save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
                save_button.clicked.connect(save_animation)
            else:
                self.over_looppoint_count = 0
                save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230); image: url(:/icons/save.svg);}&#34;)
            pause_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/pause.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            next_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/right-arrow.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            prev_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/left-arrow.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123)}&#34;)

        self.step = -1
        self.timer = QtCore.QTimer(self)
        self.timer.timeout.connect(update_image) # timer calls `update_image` everytime event is triggered
        update_image()
        self.timer.start(800) # triggers event every 800 millisecond

        dlg.setWindowTitle(&#34;Animation&#34;)
        dlg.setFixedSize(545, 410)
        dlg.closeEvent = self.stop_animation # stop timer when window is closed
        dlg.exec_()


    def stop_animation(self, event):
        &#34;&#34;&#34;Stops the timer that is used for the animation.
        Without this method the application would crash if the animation window would get closed.
        Args:
            event: Close event of the window that shows animation.
        &#34;&#34;&#34;
        self.timer.disconnect()


    def hide_retain_space(self, widgets: list):
        &#34;&#34;&#34;Retains the space of a widget even when it&#39;s hidden.

        Args:
            widget (QtWidgets.QWidget ): Widget whose space should be retained.
        &#34;&#34;&#34;
        for widget in widgets:
            retain = widget.sizePolicy()
            retain.setRetainSizeWhenHidden(True)
            widget.setSizePolicy(retain)


    def hide_multiple(self, widgets: list):
        &#34;&#34;&#34;Hides multiple widgets at once, makes code a lot shorter because it unites several calls of the same function.

        Args:
            widgets (list): Widgets who should be hidden.
        &#34;&#34;&#34;
        for widget in widgets:
            widget.hide()


    def show_multiple(self, widgets: list):
        &#34;&#34;&#34;Shows multiple widgets at once, makes code a lot shorter because it unites several calls of the same function.

        Args:
            widgets (list): Widgets who should be showed.
        &#34;&#34;&#34;
        for widget in widgets:
            widget.show()


    def heightForWidth(self, width: float):
        &#34;&#34;&#34;Computes height for a given width.

        Args:
            width (float): Given width.

        Returns:
            float: Computed height.
        &#34;&#34;&#34;
        height_for_width_factor = 1.0 * 519 / 688
        return math.ceil(width * height_for_width_factor)


    def widthForHeight(self, height):
        &#34;&#34;&#34;Computes width for a given height.

        Args:
            height (float): Given height.

        Returns:
            float: Computed width.
        &#34;&#34;&#34;
        width_for_height_factor = 1.0 * 688 / 519
        return math.ceil(height * width_for_height_factor)


    def resizeEvent(self, event: QtGui.QResizeEvent):
        &#34;&#34;&#34;Keeps the right aspect ratio of the graph visualisation image (or welcoming screen in the beginning) when window is resized.

        Args:
            event (QtGui.QResizeEvent): Resize event.
        &#34;&#34;&#34;
        super(MainWindow, self).resizeEvent(event)
        size = event.size()
        # window height minus height of all widgets below the label result in height of pixmap
        height = size.height() - self.save.height() - self.submit_molecule.height() - self.submit_exterior_nodes.height() - self.paths.height() - self.show_animation.height()
        if self.widthForHeight(height) &gt; size.width(): # pixmap width should be as most as big as width of whole window
            width = size.width()
        else:
            width = self.widthForHeight(height)
        self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(width, height, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
        self.display_molecule_m.setPixmap(QtGui.QPixmap.fromImage(self.qim_m).scaled(width, height, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="soliton_automata.gui.main_window_ba.MainWindow"><code class="flex name class">
<span>class <span class="ident">MainWindow</span></span>
</code></dt>
<dd>
<div class="desc"><p>Main Window of the GUI. Inherits from class <code>QMainWindow</code>.</p>
<p>Initializes the main window.
Main window contains a stacked layout with one window for single soliton case and one window for multi soliton case.
Both display a welcoming text and all necessary widgets for the user to specify and submit a soliton graph.
All other widgets are hidden for now and are revealed step by step, so user is guided through the use of the application.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MainWindow(QMainWindow):
    &#34;&#34;&#34;Main Window of the GUI. Inherits from class `QMainWindow`.
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;Initializes the main window.
        Main window contains a stacked layout with one window for single soliton case and one window for multi soliton case.
        Both display a welcoming text and all necessary widgets for the user to specify and submit a soliton graph.
        All other widgets are hidden for now and are revealed step by step, so user is guided through the use of the application.
        &#34;&#34;&#34;
        super(MainWindow, self).__init__()
        self.setObjectName(&#34;MainWindow&#34;)
        # central widget is a stacked layout (so user can switch between the two different windows)
        self.central_wid = QtWidgets.QWidget()
        self.layout_for_wids = QtWidgets.QStackedLayout()
        self.central_wid.setStyleSheet(&#34;&#34;&#34;background: white;&#34;&#34;&#34;)
        # move window to the top of the screen + to the center horizontally
        qt_rectangle = self.frameGeometry()
        center_point = QtWidgets.QDesktopWidget().availableGeometry().center()
        qt_rectangle.moveCenter(center_point)
        self.move(qt_rectangle.topLeft().x(), 0)
        self.resize(QtCore.QSize(600, 650))


        # SOLITON AUTOMATA WIDGET
        self.wid_single = QtWidgets.QWidget()
        self.gridLayout = QtWidgets.QGridLayout(self.wid_single)
        # Row 0:
        # Rectangle that displays the molecule
        self.display_molecule = QtWidgets.QLabel(self.wid_single)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Ignored)
        self.display_molecule.setSizePolicy(sizePolicy)
        self.display_molecule.setMinimumSize(QtCore.QSize(50, 37))
        startscreen = Startscreen().image
        self.qim = ImageQt(startscreen)
        self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(self.display_molecule.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
        self.gridLayout.addWidget(self.display_molecule, 0, 0, 2, 5, alignment = QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter)
        # Button that changes between the two windows
        self.change_window_button = QtWidgets.QPushButton(&#34;Switch Mode&#34;)
        self.change_window_button.setMinimumSize(QtCore.QSize(0, 20))
        self.gridLayout.addWidget(self.change_window_button, 0, 0, 1, 1)
        self.change_window_button.setStyleSheet(&#34;QPushButton {border-radius: 10px;}&#34;)
        # Row 1: -
        # Row 2:
        # &#34;Traversal Mode&#34; Checkbox
        self.traversal_mode = QtWidgets.QCheckBox(&#34;Traversal Mode&#34;)
        self.traversal_mode.setChecked(False)
        self.gridLayout.addWidget(self.traversal_mode, 2, 0, 1, 1)
        # Groupbox containg last two elements of row 2
        self.row2 = QtWidgets.QGroupBox()
        self.minigrid2 = QtWidgets.QGridLayout(self.row2)
        self.minigrid2.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.addWidget(self.row2, 2, 3, 1, 1)
        # Info button
        self.mol_info = QtWidgets.QPushButton(self.wid_single)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.mol_info.setSizePolicy(sizePolicy)
        self.mol_info.setMinimumSize(QtCore.QSize(0, 32))
        self.minigrid2.addWidget(self.mol_info, 2, 0, 1, 1)
        # Save button for the molecule
        self.save = QtWidgets.QPushButton(self.wid_single)
        self.save.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.save.setSizePolicy(sizePolicy)
        self.save.setMaximumSize(QtCore.QSize(16777215, 32))
        self.save.setMinimumSize(QtCore.QSize(0, 32))
        self.minigrid2.addWidget(self.save, 2, 1, 1, 1)
        # Row 3:
        # &#34;Molecule&#34; label
        self.molecule_label = QtWidgets.QLabel(self.wid_single)
        self.gridLayout.addWidget(self.molecule_label, 3, 0, 1, 1)
        # Groupbox containg middle two elements of row 3
        self.row3 = QtWidgets.QGroupBox()
        self.minigrid3 = QtWidgets.QGridLayout(self.row3)
        self.minigrid3.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.addWidget(self.row3, 3, 1, 1, 2)
        # Text field for molecule
        self.molecule_lineedit = QtWidgets.QLineEdit(self.row3)
        self.minigrid3.addWidget(self.molecule_lineedit, 0, 0, 1, 1)
        # Groupbox containg &#34;stop number&#34; widgets
        self.row3_2 = QtWidgets.QGroupBox()
        self.minigrid3_2 = QtWidgets.QGridLayout(self.row3_2)
        self.minigrid3_2.setContentsMargins(0, 0, 0, 0)
        self.minigrid3.addWidget(self.row3_2, 0, 1, 1, 1)
        # &#34;Stop number&#34; label
        self.stop_number_label = QtWidgets.QLabel(self.row3_2)
        self.minigrid3_2.addWidget(self.stop_number_label, 0, 0, 1, 1)
        # Spinbox for &#34;stop number&#34;
        self.stop_number_spinbox = QtWidgets.QSpinBox(self.row3_2)
        self.stop_number_spinbox.setValue(3)
        self.stop_number_spinbox.setMinimum(2)
        self.minigrid3_2.addWidget(self.stop_number_spinbox, 0, 1, 1, 1)
        # Submit button for molecule
        self.submit_molecule = QtWidgets.QPushButton(self.wid_single)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.submit_molecule.setSizePolicy(sizePolicy)
        self.submit_molecule.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout.addWidget(self.submit_molecule, 3, 3, 1, 1)
        # Row 4: 
        # &#34;Exterior nodes&#34; label
        self.exterior_nodes_label = QtWidgets.QLabel(self.wid_single)
        self.gridLayout.addWidget(self.exterior_nodes_label, 4, 0, 1, 1)
        # Groupbox containg middle elements of row 4
        self.row4 = QtWidgets.QGroupBox()
        self.minigrid4 = QtWidgets.QGridLayout(self.row4)
        self.minigrid4.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.addWidget(self.row4, 4, 1, 1, 2)
        # &#34;All&#34; Checkbox
        self.all_exterior_nodes = QtWidgets.QCheckBox(&#34;All&#34;)
        self.all_exterior_nodes.setChecked(False)
        self.minigrid4.addWidget(self.all_exterior_nodes, 4, 0, 1, 1)
        # Combobox to choose first exterior node
        self.node_1 = QtWidgets.QComboBox(self.row4)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.node_1.setSizePolicy(sizePolicy)
        self.minigrid4.addWidget(self.node_1, 4, 1, 1, 1)
        # &#34;&amp;&#34; label
        self.exterior_nodes_label2 = QtWidgets.QLabel(self.row4)
        self.minigrid4.addWidget(self.exterior_nodes_label2, 4, 2, 1, 1)
        # Combobox to choose second exterior node
        self.node_2 = QtWidgets.QComboBox(self.row4)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.node_2.setSizePolicy(sizePolicy)
        self.minigrid4.addWidget(self.node_2, 4, 3, 1, 1)
        # Submit button for exterior nodes
        self.submit_exterior_nodes = QtWidgets.QPushButton(self.wid_single)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.submit_exterior_nodes.setSizePolicy(sizePolicy)
        self.submit_exterior_nodes.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout.addWidget(self.submit_exterior_nodes, 4, 3, 1, 1)
        # Row 5:
        # &#34;Soliton paths&#34; label
        self.soliton_paths_label = QtWidgets.QLabel(self.wid_single)
        self.gridLayout.addWidget(self.soliton_paths_label, 5, 0, 1, 1)
        # Groupbox containg middle elements of row 5
        self.row5 = QtWidgets.QGroupBox()
        self.minigrid5 = QtWidgets.QGridLayout(self.row5)
        self.minigrid5.setContentsMargins(0, 0, 0, 0)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.row5.setSizePolicy(sizePolicy)
        self.row5.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout.addWidget(self.row5, 5, 1, 1, 3)
        # &#34;Loops&#34; checkbox
        self.if_loops = QtWidgets.QCheckBox(&#34;Loops&#34;)
        self.if_loops.setChecked(True)
        self.if_loops.setFixedWidth(68)
        self.minigrid5.addWidget(self.if_loops, 5, 0, 1, 1)
        # Combobox to choose a soliton path
        self.paths = QtWidgets.QComboBox(self.row5)
        self.minigrid5.addWidget(self.paths, 5, 1, 1, 2)
        # Row 6:
        # &#34;Show matrices&#34; button
        self.show_matrices = QtWidgets.QPushButton(self.wid_single)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.show_matrices.setSizePolicy(sizePolicy)
        self.show_matrices.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout.addWidget(self.show_matrices, 6, 1, 1, 1)
        # &#34;Show end result&#34; button
        self.show_end_result = QtWidgets.QPushButton(self.wid_single)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.show_end_result.setSizePolicy(sizePolicy)
        self.show_end_result.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout.addWidget(self.show_end_result, 6, 2, 1, 1)
        # &#34;Show animation&#34; button
        self.show_animation = QtWidgets.QPushButton(self.wid_single)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.show_animation.setSizePolicy(sizePolicy)
        self.show_animation.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout.addWidget(self.show_animation, 6, 3, 1, 1)
        # Menubar:
        self.menubar = QtWidgets.QMenuBar(self)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 564, 24))
        self.setMenuBar(self.menubar)

        # Function connections of different widgets:
        self.change_window_button.clicked.connect(self.change_window)
        self.traversal_mode.stateChanged.connect(lambda:self.change_mode(self.traversal_mode))
        self.mol_info.clicked.connect(self.mol_info_clicked)
        self.save.clicked.connect(self.save_clicked)
        self.submit_molecule.clicked.connect(self.submit_molecule_clicked)
        self.all_exterior_nodes.stateChanged.connect(self.all_exterior_nodes_statechanged)
        self.submit_exterior_nodes.clicked.connect(self.submit_exterior_nodes_clicked)
        self.if_loops.stateChanged.connect(lambda:self.loops_onoff(self.if_loops))
        self.paths.currentIndexChanged.connect(lambda: self.endless_loop_picked(self.paths))
        self.show_matrices.clicked.connect(self.show_matrices_clicked)
        self.show_end_result.clicked.connect(self.show_end_result_clicked)
        self.show_animation.clicked.connect(lambda:self.show_animation_clicked(self.show_animation))
        # Hide most widgets at the beginning (while retaining space) 
        self.hide_retain_space([self.traversal_mode, self.row2, self.exterior_nodes_label, self.row4, self.submit_exterior_nodes, self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
        self.hide_multiple([self.traversal_mode, self.row2, self.exterior_nodes_label, self.row4, self.submit_exterior_nodes, self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
        # Stylesheet:
        readme_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), &#39;../styles.css&#39;)
        with open(readme_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as fh:
            self.style = fh.read()
        self.wid_single.setStyleSheet(self.style)


        # MULTI-WAVE SOLITON AUTOMATA WIDGET
        self.wid_mult = QtWidgets.QWidget()
        self.gridLayout_m = QtWidgets.QGridLayout(self.wid_mult)
        # Row 0:
        # Rectangle that displays the molecule
        self.display_molecule_m = QtWidgets.QLabel(self.wid_mult)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Ignored)
        self.display_molecule_m.setSizePolicy(sizePolicy)
        self.display_molecule_m.setMinimumSize(QtCore.QSize(50, 37))
        startscreen_m = Startscreen().image
        self.qim_m = ImageQt(startscreen_m)
        self.display_molecule_m.setPixmap(QtGui.QPixmap.fromImage(self.qim_m).scaled(self.display_molecule_m.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
        self.gridLayout_m.addWidget(self.display_molecule_m, 0, 0, 2, 5, alignment = QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter)
        # Button that changes between the two windows
        self.change_window_button_m = QtWidgets.QPushButton(&#34;Switch Mode&#34;)
        self.change_window_button_m.setMinimumSize(QtCore.QSize(0, 20))
        self.gridLayout_m.addWidget(self.change_window_button_m, 0, 0, 1, 1)
        self.change_window_button_m.setStyleSheet(&#34;QPushButton {border-radius: 10px;}&#34;)
        # Row 1: -
        # Row 2:
        # &#34;Traversal Mode&#34; Checkbox
        self.traversal_mode_m = QtWidgets.QCheckBox(&#34;Traversal Mode&#34;)
        self.traversal_mode_m.setChecked(False)
        self.gridLayout_m.addWidget(self.traversal_mode_m, 2, 0, 1, 1)
        # Groupbox containg last two elements of row 2
        self.row2_m = QtWidgets.QGroupBox()
        self.minigrid2_m = QtWidgets.QGridLayout(self.row2_m)
        self.minigrid2_m.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_m.addWidget(self.row2_m, 2, 3, 1, 1)
        # Info button
        self.mol_info_m = QtWidgets.QPushButton(self.row2_m)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.mol_info_m.setSizePolicy(sizePolicy)
        self.mol_info_m.setMinimumSize(QtCore.QSize(0, 32))
        self.minigrid2_m.addWidget(self.mol_info_m, 2, 0, 1, 1)
        # Save button for the molecule
        self.save_m = QtWidgets.QPushButton(self.row2_m)
        self.save_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.save_m.setSizePolicy(sizePolicy)
        self.save_m.setMaximumSize(QtCore.QSize(16777215, 32))
        self.save_m.setMinimumSize(QtCore.QSize(0, 32))
        self.minigrid2_m.addWidget(self.save_m, 2, 1, 1, 1)
        # Row 3:
        # &#34;Molecule&#34; label
        self.molecule_label_m = QtWidgets.QLabel(self.wid_mult)
        self.gridLayout_m.addWidget(self.molecule_label_m, 3, 0, 1, 1)
        # Text field for molecule
        self.molecule_lineedit_m = QtWidgets.QLineEdit(self.wid_mult)
        self.gridLayout_m.addWidget(self.molecule_lineedit_m, 3, 1, 1, 2)
        # Submit button for molecule
        self.submit_molecule_m = QtWidgets.QPushButton(self.wid_mult)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.submit_molecule_m.setSizePolicy(sizePolicy)
        self.submit_molecule_m.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout_m.addWidget(self.submit_molecule_m, 3, 3, 1, 1)
        # Row 4: 
        # &#34;Set of bursts&#34; label
        self.set_of_bursts_label = QtWidgets.QLabel(self.wid_mult)
        self.gridLayout_m.addWidget(self.set_of_bursts_label, 4, 0, 1, 1)
        # Groupbox containg middle two elements of row 4
        self.row4_m = QtWidgets.QGroupBox()
        self.minigrid4_m = QtWidgets.QGridLayout(self.row4_m)
        self.minigrid4_m.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_m.addWidget(self.row4_m, 4, 1, 1, 2)
        # Text field for set of bursts
        self.set_of_bursts_lineedit = QtWidgets.QLineEdit(self.row4_m)
        self.minigrid4_m.addWidget(self.set_of_bursts_lineedit, 0, 0, 1, 1)
        # Groupbox containg &#34;stop number&#34; widgets
        self.row4_2_m = QtWidgets.QGroupBox()
        self.minigrid4_2_m = QtWidgets.QGridLayout(self.row4_2_m)
        self.minigrid4_2_m.setContentsMargins(0, 0, 0, 0)
        self.minigrid4_m.addWidget(self.row4_2_m, 0, 1, 1, 1)
        # &#34;Stop number&#34; label
        self.stop_number_label_m = QtWidgets.QLabel(self.row4_2_m)
        self.minigrid4_2_m.addWidget(self.stop_number_label_m, 0, 0, 1, 1)
        # Spinbox for &#34;stop number&#34;
        self.stop_number_spinbox_m = QtWidgets.QSpinBox(self.row4_2_m)
        self.stop_number_spinbox_m.setValue(3)
        self.stop_number_spinbox_m.setMinimum(2)
        self.minigrid4_2_m.addWidget(self.stop_number_spinbox_m, 0, 1, 1, 1)
        # Submit button for set of bursts
        self.submit_set_of_bursts = QtWidgets.QPushButton(self.wid_mult)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.submit_set_of_bursts.setSizePolicy(sizePolicy)
        self.submit_set_of_bursts.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout_m.addWidget(self.submit_set_of_bursts, 4, 3, 1, 1)
        # Row 5:
        # &#34;Bursts&#34; label
        self.bursts_label = QtWidgets.QLabel(self.wid_mult)
        self.gridLayout_m.addWidget(self.bursts_label, 5, 0, 1, 1)
        # Groupbox containg middle elements of row 5
        self.row5_m = QtWidgets.QGroupBox()
        self.minigrid4_m = QtWidgets.QGridLayout(self.row5_m)
        self.minigrid4_m.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_m.addWidget(self.row5_m, 5, 1, 1, 2)
        # &#34;All&#34; checkbox
        self.all_bursts = QtWidgets.QCheckBox(&#34;All&#34;)
        self.all_bursts.setChecked(False)
        self.minigrid4_m.addWidget(self.all_bursts, 5, 0, 1, 1)
        # Combobox to choose burst
        self.burst = QtWidgets.QComboBox(self.row5_m)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.burst.setSizePolicy(sizePolicy)
        self.minigrid4_m.addWidget(self.burst, 5, 1, 1, 1)
        # Submit button for burst
        self.submit_burst = QtWidgets.QPushButton(self.wid_mult)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        self.submit_burst.setSizePolicy(sizePolicy)
        self.submit_burst.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout_m.addWidget(self.submit_burst, 5, 3, 1, 1)
        # Row 6:
        # &#34;Traversals&#34; label
        self.traversals_label = QtWidgets.QLabel(self.wid_mult)
        self.gridLayout_m.addWidget(self.traversals_label, 6, 0, 1, 1)
        # Groupbox containg middle elements of row 6
        self.row6_m = QtWidgets.QGroupBox()
        self.minigrid6_m = QtWidgets.QGridLayout(self.row6_m)
        self.minigrid6_m.setContentsMargins(0, 0, 0, 0)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.row6_m.setSizePolicy(sizePolicy)
        self.row6_m.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout_m.addWidget(self.row6_m, 6, 1, 1, 3)
        # &#34;Loops&#34; Checkbox
        self.if_loops_m = QtWidgets.QCheckBox(&#34;Loops&#34;)
        self.if_loops_m.setChecked(True)
        self.if_loops_m.setFixedWidth(68)
        self.minigrid6_m.addWidget(self.if_loops_m, 6, 0, 1, 1)
        # Combobox to choose a traversal
        self.traversals = QtWidgets.QComboBox(self.row6_m)
        self.minigrid6_m.addWidget(self.traversals, 6, 1, 1, 2)
        # Row 7:
        # &#34;Show matrices&#34; button
        self.show_matrices_m = QtWidgets.QPushButton(self.wid_mult)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.show_matrices_m.setSizePolicy(sizePolicy)
        self.show_matrices_m.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout_m.addWidget(self.show_matrices_m, 7, 1, 1, 1)
        # &#34;Show end result&#34; button
        self.show_end_result_m = QtWidgets.QPushButton(self.wid_mult)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.show_end_result_m.setSizePolicy(sizePolicy)
        self.show_end_result_m.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout_m.addWidget(self.show_end_result_m, 7, 2, 1, 1)
        # &#34;Show animation&#34; button
        self.show_animation_m = QtWidgets.QPushButton(self.wid_mult)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.show_animation_m.setSizePolicy(sizePolicy)
        self.show_animation_m.setMinimumSize(QtCore.QSize(0, 32))
        self.gridLayout_m.addWidget(self.show_animation_m, 7, 3, 1, 1)

        # Function connections of different widgets:
        self.change_window_button_m.clicked.connect(self.change_window)
        self.traversal_mode_m.stateChanged.connect(lambda:self.change_mode_m(self.traversal_mode_m))
        self.mol_info_m.clicked.connect(self.mol_info_clicked_m)
        self.save_m.clicked.connect(self.save_clicked_m)
        self.all_bursts.stateChanged.connect(self.all_bursts_statechanged)
        self.submit_molecule_m.clicked.connect(self.submit_molecule_clicked_m)
        self.submit_set_of_bursts.clicked.connect(self.submit_set_of_bursts_clicked)
        self.submit_burst.clicked.connect(self.submit_burst_clicked)
        self.if_loops_m.stateChanged.connect(lambda:self.loops_onoff_m(self.if_loops_m))
        self.traversals.currentIndexChanged.connect(lambda: self.endless_loop_picked_m(self.traversals))
        self.show_matrices_m.clicked.connect(self.show_matrices_clicked_m)
        self.show_end_result_m.clicked.connect(self.show_end_result_clicked_m)
        self.show_animation_m.clicked.connect(lambda:self.show_animation_clicked(self.show_animation_m))
        # Hide most widgets at the beginning (while retaining space)
        self.hide_retain_space([self.traversal_mode_m, self.save_m, self.mol_info_m, self.set_of_bursts_label, self.row4_m, self.row4_2_m, self.submit_set_of_bursts, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
        self.hide_multiple([self.traversal_mode_m, self.save_m, self.mol_info_m, self.set_of_bursts_label, self.row4_m, self.row4_2_m, self.submit_set_of_bursts, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
        # Stylesheet:
        readme_path_m = os.path.join(os.path.dirname(os.path.abspath(__file__)), &#39;../styles_m.css&#39;)
        with open(readme_path_m, &#34;r&#34;, encoding=&#34;utf-8&#34;) as fh_m:
            self.style_m = fh_m.read()
        self.wid_mult.setStyleSheet(self.style_m)


        # Add both widgets to stacked layout, default widget when starting the software is single soliton case widget
        self.layout_for_wids.addWidget(self.wid_single)
        self.layout_for_wids.addWidget(self.wid_mult)
        self.central_wid.setLayout(self.layout_for_wids)
        self.setCentralWidget(self.central_wid)
        self.front_wid = 1
        self.retranslateUi()
        QtCore.QMetaObject.connectSlotsByName(self)


    def retranslateUi(self):
        &#34;&#34;&#34;Implements multi-language suppport. Is generated automatically when using PyQt5 UI code generator.
        &#34;&#34;&#34;
        _translate = QtCore.QCoreApplication.translate
        self.setWindowTitle(_translate(&#34;MainWindow&#34;, &#34;Soliton Automata Software&#34;))
        self.mol_info.setText(_translate(&#34;MainWindow&#34;, &#34;Info&#34;))
        self.molecule_label.setText(_translate(&#34;MainWindow&#34;, &#34;Molecule:&#34;))
        self.stop_number_label.setText(_translate(&#34;MainWindow&#34;, &#34;Stop:&#34;))
        self.submit_molecule.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
        self.exterior_nodes_label.setText(_translate(&#34;MainWindow&#34;, &#34;Exterior nodes:&#34;))
        self.exterior_nodes_label2.setText(_translate(&#34;MainWindow&#34;, &#34;&amp;&#34;))
        self.submit_exterior_nodes.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
        self.soliton_paths_label.setText(_translate(&#34;MainWindow&#34;, &#34;Soliton paths:&#34;))
        self.show_matrices.setText(_translate(&#34;MainWindow&#34;, &#34;Show matrices&#34;))
        self.show_end_result.setText(_translate(&#34;MainWindow&#34;, &#34;Show end result&#34;))
        self.show_animation.setText(_translate(&#34;MainWindow&#34;, &#34;Show animation&#34;))

        self.mol_info_m.setText(_translate(&#34;MainWindow&#34;, &#34;Info&#34;))
        self.molecule_label_m.setText(_translate(&#34;MainWindow&#34;, &#34;Molecule:&#34;))
        self.submit_molecule_m.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
        self.set_of_bursts_label.setText(_translate(&#34;MainWindow&#34;, &#34;Set of bursts:&#34;))
        self.submit_set_of_bursts.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
        self.bursts_label.setText(_translate(&#34;MainWindow&#34;, &#34;Bursts:&#34;))
        self.stop_number_label_m.setText(_translate(&#34;MainWindow&#34;, &#34;Stop:&#34;))
        self.submit_burst.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
        self.traversals_label.setText(_translate(&#34;MainWindow&#34;, &#34;Sets of paths:&#34;))
        self.show_matrices_m.setText(_translate(&#34;MainWindow&#34;, &#34;Show matrices&#34;))
        self.show_end_result_m.setText(_translate(&#34;MainWindow&#34;, &#34;Show end result&#34;))
        self.show_animation_m.setText(_translate(&#34;MainWindow&#34;, &#34;Show animation&#34;))


    def change_window(self):
        &#34;&#34;&#34;Is called when &#34;Change Mode&#34; button is clicked. Changes between the two widgets of the stacked layout.
        &#34;&#34;&#34;
        if self.front_wid == 1:
            self.layout_for_wids.setCurrentIndex(1)
            self.front_wid = 2
        else:
            self.layout_for_wids.setCurrentIndex(0)
            self.front_wid = 1


    def change_mode(self, checkbox: QtWidgets.QCheckBox):
        &#34;&#34;&#34;Realizes the change between being in traversal mode and not being in traversal mode in single soliton widget.
        In traversal mode, a soliton automata can be traversed by using an end result as the new soliton graph.
        When in traversal mode, the input molecule and stop number can&#39;t be edited.

        Args:
            checkbox (QtWidgets.QCheckBox): The checkbox that changes the mode.
        &#34;&#34;&#34;
        if checkbox.isChecked() == True:
            # make text field uneditable and button unclickable, turn both objects grey to make those properties visually recognizable
            self.submit_molecule.clicked.disconnect()
            self.submit_molecule.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
            self.molecule_lineedit.setReadOnly(True)
            self.molecule_lineedit.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(230, 230, 230);border-radius: 10px;padding: 0 8px;}&#34;)
            self.molecule_label.setText(&#34;Original molecule:&#34;)
            self.stop_number_spinbox.setReadOnly(True)
            self.stop_number_spinbox.setStyleSheet(&#34;QSpinBox {border: 1px solid rgb(230, 230, 230);border-radius: 10px;padding-right: 15px;}&#34;)
        else:
            self.submit_molecule.clicked.connect(self.submit_molecule_clicked)
            self.submit_molecule.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
            self.molecule_lineedit.setReadOnly(False)
            self.molecule_lineedit.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(191, 207, 255);border-radius: 10px;padding: 0 8px;}&#34;)
            self.molecule_label.setText(&#34;Molecule:&#34;)
            self.submit_molecule_clicked()
            self.stop_number_spinbox.setReadOnly(False)
            self.stop_number_spinbox.setStyleSheet(&#34;QSpinBox {border: 1px solid rgb(191, 207, 255);border-radius: 10px;padding-right: 15px;}&#34;)

    
    def change_mode_m(self, checkbox: QtWidgets.QCheckBox):
        &#34;&#34;&#34;Realizes the change between being in traversal mode and not being in traversal mode in multi soliton widget.
        In traversal mode, a soliton automata can be traversed by using an end result as the new soliton graph.
        When in traversal mode, the input molecule can&#39;t be edited.

        Args:
            checkbox (QtWidgets.QCheckBox): The checkbox that changes the mode.
        &#34;&#34;&#34;
        if checkbox.isChecked() == True:
            # make text field uneditable and button unclickable, turn both objects grey to make those properties visually recognizable
            self.submit_molecule_m.clicked.disconnect()
            self.submit_molecule_m.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
            self.molecule_lineedit_m.setReadOnly(True)
            self.molecule_lineedit_m.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(230, 230, 230);border-radius: 10px;padding: 0 8px;}&#34;)
            self.molecule_label_m.setText(&#34;Original molecule:&#34;)
            self.submit_set_of_bursts.clicked.disconnect()
            self.submit_set_of_bursts.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
            self.set_of_bursts_lineedit.setReadOnly(True)
            self.set_of_bursts_lineedit.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(230, 230, 230);border-radius: 10px;padding: 0 8px;}&#34;)
            self.stop_number_spinbox_m.setReadOnly(True)
            self.stop_number_spinbox_m.setStyleSheet(&#34;QSpinBox {border: 1px solid rgb(230, 230, 230);border-radius: 10px;padding-right: 15px;}&#34;)
        else:
            self.submit_molecule_m.clicked.connect(self.submit_molecule_clicked_m)
            self.submit_molecule_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            self.molecule_lineedit_m.setReadOnly(False)
            self.molecule_lineedit_m.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(149, 221, 185);border-radius: 10px;padding: 0 8px;}&#34;)
            self.molecule_label_m.setText(&#34;Molecule:&#34;)
            self.submit_molecule_clicked_m()
            self.submit_set_of_bursts.clicked.connect(self.submit_set_of_bursts_clicked)
            self.submit_set_of_bursts.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            self.set_of_bursts_lineedit.setReadOnly(False)
            self.set_of_bursts_lineedit.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(149, 221, 185);border-radius: 10px;padding: 0 8px;}&#34;)
            self.stop_number_spinbox_m.setReadOnly(False)
            self.stop_number_spinbox_m.setStyleSheet(&#34;QSpinBox {border: 1px solid rgb(149, 221, 185);border-radius: 10px;padding-right: 15px;}&#34;)


    def submit_molecule_clicked(self):
        &#34;&#34;&#34;Is called when user clicks button to submit the specified molecule in single soliton widget.
        Catches errors if user used the wrong syntax or specified a molecule that does not fulfill the requirements of a soliton graph.
        If the user&#39;s molecule is valid it displays the graph of the molecule. It then also reveals a save button for the graph visualisation,
        an info button and all the necessary widgets for the user to choose exterior nodes.
        &#34;&#34;&#34;
        self.node_1.clear()
        self.node_2.clear()
        self.smiles_string = self.molecule_lineedit.text()
        self.stop_number = self.stop_number_spinbox.value()
        try:
            self.my_graph = SolitonGraph(self.smiles_string)
            errors = self.my_graph.validate_soliton_graph()
            self.automata = SolitonAutomata(self.my_graph, self.stop_number)
            self.graph_pic = Visualisation.visualize_soliton_graph(self.my_graph, self.my_graph.bindings, False, True)
            self.qim = ImageQt(self.graph_pic)
            self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(self.display_molecule.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
            if errors != []:
                self.hide_multiple([self.traversal_mode, self.row2, self.exterior_nodes_label, self.row4, self.submit_exterior_nodes, self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
                msg = QMessageBox(self.wid_single)
                msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px;}&#34;)
                msg.setWindowTitle(&#34;No soliton graph&#34;)
                msg.setText(&#34;You specified a molecule that does not fulfill the requirements of a soliton graph.&#34;)
                msg.setIcon(QMessageBox.Warning)
                msg.setStandardButtons(QMessageBox.Retry)
                msg.setInformativeText(&#34;See details for all incorrect parts of your molecule.&#34;)
                details = &#34;&#34;
                for i, error in enumerate(errors):
                    if i == len(errors) - 1:
                        details = details + f&#34;- {error}&#34;
                    else:
                        details = details + f&#34;- {error}&#34; + &#34;\n&#34;
                msg.setDetailedText(details)
                x = msg.exec_() # show messagebox
            elif self.my_graph.exterior_nodes_name_collision() == True:
                self.hide_multiple([self.traversal_mode, self.row2, self.exterior_nodes_label, self.row4, self.submit_exterior_nodes, self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
                msg = QMessageBox(self.wid_single)
                msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
                msg.setWindowTitle(&#34;Name collision&#34;)
                msg.setText(&#34;You specified two or more exterior nodes with the same name.&#34;)
                msg.setIcon(QMessageBox.Warning)
                msg.setStandardButtons(QMessageBox.Retry)
                x = msg.exec_()
            else:
                self.show_multiple([self.traversal_mode, self.row2, self.exterior_nodes_label, self.row4, self.submit_exterior_nodes])
                self.hide_multiple([self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
                for key in self.my_graph.exterior_nodes_reverse:
                    self.node_1.addItem(key)
                    self.node_2.addItem(key)
        except:
            self.hide_multiple([self.traversal_mode, self.row2, self.exterior_nodes_label, self.row4, self.submit_exterior_nodes, self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
            msg = QMessageBox(self.wid_single)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
            msg.setWindowTitle(&#34;Incorrect input&#34;)
            msg.setText(&#34;The syntax of your input is not correct.&#34;)
            msg.setIcon(QMessageBox.Warning)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;Please try again with another input string.&#34;)
            details = f&#34;Reminder - this is how you define a molecule: \n&#34;
            details = details + f&#34;- Carbon atoms are marked with &#39;C&#39; \n&#34;
            details = details + f&#34;- Single bonds are marked with &#39;-&#39; or no character at all \n&#34;
            details = details + f&#34;- Double bonds are marked with &#39;=&#39; \n&#34;
            details = details + f&#34;- Branches are embedded in round brackets (e.g. &#39;C(=CC=C)C&#39;)\n&#34;
            details = details + f&#34;- The two connecting atoms of a ring are marked with the same number (e.g. &#39;C1&#39; and &#39;C1&#39;) \n&#34;
            details = details + &#34;- Exterior nodes are marked with braces and a number (e.g. &#39;{=1}&#39;)&#34;
            msg.setDetailedText(details)
            x = msg.exec_()


    def submit_molecule_clicked_m(self):
        &#34;&#34;&#34;Is called when user clicks button to submit the specified molecule in multi soliton widget.
        Catches errors if user used the wrong syntax or specified a molecule that does not fulfill the requirements of a soliton graph.
        If the user&#39;s molecule is valid it displays the graph of the molecule. It then also reveals a save button for the graph visualisation,
        an info button and all the necessary widgets for the user to specify a set of bursts and a stop number.
        &#34;&#34;&#34;
        self.smiles_string_m = self.molecule_lineedit_m.text()
        try:
            self.my_graph_m = SolitonGraph(self.smiles_string_m)
            errors = self.my_graph_m.validate_soliton_graph()
            self.graph_pic_m = Visualisation.visualize_soliton_graph(self.my_graph_m, self.my_graph_m.bindings, False, True)
            self.qim_m = ImageQt(self.graph_pic_m)
            self.display_molecule_m.setPixmap(QtGui.QPixmap.fromImage(self.qim_m).scaled(self.display_molecule_m.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
            self.set_of_bursts_lineedit.clear()
            if errors != []:
                self.hide_multiple([self.traversal_mode_m, self.save_m, self.mol_info_m, self.set_of_bursts_label, self.row4_m, self.row4_2_m, self.submit_set_of_bursts, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
                msg = QMessageBox(self.wid_mult)
                msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
                msg.setWindowTitle(&#34;No soliton graph&#34;)
                msg.setText(&#34;You specified a molecule that does not fulfill the requirements of a soliton graph.&#34;)
                msg.setIcon(QMessageBox.Warning)
                msg.setStandardButtons(QMessageBox.Retry)
                msg.setInformativeText(&#34;See details for all incorrect parts of your molecule.&#34;)
                details = &#34;&#34;
                for i, error in enumerate(errors):
                    if i == len(errors) - 1:
                        details = details + f&#34;- {error}&#34;
                    else:
                        details = details + f&#34;- {error}&#34; + &#34;\n&#34;
                msg.setDetailedText(details)
                x = msg.exec_() # show messagebox
            elif self.my_graph_m.exterior_nodes_name_collision() == True:
                self.hide_multiple([self.traversal_mode_m, self.save_m, self.mol_info_m, self.set_of_bursts_label, self.row4_m, self.row4_2_m, self.submit_set_of_bursts, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
                msg = QMessageBox(self.wid_mult)
                msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
                msg.setWindowTitle(&#34;Name collision&#34;)
                msg.setText(&#34;You specified two or more exterior nodes with the same name.&#34;)
                msg.setIcon(QMessageBox.Warning)
                msg.setStandardButtons(QMessageBox.Retry)
                x = msg.exec_()
            else:
                self.show_multiple([self.traversal_mode_m, self.save_m, self.set_of_bursts_label, self.row4_m, self.row4_2_m, self.submit_set_of_bursts])
                self.hide_multiple([self.mol_info_m, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
        except:
            self.hide_multiple([self.traversal_mode_m, self.save_m, self.mol_info_m, self.set_of_bursts_label, self.row4_m, self.row4_2_m, self.submit_set_of_bursts, self.mol_info_m, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
            msg = QMessageBox(self.wid_mult)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
            msg.setWindowTitle(&#34;Incorrect input&#34;)
            msg.setText(&#34;The syntax of your input is not correct.&#34;)
            msg.setIcon(QMessageBox.Warning)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;Please try again with another input string.&#34;)
            details = f&#34;Reminder - this is how you define a molecule: \n&#34;
            details = details + f&#34;- Carbon atoms are marked with &#39;C&#39; \n&#34;
            details = details + f&#34;- Single bonds are marked with &#39;-&#39; or no character at all \n&#34;
            details = details + f&#34;- Double bonds are marked with &#39;=&#39; \n&#34;
            details = details + f&#34;- Branches are embedded in round brackets (e.g. &#39;C(=CC=C)C&#39;)\n&#34;
            details = details + f&#34;- The two connecting atoms of a ring are marked with the same number (e.g. &#39;C1&#39; and &#39;C1&#39;) \n&#34;
            details = details + &#34;- Exterior nodes are marked with braces and a number (e.g. &#39;{=1}&#39;)&#34;
            msg.setDetailedText(details)
            x = msg.exec_()


    def mol_info_clicked(self):
        &#34;&#34;&#34;Is called when &#34;Info&#34; button in single soliton widget is clicked. Opens a dialog window showing whether
        the automata is deterministic and strongly deterministic and displaying all impervious paths.
        &#34;&#34;&#34;

        def save_info():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where a text file with all info on soliton automata/ soliton graph should be saved.
            Text file also contains the input string representing the molecule.
            Only allows `.txt` file suffix.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.wid_single, &#39;Save File&#39;, &#39;info.txt&#39;, &#39;Text files (*.txt)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;): # only do the following if user clicked on save button (without this line the application closes with an error if save action is cancelled)
                path = name[0]
                file = open(path, &#34;w&#34;)
                file.write(txt_text)
                file.close()
        
        txt_text = f&#34;Soliton graph: {self.smiles_string} \n&#34;
        txt_text = txt_text + f&#34;Stop number: {self.stop_number} \n\n&#34;
        dlg = QDialog(self.wid_single)
        grid = QtWidgets.QGridLayout(dlg)
        label_det = QtWidgets.QLabel(dlg)
        label_det.setText(&#34;Deterministic:&#34;)
        txt_text = txt_text + f&#34;Deterministic: &#34;
        grid.addWidget(label_det, 0, 0, 1, 1)
        det_bool = QtWidgets.QLabel(dlg)
        if self.automata.deterministic:
            det_bool.setText(&#34;Yes&#34;)
            txt_text = txt_text + f&#34;Yes \n&#34;
        else: 
            det_bool.setText(&#34;No&#34;)
            txt_text = txt_text + f&#34;No \n&#34;
        grid.addWidget(det_bool, 0, 1, 1, 1)
        label_strong_det = QtWidgets.QLabel(dlg)
        label_strong_det.setText(&#34;Strongly deterministic:&#34;)
        txt_text = txt_text + f&#34;Strongly deterministic: &#34;
        grid.addWidget(label_strong_det, 1, 0, 1, 1)
        strong_det_bool = QtWidgets.QLabel(dlg)
        if self.automata.strongly_deterministic:
            strong_det_bool.setText(&#34;Yes&#34;)
            txt_text = txt_text + f&#34;Yes \n&#34;
        else: 
            strong_det_bool.setText(&#34;No&#34;)
            txt_text = txt_text + f&#34;No \n&#34;
        grid.addWidget(strong_det_bool, 1, 1, 1, 1)
        label_imp_paths = QtWidgets.QLabel(dlg)
        label_imp_paths.setText(&#34;Impervious path(s):&#34;)
        txt_text = txt_text + f&#34;Impervious path(s): &#34;
        grid.addWidget(label_imp_paths, 2, 0, 1, 1, alignment = QtCore.Qt.AlignTop)
        save_button = QtWidgets.QPushButton(dlg)
        save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
        save_button.setMinimumSize(QtCore.QSize(0, 32))
        grid.addWidget(save_button, 3, 1, 1, 1)
        save_button.clicked.connect(save_info)
        group = QtWidgets.QGroupBox()
        layout = QtWidgets.QGridLayout(group)
        layout.setContentsMargins(0, 0, 0, 0)
        impervs = self.automata.find_impervious_paths()
        if impervs == []:
            layout.addWidget(QtWidgets.QLabel(&#34;-&#34;))
            txt_text = txt_text + f&#34;-&#34;
        for i, path in enumerate(impervs):
            layout.addWidget(QtWidgets.QLabel(path), i, 0, 1, 1, alignment = QtCore.Qt.AlignTop)
            txt_text = txt_text + f&#34;{path}&#34;
            if i != len(impervs)-1:
                txt_text = txt_text + f&#34;, &#34;
        grid.addWidget(group, 2, 1, 1, 1, alignment = QtCore.Qt.AlignTop)
        dlg.setWindowTitle(&#34;Info&#34;)
        dlg.exec_()

    
    def mol_info_clicked_m(self):
        &#34;&#34;&#34;Is called when &#34;Info&#34; button in multi soliton widget is clicked. Opens a dialog window showing whether
        the automata is deterministic and strongly deterministic.
        &#34;&#34;&#34;

        def save_info():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where a text file with all info on soliton automata/ soliton graph should be saved.
            Text file also contains the input string representing the molecule.
            Only allows `.txt` file suffix.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.wid_single, &#39;Save File&#39;, &#39;info.txt&#39;, &#39;Text files (*.txt)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;): # only do the following if user clicked on save button (without this line the application closes with an error if save action is cancelled)
                path = name[0]
                file = open(path, &#34;w&#34;)
                file.write(txt_text)
                file.close()
        
        dlg = QDialog(self.wid_single)
        grid = QtWidgets.QGridLayout(dlg)
        label_det = QtWidgets.QLabel(dlg)
        txt_text = f&#34;Soliton graph: {self.smiles_string_m} \n&#34;
        txt_text = txt_text + f&#34;Set of bursts: {self.bursts} \n&#34;
        txt_text = txt_text + f&#34;Stop number: {self.stop_number_m} \n\n&#34;
        label_det.setText(&#34;Deterministic:&#34;)
        txt_text = txt_text + f&#34;Deterministic: &#34;
        grid.addWidget(label_det, 0, 0, 1, 1)
        det_bool = QtWidgets.QLabel(dlg)
        if self.multi_automata.deterministic:
            det_bool.setText(&#34;Yes&#34;)
            txt_text = txt_text + f&#34;Yes \n&#34;
        else: 
            det_bool.setText(&#34;No&#34;)
            txt_text = txt_text + f&#34;No \n&#34;
        grid.addWidget(det_bool, 0, 1, 1, 1)
        label_strong_det = QtWidgets.QLabel(dlg)
        label_strong_det.setText(&#34;Strongly deterministic:&#34;)
        txt_text = txt_text + f&#34;Strongly deterministic: &#34;
        grid.addWidget(label_strong_det, 1, 0, 1, 1)
        strong_det_bool = QtWidgets.QLabel(dlg)
        if self.multi_automata.strongly_deterministic:
            strong_det_bool.setText(&#34;Yes&#34;)
            txt_text = txt_text + f&#34;Yes \n&#34;
        else: 
            strong_det_bool.setText(&#34;No&#34;)
            txt_text = txt_text + f&#34;No \n&#34;
        grid.addWidget(strong_det_bool, 1, 1, 1, 1)
        save_button = QtWidgets.QPushButton(dlg)
        save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
        save_button.setMinimumSize(QtCore.QSize(0, 32))
        grid.addWidget(save_button, 3, 1, 1, 1)
        save_button.clicked.connect(save_info)
        dlg.setWindowTitle(&#34;Info&#34;)
        dlg.exec_()


    def save_clicked(self):
        &#34;&#34;&#34;Is called when user clicks button to save the graph visualisation in single soliton widget.
        Opens a file dialog in which user can specify a path where the image should be saved.
        Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
        &#34;&#34;&#34;
        option = QtWidgets.QFileDialog.Options()
        name = QtWidgets.QFileDialog.getSaveFileName(self.wid_single, &#39;Save File&#39;, &#39;graph.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
        if name != (&#39;&#39;, &#39;&#39;):
            path = name[0]
            # turn PIL Image into byte array 
            imgByteArr = io.BytesIO()
            self.graph_pic.save(imgByteArr, format=&#39;PNG&#39;)
            imgByteArr = imgByteArr.getvalue()
            # save image at specified path
            file = open(path, &#34;wb&#34;)
            file.write(imgByteArr)
            file.close()


    def save_clicked_m(self):
        &#34;&#34;&#34;Is called when user clicks button to save the graph visualisation in multi soliton widget.
        Opens a file dialog in which user can specify a path where the image should be saved.
        Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
        &#34;&#34;&#34;
        option = QtWidgets.QFileDialog.Options()
        name = QtWidgets.QFileDialog.getSaveFileName(self.wid_mult, &#39;Save File&#39;, &#39;graph.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
        if name != (&#39;&#39;, &#39;&#39;):
            path = name[0] 
            imgByteArr = io.BytesIO()
            self.graph_pic_m.save(imgByteArr, format=&#39;PNG&#39;)
            imgByteArr = imgByteArr.getvalue()
            file = open(path, &#34;wb&#34;)
            file.write(imgByteArr)
            file.close()

    
    def submit_set_of_bursts_clicked(self):
        &#34;&#34;&#34;Method that is called when user clicks button to submit a set of bursts.
        Catches errors if user used the wrong syntax.
        If the user&#39;s set of bursts is valid it all the necessary widgets for the user to choose a burst.
        &#34;&#34;&#34;
        bursts = self.set_of_bursts_lineedit.text()
        self.bursts = bursts
        self.burst.clear()
        self.stop_number_m = self.stop_number_spinbox_m.value()
        try:
            self.multi_automata = MultiwaveSolitonAutomata(self.my_graph_m, bursts, self.stop_number_m)
            bursts = bursts.split(&#34;;&#34;)
            for burst in bursts:
                burst = re.sub(r&#34;[{}]+&#34;, &#34;&#34;, burst)
                self.burst.addItem(burst)
            self.show_multiple([self.mol_info_m, self.bursts_label, self.row5_m, self.submit_burst])
            self.hide_multiple([self.traversals_label, self.traversals, self.if_loops_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
        except:
            self.hide_multiple([self.mol_info_m, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
            msg = QMessageBox(self.wid_mult)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px;}&#34;)
            msg.setWindowTitle(&#34;Incorrect input&#34;)
            msg.setText(&#34;The syntax of your input is not correct.&#34;)
            msg.setIcon(QMessageBox.Warning)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;Please try again with another input string.&#34;)
            details = f&#34;Reminder - this is how you define a set of bursts: \n&#34;
            details = details + f&#34;- Starting and end node of a soliton are embedded in round brackets (e.g. (3, 2))\n&#34;
            details = details + f&#34;- Solitons are seperated by &#39;||&#39;\n&#34;
            details = details + f&#34;- The number in front of a soliton&#39;s pair of exterior nodes defines how many timesteps later than the previous soliton this soliton enters the graph\n&#34;
            details = details + f&#34;- A set of bursts is embedded in braces, where individual bursts are seperated by &#39;;&#39;\n&#34;
            details = details + &#34;- Example: &#34; + &#34;{(3,1)||1(1,2); (3,2)||4(2,1)}\n&#34;
            msg.setDetailedText(details)
            x = msg.exec_()


    def all_exterior_nodes_statechanged(self):
        &#34;&#34;&#34;Is called when &#34;All&#34; checkbox in single soliton widget is checked/ unchecked.
        Hides/ unhides widgets to choose a pair of exterior nodes.
        &#34;&#34;&#34;
        if self.all_exterior_nodes.isChecked():
            self.hide_multiple([self.node_1, self.exterior_nodes_label2, self.node_2])
        else: self.show_multiple([self.node_1, self.exterior_nodes_label2, self.node_2])


    def all_bursts_statechanged(self):
        &#34;&#34;&#34;Is called when &#34;All&#34; checkbox in multi soliton widget is checked/ unchecked.
        Hides/ unhides widgets to choose a burst.
        &#34;&#34;&#34;
        if self.all_bursts.isChecked():
            self.burst.hide()
        else: self.burst.show()


    def submit_exterior_nodes_clicked(self):
        &#34;&#34;&#34;Is called when user clicks button to submit exterior nodes.
        Displays all possible soliton paths between the two chosen nodes/ all pairs of exterior nodes.
        Informs the user if no soliton path exists between them.
        Otherwise all the necessary widgets for the user to choose a computed soliton path and look at further information on it are revealed.
        &#34;&#34;&#34;
        self.path_index = None # we need this variable later in show_animation_clicked
        self.paths.clear()
        self.if_loops.setChecked(True)
        if self.all_exterior_nodes.isChecked():
            key = self.automata.matrix_to_string(nx.to_numpy_array(self.my_graph.graph))
            self.found_paths = self.automata.states_plus_soliton_paths[key][1]
        else:
            node1 = self.my_graph.exterior_nodes_reverse[self.node_1.currentText()]
            node2 = self.my_graph.exterior_nodes_reverse[self.node_2.currentText()]
            self.found_paths = self.automata.call_find_all_paths_given_nodes(node1, node2, self.my_graph)
        if self.found_paths == []:
            self.hide_multiple([self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
            msg = QMessageBox(self.wid_single)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px;}&#34;)
            msg.setWindowTitle(&#34;No path found&#34;)
            msg.setText(&#34;There exists no soliton path between these exterior nodes.&#34;)
            msg.setIcon(QMessageBox.Information)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;Please try again with different exterior nodes or a different soliton automata.&#34;)
            x = msg.exec_()
        else:
            endless_loops = 0
            self.loops_indices = []
            for p, soliton_path in enumerate(self.found_paths):
                if isinstance(soliton_path, SolitonPath): # if soliton path is a real soliton path and no endless loop
                    self.paths.addItem(str(soliton_path.path_for_user))
                else:
                    this_path = &#34;[!] &#34;
                    this_path = this_path + soliton_path[0].path_for_user + &#34; ...&#34;
                    self.paths.addItem(this_path)
                    endless_loops += 1
                    self.loops_indices.append(p)
            self.soliton_paths_label.setText(f&#34;Soliton paths ({len(self.found_paths) - endless_loops}):&#34;)
            self.show_multiple([self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])

    
    def submit_burst_clicked(self):
        &#34;&#34;&#34;Is called when user clicks button to submit burst(s).
        Displays all possible traversals for the chosen burst/ all bursts.
        Informs the user if no traversals exists for it/ them.
        Otherwise all the necessary widgets for the user to choose a computed traversals and look at further information on it are revealed.
        &#34;&#34;&#34;
        self.traversal_index = None # we need this variable later in show_animation_clicked
        self.traversals.clear()
        self.if_loops_m.setChecked(True)
        if self.all_bursts.isChecked():
            key = self.multi_automata.matrix_to_string(nx.to_numpy_array(self.my_graph_m.graph))
            self.found_traversals = self.multi_automata.states_plus_traversals[key][1]
            self.num_traversals_per_burst = self.multi_automata.states_plus_traversals[key][2]
        else:
            burst_index = int(self.burst.currentIndex())
            self.found_traversals = self.multi_automata.call_find_all_travs_given_burst(self.multi_automata.bursts_dicts[burst_index], self.my_graph_m)
            self.num_traversals_per_burst = None
        if self.found_traversals == []:
            self.hide_multiple([self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
            msg = QMessageBox(self.wid_mult)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px;}&#34;)
            msg.setWindowTitle(&#34;No soliton paths found&#34;)
            msg.setText(&#34;With this burst(s), not all solitons can traverse the soliton graph successfully.&#34;)
            msg.setIcon(QMessageBox.Information)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;Please try again with different bursts.&#34;)
            x = msg.exec_()
        else:
            endless_loops = 0
            self.loops_indices_m = []
            for t, traversal in enumerate(self.found_traversals):
                if isinstance(traversal, Traversal): # if traversal is a real traversal and no endless loop
                    this_traversal = &#34;&#34;
                    for i, path in enumerate(traversal.traversal_for_user):
                        this_traversal = this_traversal + path
                        if i != len(traversal.traversal_for_user)-1:
                            this_traversal = this_traversal + &#34;, &#34;
                    self.traversals.addItem(this_traversal)
                else:
                    this_traversal = &#34;[!] &#34;
                    for i, path in enumerate(traversal[0].traversal_for_user):
                        this_traversal = this_traversal + path + &#34; ...&#34;
                        if i != len(traversal[0].traversal_for_user)-1:
                            this_traversal = this_traversal + &#34;, &#34;
                    self.traversals.addItem(this_traversal)
                    endless_loops += 1
                    self.loops_indices_m.append(t)
            self.traversals_label.setText(f&#34;Sets of paths ({len(self.found_traversals) - endless_loops}):&#34;)
            self.show_multiple([self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
            sep_index = 0
            if self.num_traversals_per_burst:
                for n, num in enumerate(self.num_traversals_per_burst): # add seperators to distinct which traversals resulted from which burst
                    if num != 0 and n != len(self.num_traversals_per_burst)-1: # don&#39;t add if there is no traversal for this burst of if it&#39;s the last burst
                        sep_index += num
                        self.traversals.insertSeparator(sep_index)
                        self.found_traversals.insert(sep_index, None) # so the indices in found_traversals correspond with the indices of the combobox items
                        self.loops_indices_m = [(index + 1) if (index &gt;= sep_index) else index for index in self.loops_indices_m]
                        sep_index += 1 # indices got shifted by one because seperator was added


    def loops_onoff(self, checkbox: QtWidgets.QCheckBox):
        &#34;&#34;&#34;Is called when &#34;loops&#34; checkbox in single soliton widget is checked/ unchecked.
        Hides &#34;loop paths&#34;/ unhides them.

        Args:
            checkbox (QtWidgets.QCheckBox): &#34;Loops&#34; checkbox.
        &#34;&#34;&#34;
        if checkbox.isChecked() == True:
            for index in self.loops_indices:
                if index &lt; self.paths.count():
                    view = self.paths.view()
                    view.setRowHidden(index, False)
                    model = self.paths.model()
                    item = model.item(index)
                    item.setFlags(item.flags() | Qt.ItemIsEnabled)
            self.paths.setCurrentIndex(0)
        else:
            for index in self.loops_indices:
                if index &lt; self.paths.count():
                    view = self.paths.view()
                    view.setRowHidden(index, True)
                    model = self.paths.model()
                    item = model.item(index)
                    item.setFlags(item.flags() &amp; ~Qt.ItemIsEnabled)
            curIndex = 0
            for i in range (0, len(self.found_paths)):
                if curIndex not in self.loops_indices:
                    break
                else:
                    curIndex += 1
            self.paths.setCurrentIndex(curIndex)


    def loops_onoff_m(self, checkbox: QtWidgets.QCheckBox):
        &#34;&#34;&#34;Is called when &#34;loops&#34; checkbox in multi soliton widget is checked/ unchecked.
        Hides &#34;loop traversals&#34;/ unhides them.

        Args:
            checkbox (QtWidgets.QCheckBox): &#34;Loops&#34; checkbox.
        &#34;&#34;&#34;
        if checkbox.isChecked() == True:
            for index in self.loops_indices_m:
                if index &lt; self.traversals.count():
                    view = self.traversals.view()
                    view.setRowHidden(index, False)
                    model = self.traversals.model()
                    item = model.item(index)
                    item.setFlags(item.flags() | Qt.ItemIsEnabled)
            self.traversals.setCurrentIndex(0)
        else:
            for index in self.loops_indices_m:
                if index &lt; self.traversals.count():
                    view = self.traversals.view()
                    view.setRowHidden(index, True)
                    model = self.traversals.model()
                    item = model.item(index)
                    item.setFlags(item.flags() &amp; ~Qt.ItemIsEnabled)
            curIndex = 0
            for i in range (0, len(self.found_traversals)):
                if curIndex not in self.loops_indices_m:
                    break
                else:
                    curIndex += 1
            self.traversals.setCurrentIndex(curIndex)

    
    def endless_loop_picked(self, combobox: QtWidgets.QComboBox):
        &#34;&#34;&#34;Is called when an element of combobox containing found paths is picked in single soliton widget. Disables &#34;show matrices&#34;
        and &#34;show end result&#34; buttons if &#34;loop path&#34; is picked/ enables them again if valid soliton path is picked.

        Args:
            combobox (QtWidgets.QComboBox): Contains all found soliton paths and &#34;loop paths&#34;.
        &#34;&#34;&#34;
        if not isinstance(self.found_paths[combobox.currentIndex()], SolitonPath): # disable
            try:
                self.show_matrices.clicked.disconnect()
                self.show_matrices.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
                self.show_end_result.clicked.disconnect()
                self.show_end_result.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
            except:
                pass
        else: # enable
            try:
                self.show_matrices.clicked.disconnect()
                self.show_matrices.clicked.connect(self.show_matrices_clicked)
                self.show_matrices.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
                self.show_end_result.clicked.disconnect()
                self.show_end_result.clicked.connect(self.show_end_result_clicked)
                self.show_end_result.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
            except:
                self.show_matrices.clicked.connect(self.show_matrices_clicked)
                self.show_matrices.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
                self.show_end_result.clicked.connect(self.show_end_result_clicked)
                self.show_end_result.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)


    def endless_loop_picked_m(self, combobox: QtWidgets.QComboBox):
        &#34;&#34;&#34;Is called when an element of combobox containing found traversals is picked in multi soliton widget. Disables &#34;show matrices&#34;
        and &#34;show end result&#34; buttons if &#34;loop traversal&#34; is picked/ enables them again if traversal is picked.

        Args:
            combobox (QtWidgets.QComboBox): Contains all found traversals and &#34;loop traversals&#34;.
        &#34;&#34;&#34;
        if not isinstance(self.found_traversals[combobox.currentIndex()], Traversal):
            try:
                self.show_matrices_m.clicked.disconnect()
                self.show_matrices_m.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
                self.show_end_result_m.clicked.disconnect()
                self.show_end_result_m.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
            except:
                pass
        else:
            try:
                self.show_matrices_m.clicked.disconnect()
                self.show_matrices_m.clicked.connect(self.show_matrices_clicked_m)
                self.show_matrices_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
                self.show_end_result_m.clicked.disconnect()
                self.show_end_result_m.clicked.connect(self.show_end_result_clicked_m)
                self.show_end_result_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            except:
                self.show_matrices_m.clicked.connect(self.show_matrices_clicked_m)
                self.show_matrices_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
                self.show_end_result_m.clicked.connect(self.show_end_result_clicked_m)
                self.show_end_result_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)


    def show_matrices_clicked(self):
        &#34;&#34;&#34;Is called when user clicks button to have the adjacency matrices of every timestep in single soliton widget displayed.
        Makes a small window pop up that shows the labelled adjacency matrices and provides a save button.
        &#34;&#34;&#34;

        def save_matrices():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where a text file with all adjacency matrices should be saved.
            Text file also contains the input string representing the molecule and the soliton path.
            Only allows `.txt` file suffix.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.wid_single, &#39;Save File&#39;, &#39;matrices.txt&#39;, &#39;Text files (*.txt)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;): # only do the following if user clicked on save button (without this line the application closes with an error if save action is cancelled)
                path = name[0]
                file = open(path, &#34;w&#34;)
                file.write(txt_text)
                file.close()

        index = self.paths.currentIndex()
        desired_path = self.found_paths[index]

        dlg = QDialog(self.wid_single)
        scrollArea = QScrollArea(dlg)
        scrollArea.setStyleSheet(&#34;font: 13pt Courier;&#34;)
        widget = QtWidgets.QWidget()
        vbox = QtWidgets.QVBoxLayout()
        if re.search(&#39;,&#39;, self.my_graph.way) is not None:
            txt_text = f&#34;Way to soliton graph: {self.my_graph.way} \n&#34;
        else:
            txt_text = f&#34;Soliton graph: {self.my_graph.way} \n&#34;
        txt_text = txt_text + f&#34;Soliton path: {desired_path.path_for_user} \n \n&#34;
        # labelling of matrix depends on wether we have long node labels (&#34;aa&#34;, &#34;ab&#34;, ...) or short ones (&#34;a&#34;, &#34;b&#34;, ...)
        if (len(self.my_graph.labels) - len(self.my_graph.exterior_nodes)) &gt; 26:
            matrix_label_horizontal = &#34;    &#34;
            long_labels = True
        else:
            matrix_label_horizontal = &#34;   &#34;
            long_labels = False
        for key in self.my_graph.labels:
            if long_labels:
                if self.my_graph.labels[key] in self.my_graph.exterior_nodes_reverse and int(self.my_graph.labels[key]) &lt; 10:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]}  &#34;
                else:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]} &#34;
            else:
                if self.my_graph.labels[key] in self.my_graph.exterior_nodes_reverse and int(self.my_graph.labels[key]) &gt;= 10:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]} &#34;
                else:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]}  &#34;
        # for show-matrices-window the node labels are added to the matrix string and this labelled matrix is added to scroll area
        # for matrices.txt we add everything (horizontal label and every row of matrix) line by line
        for i in range(len(desired_path.adjacency_matrices_list)):
            txt_text = txt_text + f&#34;Timestep {i}: \n&#34;
            txt_text = txt_text + f&#34;{matrix_label_horizontal} \n&#34;
            matrix_labelled = &#34;&#34;
            matrix_labelled = matrix_labelled + f&#34;{matrix_label_horizontal}\n&#34;
            matrix = str(desired_path.adjacency_matrices_list[i])
            matrix = re.sub(r&#34;[matrix(]&#34;, &#34;&#34;, matrix)
            matrix = re.sub(r&#34;[)]&#34;, &#34;&#34;, matrix)
            for j in range(len(matrix.splitlines())):
                if long_labels:
                    if self.my_graph.labels[j] in self.my_graph.exterior_nodes_reverse and int(self.my_graph.labels[j]) &lt; 10:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]} {matrix.splitlines()[j]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph.labels[j]} {matrix.splitlines()[j]} \n&#34;
                    else:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
                else:
                    if self.my_graph.labels[j] in self.my_graph.exterior_nodes_reverse and int(self.my_graph.labels[j]) &gt;= 10:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j][1:]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j][1:]} \n&#34;
                    else:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
            txt_text = txt_text + f&#34;\n&#34;
            vbox.addWidget(QtWidgets.QLabel(matrix_labelled))
        widget.setLayout(vbox)
        scrollArea.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        scrollArea.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        scrollArea.setWidgetResizable(True)
        scrollArea.setWidget(widget)
        scrollArea.setFixedSize(540, 405)
        save_button = QtWidgets.QPushButton(dlg)
        save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
        save_button.setGeometry(QtCore.QRect(454, 359, 70, 30))
        save_button.clicked.connect(save_matrices)

        dlg.setWindowTitle(&#34;Adjacency Matrices&#34;)
        dlg.setFixedSize(545, 410)
        dlg.exec_()


    def show_matrices_clicked_m(self):
        &#34;&#34;&#34;Is called when user clicks button to have the adjacency matrices of every timestep in multi soliton widget displayed.
        Makes a small window pop up that shows the labelled adjacency matrices and provides a save button.
        &#34;&#34;&#34;

        def save_matrices():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where a text file with all adjacency matrices should be saved.
            Text file also contains the input string representing the molecule and the soliton path.
            Only allows `.txt` file suffix.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.wid_mult, &#39;Save File&#39;, &#39;matrices.txt&#39;, &#39;Text files (*.txt)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;): # only do the following if user clicked on save button (without this line the application closes with an error if save action is cancelled)
                path = name[0]
                file = open(path, &#34;w&#34;)
                file.write(txt_text)
                file.close()

        index = self.traversals.currentIndex()
        desired_traversal = self.found_traversals[index]

        dlg = QDialog(self.wid_mult)
        scrollArea = QScrollArea(dlg)
        scrollArea.setStyleSheet(&#34;font: 13pt Courier;&#34;)
        widget = QtWidgets.QWidget()
        vbox = QtWidgets.QVBoxLayout()
        if re.search(&#39;,&#39;, self.my_graph_m.way) is not None:
            txt_text = f&#34;Way to soliton graph: {self.my_graph_m.way} \n&#34;
        else:
            txt_text = f&#34;Soliton graph: {self.my_graph_m.way} \n&#34;
        txt_text = txt_text + f&#34;Set of bursts: {self.bursts} \n&#34;
        this_traversal = &#34;&#34;
        for i, path in enumerate(desired_traversal.traversal_for_user):
            this_traversal = this_traversal + path
            if i != len(desired_traversal.traversal_for_user)-1:
                this_traversal = this_traversal + &#34;, &#34;
        txt_text = txt_text + f&#34;Traversal: {this_traversal} \n \n&#34;
        if (len(self.my_graph_m.labels) - len(self.my_graph_m.exterior_nodes)) &gt; 26:
            matrix_label_horizontal = &#34;    &#34;
            long_labels = True
        else:
            matrix_label_horizontal = &#34;   &#34;
            long_labels = False
        for key in self.my_graph_m.labels:
            if long_labels:
                if self.my_graph_m.labels[key] in self.my_graph_m.exterior_nodes_reverse and int(self.my_graph_m.labels[key]) &lt; 10:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph_m.labels[key]}  &#34;
                else:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph_m.labels[key]} &#34;
            else:
                if self.my_graph_m.labels[key] in self.my_graph_m.exterior_nodes_reverse and int(self.my_graph_m.labels[key]) &gt;= 10:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph_m.labels[key]} &#34;
                else:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph_m.labels[key]}  &#34;
        for i in range(len(desired_traversal.adjacency_matrices_list)):
            txt_text = txt_text + f&#34;Timestep {i}: \n&#34;
            txt_text = txt_text + f&#34;{matrix_label_horizontal} \n&#34;
            matrix_labelled = &#34;&#34;
            matrix_labelled = matrix_labelled + f&#34;{matrix_label_horizontal}\n&#34;
            matrix = str(desired_traversal.adjacency_matrices_list[i])
            matrix = re.sub(r&#34;[matrix(]&#34;, &#34;&#34;, matrix)
            matrix = re.sub(r&#34;[)]&#34;, &#34;&#34;, matrix)
            for j in range(len(matrix.splitlines())):
                if long_labels:
                    if self.my_graph_m.labels[j] in self.my_graph_m.exterior_nodes_reverse and int(self.my_graph_m.labels[j]) &lt; 10:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph_m.labels[j]} {matrix.splitlines()[j]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph_m.labels[j]} {matrix.splitlines()[j]} \n&#34;
                    else:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j]} \n&#34;
                else:
                    if self.my_graph_m.labels[j] in self.my_graph_m.exterior_nodes_reverse and int(self.my_graph_m.labels[j]) &gt;= 10:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j][1:]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j][1:]} \n&#34;
                    else:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j]} \n&#34;
            txt_text = txt_text + f&#34;\n&#34;
            vbox.addWidget(QtWidgets.QLabel(matrix_labelled))
        widget.setLayout(vbox)
        scrollArea.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        scrollArea.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        scrollArea.setWidgetResizable(True)
        scrollArea.setWidget(widget)
        scrollArea.setFixedSize(540, 405)
        save_button = QtWidgets.QPushButton(dlg)
        save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
        save_button.setGeometry(QtCore.QRect(454, 359, 70, 30))
        save_button.clicked.connect(save_matrices)

        dlg.setWindowTitle(&#34;Adjacency Matrices&#34;)
        dlg.setFixedSize(545, 410)
        dlg.exec_()
    

    def show_end_result_clicked(self):
        &#34;&#34;&#34;Is called when user clicks button to have the resulting graph (after soliton path is traversed) in single soliton widget displayed.
        Makes a small window pop up that shows the graph visualisation and provides a save button.
        &#34;&#34;&#34;

        def save_end_result():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where the resulting graph should be saved.
            Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.wid_single, &#39;Save File&#39;, &#39;result.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;):
                path = name[0]
                imgByteArr = io.BytesIO()
                result_pic.save(imgByteArr, format=&#39;PNG&#39;)
                imgByteArr = imgByteArr.getvalue()
                file = open(path, &#34;wb&#34;)
                file.write(imgByteArr)
                file.close()

        def use_as_new_soliton_graph(dlg: QDialog):
            &#34;&#34;&#34;Uses the end result of the selected path as the new soliton graph. Puts the software in traversal mode.

            Args:
                dlg (QDialog): The dialog window that shows the end result.
            &#34;&#34;&#34;
            current_way = self.my_graph.way
            new_soliton_graph = copy.deepcopy(self.desired_path.resulting_soliton_graph)
            self.my_graph = new_soliton_graph
            self.my_graph.way = f&#34;{current_way}, {self.desired_path.path_for_user}&#34;
            self.graph_pic = Visualisation.visualize_soliton_graph(self.my_graph, self.my_graph.bindings, False, True)
            self.qim = ImageQt(self.graph_pic)
            self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(self.display_molecule.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))

            self.traversal_mode.setChecked(True)
            self.hide_multiple([self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
            self.node_1.setCurrentIndex(0)
            self.node_2.setCurrentIndex(0)
            dlg.close()

        index = self.paths.currentIndex()
        self.desired_path = self.found_paths[index]
        bindings_index = len(self.desired_path.path) - 1
        result_pic = Visualisation.visualize_soliton_graph(self.my_graph, self.desired_path.bindings_list[bindings_index], False, True)
        qim = ImageQt(result_pic)

        dlg = QDialog(self.wid_single)
        label = QtWidgets.QLabel(dlg)
        label.setGeometry(QtCore.QRect(0, 0, 540, 405))
        label.setPixmap(QtGui.QPixmap.fromImage(qim))
        label.setScaledContents(True)
        save_button = QtWidgets.QPushButton(dlg)
        save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
        save_button.setGeometry(QtCore.QRect(470, 375, 70, 30))
        save_button.clicked.connect(save_end_result)
        use_button = QtWidgets.QPushButton(&#34;Use&#34;, dlg)
        use_button.clicked.connect(lambda: use_as_new_soliton_graph(dlg))
        use_button.setGeometry(QtCore.QRect(395, 375, 70, 30))

        dlg.setWindowTitle(&#34;End result&#34;)
        dlg.setFixedSize(545, 410)
        dlg.exec_()

    
    def show_end_result_clicked_m(self):
        &#34;&#34;&#34;Is called when user clicks button to have the resulting graph (after soliton path is traversed) in multi soliton widget displayed.
        Makes a small window pop up that shows the graph visualisation and provides a save button.
        &#34;&#34;&#34;

        def save_end_result():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where the resulting graph should be saved.
            Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.wid_mult, &#39;Save File&#39;, &#39;result.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;):
                path = name[0]
                imgByteArr = io.BytesIO()
                result_pic.save(imgByteArr, format=&#39;PNG&#39;)
                imgByteArr = imgByteArr.getvalue()
                file = open(path, &#34;wb&#34;)
                file.write(imgByteArr)
                file.close()

        def use_as_new_soliton_graph(dlg: QDialog):
            &#34;&#34;&#34;Uses the end result of the selected path as the new soliton graph. Puts the software in traversal mode.

            Args:
                dlg (QDialog): The dialog window that shows the end result.
            &#34;&#34;&#34;
            current_way = self.my_graph_m.way
            new_soliton_graph = copy.deepcopy(self.desired_traversal.resulting_soliton_graph)
            self.my_graph_m = new_soliton_graph
            self.my_graph_m.way = f&#34;{current_way}, {self.desired_traversal.traversal_for_user}&#34;
            self.graph_pic = Visualisation.visualize_soliton_graph(self.my_graph_m, self.my_graph_m.bindings, False, True)
            self.qim_m = ImageQt(self.graph_pic)
            self.display_molecule_m.setPixmap(QtGui.QPixmap.fromImage(self.qim_m).scaled(self.display_molecule_m.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))

            self.traversal_mode_m.setChecked(True)
            self.hide_multiple([self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
            self.burst.setCurrentIndex(0)
            dlg.close()

        index = self.traversals.currentIndex()
        self.desired_traversal = self.found_traversals[index]
        result_pic = Visualisation.visualize_soliton_graph(self.desired_traversal.resulting_soliton_graph, self.desired_traversal.resulting_soliton_graph.bindings, False, True)
        qim = ImageQt(result_pic)

        dlg = QDialog(self.wid_mult)
        label = QtWidgets.QLabel(dlg)
        label.setGeometry(QtCore.QRect(0, 0, 540, 405))
        label.setPixmap(QtGui.QPixmap.fromImage(qim))
        label.setScaledContents(True)
        save_button = QtWidgets.QPushButton(dlg)
        save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
        save_button.setGeometry(QtCore.QRect(470, 375, 70, 30))
        save_button.clicked.connect(save_end_result)
        use_button = QtWidgets.QPushButton(&#34;Use&#34;, dlg)
        use_button.clicked.connect(lambda: use_as_new_soliton_graph(dlg))
        use_button.setGeometry(QtCore.QRect(395, 375, 70, 30))

        dlg.setWindowTitle(&#34;End result&#34;)
        dlg.setFixedSize(545, 410)
        dlg.exec_()


    def show_animation_clicked(self, button: QtWidgets.QPushButton):
        &#34;&#34;&#34;Is called when user clicks button to have the animation of the soliton traversing the graph displayed.
        Makes a small window pop up that shows the animation and provides a &#34;pause&#34;/ &#34;play&#34; button, a &#34;back&#34; and a &#34;forward&#34; button and a save button.
        Instead of displaying the `gif` it uses a sequence of `PIL` images and always shows the next image after a certain time.
        Calls different animation functions depending on whether application is in single or multi soliton widget.
        If a &#34;loop path&#34;/ &#34;loop traversal&#34; was chosen, save button is disabled and animation loops after loop point is reached.

        Args:
            button (QtWidgets.QPushButton): Button that called the function (either button in single or in multi soliton widget).
        &#34;&#34;&#34;

        def save_animation():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where the animation should be saved.
            Only allows `.gif` file suffix.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(wid, &#39;Save File&#39;, &#39;animation.gif&#39;, &#39;Images (*.gif)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;):
                path = name[0]
                if button == self.show_animation: # single soliton animation
                    ani = Animation.graph_animation(self.my_graph, self.desired_path)
                else: ani = Animation.graph_animation_multiwave(self.my_graph_m, self.desired_traversal) # multi soliton animation
                ani.save(path, writer=&#39;pillow&#39;, dpi = 600)

        def update_image():
            &#34;&#34;&#34;Displays next image of animation.
            &#34;&#34;&#34;
            self.step += 1
            if button == self.show_animation:
                if isinstance(self.desired_path, SolitonPath):
                    if self.step == len(self.desired_path.path): # start animation all over again as soon as end is reached (endless loop)
                        self.step = 0
                else:
                    if self.step == len(self.desired_path[0].path):
                        self.over_looppoint_count += 1 # another &#34;round&#34; of loop made
                        self.step = self.desired_path[1] # we reached the &#34;end&#34; (which in reality is the point where we noticed we are stuck in a loop) so we have to continue at the loop point now
            else:
                if isinstance(self.desired_traversal, Traversal):
                    if self.step == len(self.desired_traversal.pos):
                        self.step = 0
                else:
                    if self.step == len(self.desired_traversal[0].pos):
                        self.over_looppoint_count += 1
                        self.step = self.desired_traversal[1]
            im = self.pil_images[self.step]
            qim = ImageQt(im)
            self.label.setPixmap(QtGui.QPixmap.fromImage(qim.copy()))
            self.label.setScaledContents(True)

        def update_image_reverse():
            &#34;&#34;&#34;Displays previous image of animation.
            &#34;&#34;&#34;
            self.step -= 1
            if button == self.show_animation:
                if isinstance(self.desired_path, SolitonPath):
                    if self.step == -1: # if start of animation was reached in the step before then continue at end of animation
                        self.step = len(self.desired_path.path) - 1
                else:
                    if self.step == -1:
                        self.step = 0 # we can&#39;t go back to the end of the animation because it has no end, instead we stay at the beginning
                    elif self.step == self.desired_path[1] - 1 and self.over_looppoint_count != 0: # before we go back to before the loop point we have to dismantle all &#34;rounds&#34; of loop that we made
                        self.step = len(self.desired_path[0].path) - 1 # continue again at the &#34;end&#34;
                        self.over_looppoint_count -= 1 # dismantle
            else:
                if isinstance(self.desired_traversal, Traversal):
                    if self.step == -1:
                        self.step = len(self.desired_traversal.pos) - 1
                else:
                    if self.step == -1:
                        self.step = 0 
                    elif self.step == self.desired_traversal[1] - 1 and self.over_looppoint_count != 0:
                        self.step = len(self.desired_traversal[0].pos) - 1
                        self.over_looppoint_count -= 1
            im = self.pil_images[self.step]
            qim = ImageQt(im)
            self.label.setPixmap(QtGui.QPixmap.fromImage(qim.copy()))
            self.label.setScaledContents(True)
            
        def pause_animation(button: QtWidgets.QPushButton):
            &#34;&#34;&#34;Is called when &#34;pause&#34;/ &#34;play&#34; button is pressed.
            Pauses/ plays animation by stopping the timer/ starting the timer.

            Args:
                button (QtWidgets.QPushButton): Button that called the function (either button in single or in multi soliton widget).
            &#34;&#34;&#34;
            if self.timer.isActive(): # pause
                self.timer.stop()
                if button.parentWidget().parentWidget() == self.wid_single:
                    button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
                else: button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            else: # play
                update_image()
                self.timer.start(800)
                if button.parentWidget().parentWidget() == self.wid_single:
                    button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/pause.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
                else: button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/pause.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)

        def next_img(button: QtWidgets.QPushButton):
            &#34;&#34;&#34;Is called when &#34;forward&#34; button is pressed.
            Stops the timer if it is still active and calls `update_image` function.

            Args:
                button (QtWidgets.QPushButton): Button that called the function (either button in single or in multi soliton widget).
            &#34;&#34;&#34;
            if self.timer.isActive():
                self.timer.stop()
                if button.parentWidget().parentWidget() == self.wid_single:
                    button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
                else: button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            update_image()

        def prev_img(button: QtWidgets.QPushButton):
            &#34;&#34;&#34;Is called when &#34;back&#34; button is pressed.
            Stops the timer if it is still active and calls `update_image_reverse` function.

            Args:
                button (QtWidgets.QPushButton): Button that called the function (either button in single or in multi soliton widget).
            &#34;&#34;&#34;
            if self.timer.isActive():
                self.timer.stop()
                if button.parentWidget().parentWidget() == self.wid_single:
                    button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
                else: button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            update_image_reverse()
            
        if button == self.show_animation:
            dlg = QDialog(self.wid_single)
        else: dlg = QDialog(self.wid_mult)
        self.label = QtWidgets.QLabel(dlg)
        self.label.setGeometry(QtCore.QRect(0, 0, 540, 405))
        
        if button == self.show_animation:
            wid = self.wid_single
        else:
            wid = self.wid_mult
        
        if button == self.show_animation:
            if self.path_index != self.paths.currentIndex():
                self.path_index = self.paths.currentIndex()
                self.desired_path = self.found_paths[self.path_index]
                if isinstance(self.desired_path, SolitonPath): # soliton path
                    plots_and_arrays = Animation.list_of_plots_and_arrays(self.my_graph, self.desired_path)
                else: # &#34;loop path&#34;
                    plots_and_arrays = Animation.list_of_plots_and_arrays(self.my_graph, self.desired_path[0])
                self.pil_images = Animation.list_of_pil_images(plots_and_arrays)
        else:
            if self.traversal_index != self.traversals.currentIndex():
                self.traversal_index = self.traversals.currentIndex()
                self.desired_traversal = self.found_traversals[self.traversal_index]
                if isinstance(self.desired_traversal, Traversal):
                    plots_and_arrays = Animation.list_of_plots_and_arrays_multiwave(self.my_graph_m, self.desired_traversal)
                else: 
                    plots_and_arrays = Animation.list_of_plots_and_arrays_multiwave(self.my_graph_m, self.desired_traversal[0])
                self.pil_images = Animation.list_of_pil_images(plots_and_arrays)

        save_button = QtWidgets.QPushButton(dlg)
        save_button.setGeometry(QtCore.QRect(470, 375, 70, 30))
        pause_button = QtWidgets.QPushButton(dlg)
        pause_button.setGeometry(QtCore.QRect(240, 375, 30, 30))
        pause_button.clicked.connect(lambda: pause_animation(pause_button))
        next_button = QtWidgets.QPushButton(dlg)
        next_button.setGeometry(QtCore.QRect(275, 375, 30, 30))
        next_button.clicked.connect(lambda: next_img(pause_button))
        prev_button = QtWidgets.QPushButton(dlg)
        prev_button.setGeometry(QtCore.QRect(205, 375, 30, 30))
        prev_button.clicked.connect(lambda: prev_img(pause_button))
        if button == self.show_animation:
            if isinstance(self.desired_path, SolitonPath):
                save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
                save_button.clicked.connect(save_animation)
            else:
                self.over_looppoint_count = 0 # how many times we passed the loop point
                save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230); image: url(:/icons/save.svg);}&#34;)
            pause_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/pause.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
            next_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/right-arrow.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
            prev_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/left-arrow.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193)}&#34;)
        else:
            if isinstance(self.desired_traversal, Traversal):
                save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
                save_button.clicked.connect(save_animation)
            else:
                self.over_looppoint_count = 0
                save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230); image: url(:/icons/save.svg);}&#34;)
            pause_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/pause.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            next_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/right-arrow.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            prev_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/left-arrow.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123)}&#34;)

        self.step = -1
        self.timer = QtCore.QTimer(self)
        self.timer.timeout.connect(update_image) # timer calls `update_image` everytime event is triggered
        update_image()
        self.timer.start(800) # triggers event every 800 millisecond

        dlg.setWindowTitle(&#34;Animation&#34;)
        dlg.setFixedSize(545, 410)
        dlg.closeEvent = self.stop_animation # stop timer when window is closed
        dlg.exec_()


    def stop_animation(self, event):
        &#34;&#34;&#34;Stops the timer that is used for the animation.
        Without this method the application would crash if the animation window would get closed.
        Args:
            event: Close event of the window that shows animation.
        &#34;&#34;&#34;
        self.timer.disconnect()


    def hide_retain_space(self, widgets: list):
        &#34;&#34;&#34;Retains the space of a widget even when it&#39;s hidden.

        Args:
            widget (QtWidgets.QWidget ): Widget whose space should be retained.
        &#34;&#34;&#34;
        for widget in widgets:
            retain = widget.sizePolicy()
            retain.setRetainSizeWhenHidden(True)
            widget.setSizePolicy(retain)


    def hide_multiple(self, widgets: list):
        &#34;&#34;&#34;Hides multiple widgets at once, makes code a lot shorter because it unites several calls of the same function.

        Args:
            widgets (list): Widgets who should be hidden.
        &#34;&#34;&#34;
        for widget in widgets:
            widget.hide()


    def show_multiple(self, widgets: list):
        &#34;&#34;&#34;Shows multiple widgets at once, makes code a lot shorter because it unites several calls of the same function.

        Args:
            widgets (list): Widgets who should be showed.
        &#34;&#34;&#34;
        for widget in widgets:
            widget.show()


    def heightForWidth(self, width: float):
        &#34;&#34;&#34;Computes height for a given width.

        Args:
            width (float): Given width.

        Returns:
            float: Computed height.
        &#34;&#34;&#34;
        height_for_width_factor = 1.0 * 519 / 688
        return math.ceil(width * height_for_width_factor)


    def widthForHeight(self, height):
        &#34;&#34;&#34;Computes width for a given height.

        Args:
            height (float): Given height.

        Returns:
            float: Computed width.
        &#34;&#34;&#34;
        width_for_height_factor = 1.0 * 688 / 519
        return math.ceil(height * width_for_height_factor)


    def resizeEvent(self, event: QtGui.QResizeEvent):
        &#34;&#34;&#34;Keeps the right aspect ratio of the graph visualisation image (or welcoming screen in the beginning) when window is resized.

        Args:
            event (QtGui.QResizeEvent): Resize event.
        &#34;&#34;&#34;
        super(MainWindow, self).resizeEvent(event)
        size = event.size()
        # window height minus height of all widgets below the label result in height of pixmap
        height = size.height() - self.save.height() - self.submit_molecule.height() - self.submit_exterior_nodes.height() - self.paths.height() - self.show_animation.height()
        if self.widthForHeight(height) &gt; size.width(): # pixmap width should be as most as big as width of whole window
            width = size.width()
        else:
            width = self.widthForHeight(height)
        self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(width, height, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
        self.display_molecule_m.setPixmap(QtGui.QPixmap.fromImage(self.qim_m).scaled(width, height, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.all_bursts_statechanged"><code class="name flex">
<span>def <span class="ident">all_bursts_statechanged</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when "All" checkbox in multi soliton widget is checked/ unchecked.
Hides/ unhides widgets to choose a burst.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_bursts_statechanged(self):
    &#34;&#34;&#34;Is called when &#34;All&#34; checkbox in multi soliton widget is checked/ unchecked.
    Hides/ unhides widgets to choose a burst.
    &#34;&#34;&#34;
    if self.all_bursts.isChecked():
        self.burst.hide()
    else: self.burst.show()</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.all_exterior_nodes_statechanged"><code class="name flex">
<span>def <span class="ident">all_exterior_nodes_statechanged</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when "All" checkbox in single soliton widget is checked/ unchecked.
Hides/ unhides widgets to choose a pair of exterior nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_exterior_nodes_statechanged(self):
    &#34;&#34;&#34;Is called when &#34;All&#34; checkbox in single soliton widget is checked/ unchecked.
    Hides/ unhides widgets to choose a pair of exterior nodes.
    &#34;&#34;&#34;
    if self.all_exterior_nodes.isChecked():
        self.hide_multiple([self.node_1, self.exterior_nodes_label2, self.node_2])
    else: self.show_multiple([self.node_1, self.exterior_nodes_label2, self.node_2])</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.change_mode"><code class="name flex">
<span>def <span class="ident">change_mode</span></span>(<span>self, checkbox:PyQt5.QtWidgets.QCheckBox)</span>
</code></dt>
<dd>
<div class="desc"><p>Realizes the change between being in traversal mode and not being in traversal mode in single soliton widget.
In traversal mode, a soliton automata can be traversed by using an end result as the new soliton graph.
When in traversal mode, the input molecule and stop number can't be edited.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>checkbox</code></strong> :&ensp;<code>QtWidgets.QCheckBox</code></dt>
<dd>The checkbox that changes the mode.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_mode(self, checkbox: QtWidgets.QCheckBox):
    &#34;&#34;&#34;Realizes the change between being in traversal mode and not being in traversal mode in single soliton widget.
    In traversal mode, a soliton automata can be traversed by using an end result as the new soliton graph.
    When in traversal mode, the input molecule and stop number can&#39;t be edited.

    Args:
        checkbox (QtWidgets.QCheckBox): The checkbox that changes the mode.
    &#34;&#34;&#34;
    if checkbox.isChecked() == True:
        # make text field uneditable and button unclickable, turn both objects grey to make those properties visually recognizable
        self.submit_molecule.clicked.disconnect()
        self.submit_molecule.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
        self.molecule_lineedit.setReadOnly(True)
        self.molecule_lineedit.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(230, 230, 230);border-radius: 10px;padding: 0 8px;}&#34;)
        self.molecule_label.setText(&#34;Original molecule:&#34;)
        self.stop_number_spinbox.setReadOnly(True)
        self.stop_number_spinbox.setStyleSheet(&#34;QSpinBox {border: 1px solid rgb(230, 230, 230);border-radius: 10px;padding-right: 15px;}&#34;)
    else:
        self.submit_molecule.clicked.connect(self.submit_molecule_clicked)
        self.submit_molecule.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
        self.molecule_lineedit.setReadOnly(False)
        self.molecule_lineedit.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(191, 207, 255);border-radius: 10px;padding: 0 8px;}&#34;)
        self.molecule_label.setText(&#34;Molecule:&#34;)
        self.submit_molecule_clicked()
        self.stop_number_spinbox.setReadOnly(False)
        self.stop_number_spinbox.setStyleSheet(&#34;QSpinBox {border: 1px solid rgb(191, 207, 255);border-radius: 10px;padding-right: 15px;}&#34;)</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.change_mode_m"><code class="name flex">
<span>def <span class="ident">change_mode_m</span></span>(<span>self, checkbox:PyQt5.QtWidgets.QCheckBox)</span>
</code></dt>
<dd>
<div class="desc"><p>Realizes the change between being in traversal mode and not being in traversal mode in multi soliton widget.
In traversal mode, a soliton automata can be traversed by using an end result as the new soliton graph.
When in traversal mode, the input molecule can't be edited.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>checkbox</code></strong> :&ensp;<code>QtWidgets.QCheckBox</code></dt>
<dd>The checkbox that changes the mode.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_mode_m(self, checkbox: QtWidgets.QCheckBox):
    &#34;&#34;&#34;Realizes the change between being in traversal mode and not being in traversal mode in multi soliton widget.
    In traversal mode, a soliton automata can be traversed by using an end result as the new soliton graph.
    When in traversal mode, the input molecule can&#39;t be edited.

    Args:
        checkbox (QtWidgets.QCheckBox): The checkbox that changes the mode.
    &#34;&#34;&#34;
    if checkbox.isChecked() == True:
        # make text field uneditable and button unclickable, turn both objects grey to make those properties visually recognizable
        self.submit_molecule_m.clicked.disconnect()
        self.submit_molecule_m.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
        self.molecule_lineedit_m.setReadOnly(True)
        self.molecule_lineedit_m.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(230, 230, 230);border-radius: 10px;padding: 0 8px;}&#34;)
        self.molecule_label_m.setText(&#34;Original molecule:&#34;)
        self.submit_set_of_bursts.clicked.disconnect()
        self.submit_set_of_bursts.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
        self.set_of_bursts_lineedit.setReadOnly(True)
        self.set_of_bursts_lineedit.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(230, 230, 230);border-radius: 10px;padding: 0 8px;}&#34;)
        self.stop_number_spinbox_m.setReadOnly(True)
        self.stop_number_spinbox_m.setStyleSheet(&#34;QSpinBox {border: 1px solid rgb(230, 230, 230);border-radius: 10px;padding-right: 15px;}&#34;)
    else:
        self.submit_molecule_m.clicked.connect(self.submit_molecule_clicked_m)
        self.submit_molecule_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
        self.molecule_lineedit_m.setReadOnly(False)
        self.molecule_lineedit_m.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(149, 221, 185);border-radius: 10px;padding: 0 8px;}&#34;)
        self.molecule_label_m.setText(&#34;Molecule:&#34;)
        self.submit_molecule_clicked_m()
        self.submit_set_of_bursts.clicked.connect(self.submit_set_of_bursts_clicked)
        self.submit_set_of_bursts.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
        self.set_of_bursts_lineedit.setReadOnly(False)
        self.set_of_bursts_lineedit.setStyleSheet(&#34;QLineEdit {border: 2px solid rgb(149, 221, 185);border-radius: 10px;padding: 0 8px;}&#34;)
        self.stop_number_spinbox_m.setReadOnly(False)
        self.stop_number_spinbox_m.setStyleSheet(&#34;QSpinBox {border: 1px solid rgb(149, 221, 185);border-radius: 10px;padding-right: 15px;}&#34;)</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.change_window"><code class="name flex">
<span>def <span class="ident">change_window</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when "Change Mode" button is clicked. Changes between the two widgets of the stacked layout.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_window(self):
    &#34;&#34;&#34;Is called when &#34;Change Mode&#34; button is clicked. Changes between the two widgets of the stacked layout.
    &#34;&#34;&#34;
    if self.front_wid == 1:
        self.layout_for_wids.setCurrentIndex(1)
        self.front_wid = 2
    else:
        self.layout_for_wids.setCurrentIndex(0)
        self.front_wid = 1</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.endless_loop_picked"><code class="name flex">
<span>def <span class="ident">endless_loop_picked</span></span>(<span>self, combobox:PyQt5.QtWidgets.QComboBox)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when an element of combobox containing found paths is picked in single soliton widget. Disables "show matrices"
and "show end result" buttons if "loop path" is picked/ enables them again if valid soliton path is picked.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>combobox</code></strong> :&ensp;<code>QtWidgets.QComboBox</code></dt>
<dd>Contains all found soliton paths and "loop paths".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def endless_loop_picked(self, combobox: QtWidgets.QComboBox):
    &#34;&#34;&#34;Is called when an element of combobox containing found paths is picked in single soliton widget. Disables &#34;show matrices&#34;
    and &#34;show end result&#34; buttons if &#34;loop path&#34; is picked/ enables them again if valid soliton path is picked.

    Args:
        combobox (QtWidgets.QComboBox): Contains all found soliton paths and &#34;loop paths&#34;.
    &#34;&#34;&#34;
    if not isinstance(self.found_paths[combobox.currentIndex()], SolitonPath): # disable
        try:
            self.show_matrices.clicked.disconnect()
            self.show_matrices.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
            self.show_end_result.clicked.disconnect()
            self.show_end_result.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
        except:
            pass
    else: # enable
        try:
            self.show_matrices.clicked.disconnect()
            self.show_matrices.clicked.connect(self.show_matrices_clicked)
            self.show_matrices.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
            self.show_end_result.clicked.disconnect()
            self.show_end_result.clicked.connect(self.show_end_result_clicked)
            self.show_end_result.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
        except:
            self.show_matrices.clicked.connect(self.show_matrices_clicked)
            self.show_matrices.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
            self.show_end_result.clicked.connect(self.show_end_result_clicked)
            self.show_end_result.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.endless_loop_picked_m"><code class="name flex">
<span>def <span class="ident">endless_loop_picked_m</span></span>(<span>self, combobox:PyQt5.QtWidgets.QComboBox)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when an element of combobox containing found traversals is picked in multi soliton widget. Disables "show matrices"
and "show end result" buttons if "loop traversal" is picked/ enables them again if traversal is picked.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>combobox</code></strong> :&ensp;<code>QtWidgets.QComboBox</code></dt>
<dd>Contains all found traversals and "loop traversals".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def endless_loop_picked_m(self, combobox: QtWidgets.QComboBox):
    &#34;&#34;&#34;Is called when an element of combobox containing found traversals is picked in multi soliton widget. Disables &#34;show matrices&#34;
    and &#34;show end result&#34; buttons if &#34;loop traversal&#34; is picked/ enables them again if traversal is picked.

    Args:
        combobox (QtWidgets.QComboBox): Contains all found traversals and &#34;loop traversals&#34;.
    &#34;&#34;&#34;
    if not isinstance(self.found_traversals[combobox.currentIndex()], Traversal):
        try:
            self.show_matrices_m.clicked.disconnect()
            self.show_matrices_m.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
            self.show_end_result_m.clicked.disconnect()
            self.show_end_result_m.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230);}&#34;)
        except:
            pass
    else:
        try:
            self.show_matrices_m.clicked.disconnect()
            self.show_matrices_m.clicked.connect(self.show_matrices_clicked_m)
            self.show_matrices_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            self.show_end_result_m.clicked.disconnect()
            self.show_end_result_m.clicked.connect(self.show_end_result_clicked_m)
            self.show_end_result_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
        except:
            self.show_matrices_m.clicked.connect(self.show_matrices_clicked_m)
            self.show_matrices_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            self.show_end_result_m.clicked.connect(self.show_end_result_clicked_m)
            self.show_end_result_m.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.heightForWidth"><code class="name flex">
<span>def <span class="ident">heightForWidth</span></span>(<span>self, width:float)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes height for a given width.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code></dt>
<dd>Given width.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Computed height.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def heightForWidth(self, width: float):
    &#34;&#34;&#34;Computes height for a given width.

    Args:
        width (float): Given width.

    Returns:
        float: Computed height.
    &#34;&#34;&#34;
    height_for_width_factor = 1.0 * 519 / 688
    return math.ceil(width * height_for_width_factor)</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.hide_multiple"><code class="name flex">
<span>def <span class="ident">hide_multiple</span></span>(<span>self, widgets:list)</span>
</code></dt>
<dd>
<div class="desc"><p>Hides multiple widgets at once, makes code a lot shorter because it unites several calls of the same function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>widgets</code></strong> :&ensp;<code>list</code></dt>
<dd>Widgets who should be hidden.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hide_multiple(self, widgets: list):
    &#34;&#34;&#34;Hides multiple widgets at once, makes code a lot shorter because it unites several calls of the same function.

    Args:
        widgets (list): Widgets who should be hidden.
    &#34;&#34;&#34;
    for widget in widgets:
        widget.hide()</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.hide_retain_space"><code class="name flex">
<span>def <span class="ident">hide_retain_space</span></span>(<span>self, widgets:list)</span>
</code></dt>
<dd>
<div class="desc"><p>Retains the space of a widget even when it's hidden.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>widget</code></strong> :&ensp;<code>QtWidgets.QWidget </code></dt>
<dd>Widget whose space should be retained.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hide_retain_space(self, widgets: list):
    &#34;&#34;&#34;Retains the space of a widget even when it&#39;s hidden.

    Args:
        widget (QtWidgets.QWidget ): Widget whose space should be retained.
    &#34;&#34;&#34;
    for widget in widgets:
        retain = widget.sizePolicy()
        retain.setRetainSizeWhenHidden(True)
        widget.setSizePolicy(retain)</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.loops_onoff"><code class="name flex">
<span>def <span class="ident">loops_onoff</span></span>(<span>self, checkbox:PyQt5.QtWidgets.QCheckBox)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when "loops" checkbox in single soliton widget is checked/ unchecked.
Hides "loop paths"/ unhides them.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>checkbox</code></strong> :&ensp;<code>QtWidgets.QCheckBox</code></dt>
<dd>"Loops" checkbox.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loops_onoff(self, checkbox: QtWidgets.QCheckBox):
    &#34;&#34;&#34;Is called when &#34;loops&#34; checkbox in single soliton widget is checked/ unchecked.
    Hides &#34;loop paths&#34;/ unhides them.

    Args:
        checkbox (QtWidgets.QCheckBox): &#34;Loops&#34; checkbox.
    &#34;&#34;&#34;
    if checkbox.isChecked() == True:
        for index in self.loops_indices:
            if index &lt; self.paths.count():
                view = self.paths.view()
                view.setRowHidden(index, False)
                model = self.paths.model()
                item = model.item(index)
                item.setFlags(item.flags() | Qt.ItemIsEnabled)
        self.paths.setCurrentIndex(0)
    else:
        for index in self.loops_indices:
            if index &lt; self.paths.count():
                view = self.paths.view()
                view.setRowHidden(index, True)
                model = self.paths.model()
                item = model.item(index)
                item.setFlags(item.flags() &amp; ~Qt.ItemIsEnabled)
        curIndex = 0
        for i in range (0, len(self.found_paths)):
            if curIndex not in self.loops_indices:
                break
            else:
                curIndex += 1
        self.paths.setCurrentIndex(curIndex)</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.loops_onoff_m"><code class="name flex">
<span>def <span class="ident">loops_onoff_m</span></span>(<span>self, checkbox:PyQt5.QtWidgets.QCheckBox)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when "loops" checkbox in multi soliton widget is checked/ unchecked.
Hides "loop traversals"/ unhides them.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>checkbox</code></strong> :&ensp;<code>QtWidgets.QCheckBox</code></dt>
<dd>"Loops" checkbox.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loops_onoff_m(self, checkbox: QtWidgets.QCheckBox):
    &#34;&#34;&#34;Is called when &#34;loops&#34; checkbox in multi soliton widget is checked/ unchecked.
    Hides &#34;loop traversals&#34;/ unhides them.

    Args:
        checkbox (QtWidgets.QCheckBox): &#34;Loops&#34; checkbox.
    &#34;&#34;&#34;
    if checkbox.isChecked() == True:
        for index in self.loops_indices_m:
            if index &lt; self.traversals.count():
                view = self.traversals.view()
                view.setRowHidden(index, False)
                model = self.traversals.model()
                item = model.item(index)
                item.setFlags(item.flags() | Qt.ItemIsEnabled)
        self.traversals.setCurrentIndex(0)
    else:
        for index in self.loops_indices_m:
            if index &lt; self.traversals.count():
                view = self.traversals.view()
                view.setRowHidden(index, True)
                model = self.traversals.model()
                item = model.item(index)
                item.setFlags(item.flags() &amp; ~Qt.ItemIsEnabled)
        curIndex = 0
        for i in range (0, len(self.found_traversals)):
            if curIndex not in self.loops_indices_m:
                break
            else:
                curIndex += 1
        self.traversals.setCurrentIndex(curIndex)</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.mol_info_clicked"><code class="name flex">
<span>def <span class="ident">mol_info_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when "Info" button in single soliton widget is clicked. Opens a dialog window showing whether
the automata is deterministic and strongly deterministic and displaying all impervious paths.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mol_info_clicked(self):
    &#34;&#34;&#34;Is called when &#34;Info&#34; button in single soliton widget is clicked. Opens a dialog window showing whether
    the automata is deterministic and strongly deterministic and displaying all impervious paths.
    &#34;&#34;&#34;

    def save_info():
        &#34;&#34;&#34;Opens a file dialog in which user can specify a path where a text file with all info on soliton automata/ soliton graph should be saved.
        Text file also contains the input string representing the molecule.
        Only allows `.txt` file suffix.
        &#34;&#34;&#34;
        option = QtWidgets.QFileDialog.Options()
        name = QtWidgets.QFileDialog.getSaveFileName(self.wid_single, &#39;Save File&#39;, &#39;info.txt&#39;, &#39;Text files (*.txt)&#39;, options = option)
        if name != (&#39;&#39;, &#39;&#39;): # only do the following if user clicked on save button (without this line the application closes with an error if save action is cancelled)
            path = name[0]
            file = open(path, &#34;w&#34;)
            file.write(txt_text)
            file.close()
    
    txt_text = f&#34;Soliton graph: {self.smiles_string} \n&#34;
    txt_text = txt_text + f&#34;Stop number: {self.stop_number} \n\n&#34;
    dlg = QDialog(self.wid_single)
    grid = QtWidgets.QGridLayout(dlg)
    label_det = QtWidgets.QLabel(dlg)
    label_det.setText(&#34;Deterministic:&#34;)
    txt_text = txt_text + f&#34;Deterministic: &#34;
    grid.addWidget(label_det, 0, 0, 1, 1)
    det_bool = QtWidgets.QLabel(dlg)
    if self.automata.deterministic:
        det_bool.setText(&#34;Yes&#34;)
        txt_text = txt_text + f&#34;Yes \n&#34;
    else: 
        det_bool.setText(&#34;No&#34;)
        txt_text = txt_text + f&#34;No \n&#34;
    grid.addWidget(det_bool, 0, 1, 1, 1)
    label_strong_det = QtWidgets.QLabel(dlg)
    label_strong_det.setText(&#34;Strongly deterministic:&#34;)
    txt_text = txt_text + f&#34;Strongly deterministic: &#34;
    grid.addWidget(label_strong_det, 1, 0, 1, 1)
    strong_det_bool = QtWidgets.QLabel(dlg)
    if self.automata.strongly_deterministic:
        strong_det_bool.setText(&#34;Yes&#34;)
        txt_text = txt_text + f&#34;Yes \n&#34;
    else: 
        strong_det_bool.setText(&#34;No&#34;)
        txt_text = txt_text + f&#34;No \n&#34;
    grid.addWidget(strong_det_bool, 1, 1, 1, 1)
    label_imp_paths = QtWidgets.QLabel(dlg)
    label_imp_paths.setText(&#34;Impervious path(s):&#34;)
    txt_text = txt_text + f&#34;Impervious path(s): &#34;
    grid.addWidget(label_imp_paths, 2, 0, 1, 1, alignment = QtCore.Qt.AlignTop)
    save_button = QtWidgets.QPushButton(dlg)
    save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
    save_button.setMinimumSize(QtCore.QSize(0, 32))
    grid.addWidget(save_button, 3, 1, 1, 1)
    save_button.clicked.connect(save_info)
    group = QtWidgets.QGroupBox()
    layout = QtWidgets.QGridLayout(group)
    layout.setContentsMargins(0, 0, 0, 0)
    impervs = self.automata.find_impervious_paths()
    if impervs == []:
        layout.addWidget(QtWidgets.QLabel(&#34;-&#34;))
        txt_text = txt_text + f&#34;-&#34;
    for i, path in enumerate(impervs):
        layout.addWidget(QtWidgets.QLabel(path), i, 0, 1, 1, alignment = QtCore.Qt.AlignTop)
        txt_text = txt_text + f&#34;{path}&#34;
        if i != len(impervs)-1:
            txt_text = txt_text + f&#34;, &#34;
    grid.addWidget(group, 2, 1, 1, 1, alignment = QtCore.Qt.AlignTop)
    dlg.setWindowTitle(&#34;Info&#34;)
    dlg.exec_()</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.mol_info_clicked_m"><code class="name flex">
<span>def <span class="ident">mol_info_clicked_m</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when "Info" button in multi soliton widget is clicked. Opens a dialog window showing whether
the automata is deterministic and strongly deterministic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mol_info_clicked_m(self):
    &#34;&#34;&#34;Is called when &#34;Info&#34; button in multi soliton widget is clicked. Opens a dialog window showing whether
    the automata is deterministic and strongly deterministic.
    &#34;&#34;&#34;

    def save_info():
        &#34;&#34;&#34;Opens a file dialog in which user can specify a path where a text file with all info on soliton automata/ soliton graph should be saved.
        Text file also contains the input string representing the molecule.
        Only allows `.txt` file suffix.
        &#34;&#34;&#34;
        option = QtWidgets.QFileDialog.Options()
        name = QtWidgets.QFileDialog.getSaveFileName(self.wid_single, &#39;Save File&#39;, &#39;info.txt&#39;, &#39;Text files (*.txt)&#39;, options = option)
        if name != (&#39;&#39;, &#39;&#39;): # only do the following if user clicked on save button (without this line the application closes with an error if save action is cancelled)
            path = name[0]
            file = open(path, &#34;w&#34;)
            file.write(txt_text)
            file.close()
    
    dlg = QDialog(self.wid_single)
    grid = QtWidgets.QGridLayout(dlg)
    label_det = QtWidgets.QLabel(dlg)
    txt_text = f&#34;Soliton graph: {self.smiles_string_m} \n&#34;
    txt_text = txt_text + f&#34;Set of bursts: {self.bursts} \n&#34;
    txt_text = txt_text + f&#34;Stop number: {self.stop_number_m} \n\n&#34;
    label_det.setText(&#34;Deterministic:&#34;)
    txt_text = txt_text + f&#34;Deterministic: &#34;
    grid.addWidget(label_det, 0, 0, 1, 1)
    det_bool = QtWidgets.QLabel(dlg)
    if self.multi_automata.deterministic:
        det_bool.setText(&#34;Yes&#34;)
        txt_text = txt_text + f&#34;Yes \n&#34;
    else: 
        det_bool.setText(&#34;No&#34;)
        txt_text = txt_text + f&#34;No \n&#34;
    grid.addWidget(det_bool, 0, 1, 1, 1)
    label_strong_det = QtWidgets.QLabel(dlg)
    label_strong_det.setText(&#34;Strongly deterministic:&#34;)
    txt_text = txt_text + f&#34;Strongly deterministic: &#34;
    grid.addWidget(label_strong_det, 1, 0, 1, 1)
    strong_det_bool = QtWidgets.QLabel(dlg)
    if self.multi_automata.strongly_deterministic:
        strong_det_bool.setText(&#34;Yes&#34;)
        txt_text = txt_text + f&#34;Yes \n&#34;
    else: 
        strong_det_bool.setText(&#34;No&#34;)
        txt_text = txt_text + f&#34;No \n&#34;
    grid.addWidget(strong_det_bool, 1, 1, 1, 1)
    save_button = QtWidgets.QPushButton(dlg)
    save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
    save_button.setMinimumSize(QtCore.QSize(0, 32))
    grid.addWidget(save_button, 3, 1, 1, 1)
    save_button.clicked.connect(save_info)
    dlg.setWindowTitle(&#34;Info&#34;)
    dlg.exec_()</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.resizeEvent"><code class="name flex">
<span>def <span class="ident">resizeEvent</span></span>(<span>self, event:PyQt5.QtGui.QResizeEvent)</span>
</code></dt>
<dd>
<div class="desc"><p>Keeps the right aspect ratio of the graph visualisation image (or welcoming screen in the beginning) when window is resized.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>QtGui.QResizeEvent</code></dt>
<dd>Resize event.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resizeEvent(self, event: QtGui.QResizeEvent):
    &#34;&#34;&#34;Keeps the right aspect ratio of the graph visualisation image (or welcoming screen in the beginning) when window is resized.

    Args:
        event (QtGui.QResizeEvent): Resize event.
    &#34;&#34;&#34;
    super(MainWindow, self).resizeEvent(event)
    size = event.size()
    # window height minus height of all widgets below the label result in height of pixmap
    height = size.height() - self.save.height() - self.submit_molecule.height() - self.submit_exterior_nodes.height() - self.paths.height() - self.show_animation.height()
    if self.widthForHeight(height) &gt; size.width(): # pixmap width should be as most as big as width of whole window
        width = size.width()
    else:
        width = self.widthForHeight(height)
    self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(width, height, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
    self.display_molecule_m.setPixmap(QtGui.QPixmap.fromImage(self.qim_m).scaled(width, height, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.retranslateUi"><code class="name flex">
<span>def <span class="ident">retranslateUi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Implements multi-language suppport. Is generated automatically when using PyQt5 UI code generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retranslateUi(self):
    &#34;&#34;&#34;Implements multi-language suppport. Is generated automatically when using PyQt5 UI code generator.
    &#34;&#34;&#34;
    _translate = QtCore.QCoreApplication.translate
    self.setWindowTitle(_translate(&#34;MainWindow&#34;, &#34;Soliton Automata Software&#34;))
    self.mol_info.setText(_translate(&#34;MainWindow&#34;, &#34;Info&#34;))
    self.molecule_label.setText(_translate(&#34;MainWindow&#34;, &#34;Molecule:&#34;))
    self.stop_number_label.setText(_translate(&#34;MainWindow&#34;, &#34;Stop:&#34;))
    self.submit_molecule.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
    self.exterior_nodes_label.setText(_translate(&#34;MainWindow&#34;, &#34;Exterior nodes:&#34;))
    self.exterior_nodes_label2.setText(_translate(&#34;MainWindow&#34;, &#34;&amp;&#34;))
    self.submit_exterior_nodes.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
    self.soliton_paths_label.setText(_translate(&#34;MainWindow&#34;, &#34;Soliton paths:&#34;))
    self.show_matrices.setText(_translate(&#34;MainWindow&#34;, &#34;Show matrices&#34;))
    self.show_end_result.setText(_translate(&#34;MainWindow&#34;, &#34;Show end result&#34;))
    self.show_animation.setText(_translate(&#34;MainWindow&#34;, &#34;Show animation&#34;))

    self.mol_info_m.setText(_translate(&#34;MainWindow&#34;, &#34;Info&#34;))
    self.molecule_label_m.setText(_translate(&#34;MainWindow&#34;, &#34;Molecule:&#34;))
    self.submit_molecule_m.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
    self.set_of_bursts_label.setText(_translate(&#34;MainWindow&#34;, &#34;Set of bursts:&#34;))
    self.submit_set_of_bursts.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
    self.bursts_label.setText(_translate(&#34;MainWindow&#34;, &#34;Bursts:&#34;))
    self.stop_number_label_m.setText(_translate(&#34;MainWindow&#34;, &#34;Stop:&#34;))
    self.submit_burst.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
    self.traversals_label.setText(_translate(&#34;MainWindow&#34;, &#34;Sets of paths:&#34;))
    self.show_matrices_m.setText(_translate(&#34;MainWindow&#34;, &#34;Show matrices&#34;))
    self.show_end_result_m.setText(_translate(&#34;MainWindow&#34;, &#34;Show end result&#34;))
    self.show_animation_m.setText(_translate(&#34;MainWindow&#34;, &#34;Show animation&#34;))</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.save_clicked"><code class="name flex">
<span>def <span class="ident">save_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when user clicks button to save the graph visualisation in single soliton widget.
Opens a file dialog in which user can specify a path where the image should be saved.
Only allows <code>.jpg</code>, <code>.png</code> and <code>.jpeg</code> file suffixes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_clicked(self):
    &#34;&#34;&#34;Is called when user clicks button to save the graph visualisation in single soliton widget.
    Opens a file dialog in which user can specify a path where the image should be saved.
    Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
    &#34;&#34;&#34;
    option = QtWidgets.QFileDialog.Options()
    name = QtWidgets.QFileDialog.getSaveFileName(self.wid_single, &#39;Save File&#39;, &#39;graph.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
    if name != (&#39;&#39;, &#39;&#39;):
        path = name[0]
        # turn PIL Image into byte array 
        imgByteArr = io.BytesIO()
        self.graph_pic.save(imgByteArr, format=&#39;PNG&#39;)
        imgByteArr = imgByteArr.getvalue()
        # save image at specified path
        file = open(path, &#34;wb&#34;)
        file.write(imgByteArr)
        file.close()</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.save_clicked_m"><code class="name flex">
<span>def <span class="ident">save_clicked_m</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when user clicks button to save the graph visualisation in multi soliton widget.
Opens a file dialog in which user can specify a path where the image should be saved.
Only allows <code>.jpg</code>, <code>.png</code> and <code>.jpeg</code> file suffixes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_clicked_m(self):
    &#34;&#34;&#34;Is called when user clicks button to save the graph visualisation in multi soliton widget.
    Opens a file dialog in which user can specify a path where the image should be saved.
    Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
    &#34;&#34;&#34;
    option = QtWidgets.QFileDialog.Options()
    name = QtWidgets.QFileDialog.getSaveFileName(self.wid_mult, &#39;Save File&#39;, &#39;graph.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
    if name != (&#39;&#39;, &#39;&#39;):
        path = name[0] 
        imgByteArr = io.BytesIO()
        self.graph_pic_m.save(imgByteArr, format=&#39;PNG&#39;)
        imgByteArr = imgByteArr.getvalue()
        file = open(path, &#34;wb&#34;)
        file.write(imgByteArr)
        file.close()</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.show_animation_clicked"><code class="name flex">
<span>def <span class="ident">show_animation_clicked</span></span>(<span>self, button:PyQt5.QtWidgets.QPushButton)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when user clicks button to have the animation of the soliton traversing the graph displayed.
Makes a small window pop up that shows the animation and provides a "pause"/ "play" button, a "back" and a "forward" button and a save button.
Instead of displaying the <code>gif</code> it uses a sequence of <code>PIL</code> images and always shows the next image after a certain time.
Calls different animation functions depending on whether application is in single or multi soliton widget.
If a "loop path"/ "loop traversal" was chosen, save button is disabled and animation loops after loop point is reached.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>button</code></strong> :&ensp;<code>QtWidgets.QPushButton</code></dt>
<dd>Button that called the function (either button in single or in multi soliton widget).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_animation_clicked(self, button: QtWidgets.QPushButton):
    &#34;&#34;&#34;Is called when user clicks button to have the animation of the soliton traversing the graph displayed.
    Makes a small window pop up that shows the animation and provides a &#34;pause&#34;/ &#34;play&#34; button, a &#34;back&#34; and a &#34;forward&#34; button and a save button.
    Instead of displaying the `gif` it uses a sequence of `PIL` images and always shows the next image after a certain time.
    Calls different animation functions depending on whether application is in single or multi soliton widget.
    If a &#34;loop path&#34;/ &#34;loop traversal&#34; was chosen, save button is disabled and animation loops after loop point is reached.

    Args:
        button (QtWidgets.QPushButton): Button that called the function (either button in single or in multi soliton widget).
    &#34;&#34;&#34;

    def save_animation():
        &#34;&#34;&#34;Opens a file dialog in which user can specify a path where the animation should be saved.
        Only allows `.gif` file suffix.
        &#34;&#34;&#34;
        option = QtWidgets.QFileDialog.Options()
        name = QtWidgets.QFileDialog.getSaveFileName(wid, &#39;Save File&#39;, &#39;animation.gif&#39;, &#39;Images (*.gif)&#39;, options = option)
        if name != (&#39;&#39;, &#39;&#39;):
            path = name[0]
            if button == self.show_animation: # single soliton animation
                ani = Animation.graph_animation(self.my_graph, self.desired_path)
            else: ani = Animation.graph_animation_multiwave(self.my_graph_m, self.desired_traversal) # multi soliton animation
            ani.save(path, writer=&#39;pillow&#39;, dpi = 600)

    def update_image():
        &#34;&#34;&#34;Displays next image of animation.
        &#34;&#34;&#34;
        self.step += 1
        if button == self.show_animation:
            if isinstance(self.desired_path, SolitonPath):
                if self.step == len(self.desired_path.path): # start animation all over again as soon as end is reached (endless loop)
                    self.step = 0
            else:
                if self.step == len(self.desired_path[0].path):
                    self.over_looppoint_count += 1 # another &#34;round&#34; of loop made
                    self.step = self.desired_path[1] # we reached the &#34;end&#34; (which in reality is the point where we noticed we are stuck in a loop) so we have to continue at the loop point now
        else:
            if isinstance(self.desired_traversal, Traversal):
                if self.step == len(self.desired_traversal.pos):
                    self.step = 0
            else:
                if self.step == len(self.desired_traversal[0].pos):
                    self.over_looppoint_count += 1
                    self.step = self.desired_traversal[1]
        im = self.pil_images[self.step]
        qim = ImageQt(im)
        self.label.setPixmap(QtGui.QPixmap.fromImage(qim.copy()))
        self.label.setScaledContents(True)

    def update_image_reverse():
        &#34;&#34;&#34;Displays previous image of animation.
        &#34;&#34;&#34;
        self.step -= 1
        if button == self.show_animation:
            if isinstance(self.desired_path, SolitonPath):
                if self.step == -1: # if start of animation was reached in the step before then continue at end of animation
                    self.step = len(self.desired_path.path) - 1
            else:
                if self.step == -1:
                    self.step = 0 # we can&#39;t go back to the end of the animation because it has no end, instead we stay at the beginning
                elif self.step == self.desired_path[1] - 1 and self.over_looppoint_count != 0: # before we go back to before the loop point we have to dismantle all &#34;rounds&#34; of loop that we made
                    self.step = len(self.desired_path[0].path) - 1 # continue again at the &#34;end&#34;
                    self.over_looppoint_count -= 1 # dismantle
        else:
            if isinstance(self.desired_traversal, Traversal):
                if self.step == -1:
                    self.step = len(self.desired_traversal.pos) - 1
            else:
                if self.step == -1:
                    self.step = 0 
                elif self.step == self.desired_traversal[1] - 1 and self.over_looppoint_count != 0:
                    self.step = len(self.desired_traversal[0].pos) - 1
                    self.over_looppoint_count -= 1
        im = self.pil_images[self.step]
        qim = ImageQt(im)
        self.label.setPixmap(QtGui.QPixmap.fromImage(qim.copy()))
        self.label.setScaledContents(True)
        
    def pause_animation(button: QtWidgets.QPushButton):
        &#34;&#34;&#34;Is called when &#34;pause&#34;/ &#34;play&#34; button is pressed.
        Pauses/ plays animation by stopping the timer/ starting the timer.

        Args:
            button (QtWidgets.QPushButton): Button that called the function (either button in single or in multi soliton widget).
        &#34;&#34;&#34;
        if self.timer.isActive(): # pause
            self.timer.stop()
            if button.parentWidget().parentWidget() == self.wid_single:
                button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
            else: button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
        else: # play
            update_image()
            self.timer.start(800)
            if button.parentWidget().parentWidget() == self.wid_single:
                button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/pause.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
            else: button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/pause.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)

    def next_img(button: QtWidgets.QPushButton):
        &#34;&#34;&#34;Is called when &#34;forward&#34; button is pressed.
        Stops the timer if it is still active and calls `update_image` function.

        Args:
            button (QtWidgets.QPushButton): Button that called the function (either button in single or in multi soliton widget).
        &#34;&#34;&#34;
        if self.timer.isActive():
            self.timer.stop()
            if button.parentWidget().parentWidget() == self.wid_single:
                button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
            else: button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
        update_image()

    def prev_img(button: QtWidgets.QPushButton):
        &#34;&#34;&#34;Is called when &#34;back&#34; button is pressed.
        Stops the timer if it is still active and calls `update_image_reverse` function.

        Args:
            button (QtWidgets.QPushButton): Button that called the function (either button in single or in multi soliton widget).
        &#34;&#34;&#34;
        if self.timer.isActive():
            self.timer.stop()
            if button.parentWidget().parentWidget() == self.wid_single:
                button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
            else: button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/play.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
        update_image_reverse()
        
    if button == self.show_animation:
        dlg = QDialog(self.wid_single)
    else: dlg = QDialog(self.wid_mult)
    self.label = QtWidgets.QLabel(dlg)
    self.label.setGeometry(QtCore.QRect(0, 0, 540, 405))
    
    if button == self.show_animation:
        wid = self.wid_single
    else:
        wid = self.wid_mult
    
    if button == self.show_animation:
        if self.path_index != self.paths.currentIndex():
            self.path_index = self.paths.currentIndex()
            self.desired_path = self.found_paths[self.path_index]
            if isinstance(self.desired_path, SolitonPath): # soliton path
                plots_and_arrays = Animation.list_of_plots_and_arrays(self.my_graph, self.desired_path)
            else: # &#34;loop path&#34;
                plots_and_arrays = Animation.list_of_plots_and_arrays(self.my_graph, self.desired_path[0])
            self.pil_images = Animation.list_of_pil_images(plots_and_arrays)
    else:
        if self.traversal_index != self.traversals.currentIndex():
            self.traversal_index = self.traversals.currentIndex()
            self.desired_traversal = self.found_traversals[self.traversal_index]
            if isinstance(self.desired_traversal, Traversal):
                plots_and_arrays = Animation.list_of_plots_and_arrays_multiwave(self.my_graph_m, self.desired_traversal)
            else: 
                plots_and_arrays = Animation.list_of_plots_and_arrays_multiwave(self.my_graph_m, self.desired_traversal[0])
            self.pil_images = Animation.list_of_pil_images(plots_and_arrays)

    save_button = QtWidgets.QPushButton(dlg)
    save_button.setGeometry(QtCore.QRect(470, 375, 70, 30))
    pause_button = QtWidgets.QPushButton(dlg)
    pause_button.setGeometry(QtCore.QRect(240, 375, 30, 30))
    pause_button.clicked.connect(lambda: pause_animation(pause_button))
    next_button = QtWidgets.QPushButton(dlg)
    next_button.setGeometry(QtCore.QRect(275, 375, 30, 30))
    next_button.clicked.connect(lambda: next_img(pause_button))
    prev_button = QtWidgets.QPushButton(dlg)
    prev_button.setGeometry(QtCore.QRect(205, 375, 30, 30))
    prev_button.clicked.connect(lambda: prev_img(pause_button))
    if button == self.show_animation:
        if isinstance(self.desired_path, SolitonPath):
            save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
            save_button.clicked.connect(save_animation)
        else:
            self.over_looppoint_count = 0 # how many times we passed the loop point
            save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230); image: url(:/icons/save.svg);}&#34;)
        pause_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/pause.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
        next_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/right-arrow.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
        prev_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/left-arrow.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193)}&#34;)
    else:
        if isinstance(self.desired_traversal, Traversal):
            save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
            save_button.clicked.connect(save_animation)
        else:
            self.over_looppoint_count = 0
            save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(230, 230, 230); image: url(:/icons/save.svg);}&#34;)
        pause_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/pause.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
        next_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/right-arrow.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
        prev_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/left-arrow.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123)}&#34;)

    self.step = -1
    self.timer = QtCore.QTimer(self)
    self.timer.timeout.connect(update_image) # timer calls `update_image` everytime event is triggered
    update_image()
    self.timer.start(800) # triggers event every 800 millisecond

    dlg.setWindowTitle(&#34;Animation&#34;)
    dlg.setFixedSize(545, 410)
    dlg.closeEvent = self.stop_animation # stop timer when window is closed
    dlg.exec_()</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.show_end_result_clicked"><code class="name flex">
<span>def <span class="ident">show_end_result_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when user clicks button to have the resulting graph (after soliton path is traversed) in single soliton widget displayed.
Makes a small window pop up that shows the graph visualisation and provides a save button.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_end_result_clicked(self):
    &#34;&#34;&#34;Is called when user clicks button to have the resulting graph (after soliton path is traversed) in single soliton widget displayed.
    Makes a small window pop up that shows the graph visualisation and provides a save button.
    &#34;&#34;&#34;

    def save_end_result():
        &#34;&#34;&#34;Opens a file dialog in which user can specify a path where the resulting graph should be saved.
        Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
        &#34;&#34;&#34;
        option = QtWidgets.QFileDialog.Options()
        name = QtWidgets.QFileDialog.getSaveFileName(self.wid_single, &#39;Save File&#39;, &#39;result.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
        if name != (&#39;&#39;, &#39;&#39;):
            path = name[0]
            imgByteArr = io.BytesIO()
            result_pic.save(imgByteArr, format=&#39;PNG&#39;)
            imgByteArr = imgByteArr.getvalue()
            file = open(path, &#34;wb&#34;)
            file.write(imgByteArr)
            file.close()

    def use_as_new_soliton_graph(dlg: QDialog):
        &#34;&#34;&#34;Uses the end result of the selected path as the new soliton graph. Puts the software in traversal mode.

        Args:
            dlg (QDialog): The dialog window that shows the end result.
        &#34;&#34;&#34;
        current_way = self.my_graph.way
        new_soliton_graph = copy.deepcopy(self.desired_path.resulting_soliton_graph)
        self.my_graph = new_soliton_graph
        self.my_graph.way = f&#34;{current_way}, {self.desired_path.path_for_user}&#34;
        self.graph_pic = Visualisation.visualize_soliton_graph(self.my_graph, self.my_graph.bindings, False, True)
        self.qim = ImageQt(self.graph_pic)
        self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(self.display_molecule.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))

        self.traversal_mode.setChecked(True)
        self.hide_multiple([self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
        self.node_1.setCurrentIndex(0)
        self.node_2.setCurrentIndex(0)
        dlg.close()

    index = self.paths.currentIndex()
    self.desired_path = self.found_paths[index]
    bindings_index = len(self.desired_path.path) - 1
    result_pic = Visualisation.visualize_soliton_graph(self.my_graph, self.desired_path.bindings_list[bindings_index], False, True)
    qim = ImageQt(result_pic)

    dlg = QDialog(self.wid_single)
    label = QtWidgets.QLabel(dlg)
    label.setGeometry(QtCore.QRect(0, 0, 540, 405))
    label.setPixmap(QtGui.QPixmap.fromImage(qim))
    label.setScaledContents(True)
    save_button = QtWidgets.QPushButton(dlg)
    save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
    save_button.setGeometry(QtCore.QRect(470, 375, 70, 30))
    save_button.clicked.connect(save_end_result)
    use_button = QtWidgets.QPushButton(&#34;Use&#34;, dlg)
    use_button.clicked.connect(lambda: use_as_new_soliton_graph(dlg))
    use_button.setGeometry(QtCore.QRect(395, 375, 70, 30))

    dlg.setWindowTitle(&#34;End result&#34;)
    dlg.setFixedSize(545, 410)
    dlg.exec_()</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.show_end_result_clicked_m"><code class="name flex">
<span>def <span class="ident">show_end_result_clicked_m</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when user clicks button to have the resulting graph (after soliton path is traversed) in multi soliton widget displayed.
Makes a small window pop up that shows the graph visualisation and provides a save button.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_end_result_clicked_m(self):
    &#34;&#34;&#34;Is called when user clicks button to have the resulting graph (after soliton path is traversed) in multi soliton widget displayed.
    Makes a small window pop up that shows the graph visualisation and provides a save button.
    &#34;&#34;&#34;

    def save_end_result():
        &#34;&#34;&#34;Opens a file dialog in which user can specify a path where the resulting graph should be saved.
        Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
        &#34;&#34;&#34;
        option = QtWidgets.QFileDialog.Options()
        name = QtWidgets.QFileDialog.getSaveFileName(self.wid_mult, &#39;Save File&#39;, &#39;result.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
        if name != (&#39;&#39;, &#39;&#39;):
            path = name[0]
            imgByteArr = io.BytesIO()
            result_pic.save(imgByteArr, format=&#39;PNG&#39;)
            imgByteArr = imgByteArr.getvalue()
            file = open(path, &#34;wb&#34;)
            file.write(imgByteArr)
            file.close()

    def use_as_new_soliton_graph(dlg: QDialog):
        &#34;&#34;&#34;Uses the end result of the selected path as the new soliton graph. Puts the software in traversal mode.

        Args:
            dlg (QDialog): The dialog window that shows the end result.
        &#34;&#34;&#34;
        current_way = self.my_graph_m.way
        new_soliton_graph = copy.deepcopy(self.desired_traversal.resulting_soliton_graph)
        self.my_graph_m = new_soliton_graph
        self.my_graph_m.way = f&#34;{current_way}, {self.desired_traversal.traversal_for_user}&#34;
        self.graph_pic = Visualisation.visualize_soliton_graph(self.my_graph_m, self.my_graph_m.bindings, False, True)
        self.qim_m = ImageQt(self.graph_pic)
        self.display_molecule_m.setPixmap(QtGui.QPixmap.fromImage(self.qim_m).scaled(self.display_molecule_m.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))

        self.traversal_mode_m.setChecked(True)
        self.hide_multiple([self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
        self.burst.setCurrentIndex(0)
        dlg.close()

    index = self.traversals.currentIndex()
    self.desired_traversal = self.found_traversals[index]
    result_pic = Visualisation.visualize_soliton_graph(self.desired_traversal.resulting_soliton_graph, self.desired_traversal.resulting_soliton_graph.bindings, False, True)
    qim = ImageQt(result_pic)

    dlg = QDialog(self.wid_mult)
    label = QtWidgets.QLabel(dlg)
    label.setGeometry(QtCore.QRect(0, 0, 540, 405))
    label.setPixmap(QtGui.QPixmap.fromImage(qim))
    label.setScaledContents(True)
    save_button = QtWidgets.QPushButton(dlg)
    save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
    save_button.setGeometry(QtCore.QRect(470, 375, 70, 30))
    save_button.clicked.connect(save_end_result)
    use_button = QtWidgets.QPushButton(&#34;Use&#34;, dlg)
    use_button.clicked.connect(lambda: use_as_new_soliton_graph(dlg))
    use_button.setGeometry(QtCore.QRect(395, 375, 70, 30))

    dlg.setWindowTitle(&#34;End result&#34;)
    dlg.setFixedSize(545, 410)
    dlg.exec_()</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.show_matrices_clicked"><code class="name flex">
<span>def <span class="ident">show_matrices_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when user clicks button to have the adjacency matrices of every timestep in single soliton widget displayed.
Makes a small window pop up that shows the labelled adjacency matrices and provides a save button.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_matrices_clicked(self):
    &#34;&#34;&#34;Is called when user clicks button to have the adjacency matrices of every timestep in single soliton widget displayed.
    Makes a small window pop up that shows the labelled adjacency matrices and provides a save button.
    &#34;&#34;&#34;

    def save_matrices():
        &#34;&#34;&#34;Opens a file dialog in which user can specify a path where a text file with all adjacency matrices should be saved.
        Text file also contains the input string representing the molecule and the soliton path.
        Only allows `.txt` file suffix.
        &#34;&#34;&#34;
        option = QtWidgets.QFileDialog.Options()
        name = QtWidgets.QFileDialog.getSaveFileName(self.wid_single, &#39;Save File&#39;, &#39;matrices.txt&#39;, &#39;Text files (*.txt)&#39;, options = option)
        if name != (&#39;&#39;, &#39;&#39;): # only do the following if user clicked on save button (without this line the application closes with an error if save action is cancelled)
            path = name[0]
            file = open(path, &#34;w&#34;)
            file.write(txt_text)
            file.close()

    index = self.paths.currentIndex()
    desired_path = self.found_paths[index]

    dlg = QDialog(self.wid_single)
    scrollArea = QScrollArea(dlg)
    scrollArea.setStyleSheet(&#34;font: 13pt Courier;&#34;)
    widget = QtWidgets.QWidget()
    vbox = QtWidgets.QVBoxLayout()
    if re.search(&#39;,&#39;, self.my_graph.way) is not None:
        txt_text = f&#34;Way to soliton graph: {self.my_graph.way} \n&#34;
    else:
        txt_text = f&#34;Soliton graph: {self.my_graph.way} \n&#34;
    txt_text = txt_text + f&#34;Soliton path: {desired_path.path_for_user} \n \n&#34;
    # labelling of matrix depends on wether we have long node labels (&#34;aa&#34;, &#34;ab&#34;, ...) or short ones (&#34;a&#34;, &#34;b&#34;, ...)
    if (len(self.my_graph.labels) - len(self.my_graph.exterior_nodes)) &gt; 26:
        matrix_label_horizontal = &#34;    &#34;
        long_labels = True
    else:
        matrix_label_horizontal = &#34;   &#34;
        long_labels = False
    for key in self.my_graph.labels:
        if long_labels:
            if self.my_graph.labels[key] in self.my_graph.exterior_nodes_reverse and int(self.my_graph.labels[key]) &lt; 10:
                matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]}  &#34;
            else:
                matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]} &#34;
        else:
            if self.my_graph.labels[key] in self.my_graph.exterior_nodes_reverse and int(self.my_graph.labels[key]) &gt;= 10:
                matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]} &#34;
            else:
                matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]}  &#34;
    # for show-matrices-window the node labels are added to the matrix string and this labelled matrix is added to scroll area
    # for matrices.txt we add everything (horizontal label and every row of matrix) line by line
    for i in range(len(desired_path.adjacency_matrices_list)):
        txt_text = txt_text + f&#34;Timestep {i}: \n&#34;
        txt_text = txt_text + f&#34;{matrix_label_horizontal} \n&#34;
        matrix_labelled = &#34;&#34;
        matrix_labelled = matrix_labelled + f&#34;{matrix_label_horizontal}\n&#34;
        matrix = str(desired_path.adjacency_matrices_list[i])
        matrix = re.sub(r&#34;[matrix(]&#34;, &#34;&#34;, matrix)
        matrix = re.sub(r&#34;[)]&#34;, &#34;&#34;, matrix)
        for j in range(len(matrix.splitlines())):
            if long_labels:
                if self.my_graph.labels[j] in self.my_graph.exterior_nodes_reverse and int(self.my_graph.labels[j]) &lt; 10:
                    matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]} {matrix.splitlines()[j]} \n&#34;
                    txt_text = txt_text + f&#34;{self.my_graph.labels[j]} {matrix.splitlines()[j]} \n&#34;
                else:
                    matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
                    txt_text = txt_text + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
            else:
                if self.my_graph.labels[j] in self.my_graph.exterior_nodes_reverse and int(self.my_graph.labels[j]) &gt;= 10:
                    matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j][1:]} \n&#34;
                    txt_text = txt_text + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j][1:]} \n&#34;
                else:
                    matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
                    txt_text = txt_text + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
        txt_text = txt_text + f&#34;\n&#34;
        vbox.addWidget(QtWidgets.QLabel(matrix_labelled))
    widget.setLayout(vbox)
    scrollArea.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
    scrollArea.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
    scrollArea.setWidgetResizable(True)
    scrollArea.setWidget(widget)
    scrollArea.setFixedSize(540, 405)
    save_button = QtWidgets.QPushButton(dlg)
    save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(191, 207, 255); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(132, 145, 193);}&#34;)
    save_button.setGeometry(QtCore.QRect(454, 359, 70, 30))
    save_button.clicked.connect(save_matrices)

    dlg.setWindowTitle(&#34;Adjacency Matrices&#34;)
    dlg.setFixedSize(545, 410)
    dlg.exec_()</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.show_matrices_clicked_m"><code class="name flex">
<span>def <span class="ident">show_matrices_clicked_m</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when user clicks button to have the adjacency matrices of every timestep in multi soliton widget displayed.
Makes a small window pop up that shows the labelled adjacency matrices and provides a save button.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_matrices_clicked_m(self):
    &#34;&#34;&#34;Is called when user clicks button to have the adjacency matrices of every timestep in multi soliton widget displayed.
    Makes a small window pop up that shows the labelled adjacency matrices and provides a save button.
    &#34;&#34;&#34;

    def save_matrices():
        &#34;&#34;&#34;Opens a file dialog in which user can specify a path where a text file with all adjacency matrices should be saved.
        Text file also contains the input string representing the molecule and the soliton path.
        Only allows `.txt` file suffix.
        &#34;&#34;&#34;
        option = QtWidgets.QFileDialog.Options()
        name = QtWidgets.QFileDialog.getSaveFileName(self.wid_mult, &#39;Save File&#39;, &#39;matrices.txt&#39;, &#39;Text files (*.txt)&#39;, options = option)
        if name != (&#39;&#39;, &#39;&#39;): # only do the following if user clicked on save button (without this line the application closes with an error if save action is cancelled)
            path = name[0]
            file = open(path, &#34;w&#34;)
            file.write(txt_text)
            file.close()

    index = self.traversals.currentIndex()
    desired_traversal = self.found_traversals[index]

    dlg = QDialog(self.wid_mult)
    scrollArea = QScrollArea(dlg)
    scrollArea.setStyleSheet(&#34;font: 13pt Courier;&#34;)
    widget = QtWidgets.QWidget()
    vbox = QtWidgets.QVBoxLayout()
    if re.search(&#39;,&#39;, self.my_graph_m.way) is not None:
        txt_text = f&#34;Way to soliton graph: {self.my_graph_m.way} \n&#34;
    else:
        txt_text = f&#34;Soliton graph: {self.my_graph_m.way} \n&#34;
    txt_text = txt_text + f&#34;Set of bursts: {self.bursts} \n&#34;
    this_traversal = &#34;&#34;
    for i, path in enumerate(desired_traversal.traversal_for_user):
        this_traversal = this_traversal + path
        if i != len(desired_traversal.traversal_for_user)-1:
            this_traversal = this_traversal + &#34;, &#34;
    txt_text = txt_text + f&#34;Traversal: {this_traversal} \n \n&#34;
    if (len(self.my_graph_m.labels) - len(self.my_graph_m.exterior_nodes)) &gt; 26:
        matrix_label_horizontal = &#34;    &#34;
        long_labels = True
    else:
        matrix_label_horizontal = &#34;   &#34;
        long_labels = False
    for key in self.my_graph_m.labels:
        if long_labels:
            if self.my_graph_m.labels[key] in self.my_graph_m.exterior_nodes_reverse and int(self.my_graph_m.labels[key]) &lt; 10:
                matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph_m.labels[key]}  &#34;
            else:
                matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph_m.labels[key]} &#34;
        else:
            if self.my_graph_m.labels[key] in self.my_graph_m.exterior_nodes_reverse and int(self.my_graph_m.labels[key]) &gt;= 10:
                matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph_m.labels[key]} &#34;
            else:
                matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph_m.labels[key]}  &#34;
    for i in range(len(desired_traversal.adjacency_matrices_list)):
        txt_text = txt_text + f&#34;Timestep {i}: \n&#34;
        txt_text = txt_text + f&#34;{matrix_label_horizontal} \n&#34;
        matrix_labelled = &#34;&#34;
        matrix_labelled = matrix_labelled + f&#34;{matrix_label_horizontal}\n&#34;
        matrix = str(desired_traversal.adjacency_matrices_list[i])
        matrix = re.sub(r&#34;[matrix(]&#34;, &#34;&#34;, matrix)
        matrix = re.sub(r&#34;[)]&#34;, &#34;&#34;, matrix)
        for j in range(len(matrix.splitlines())):
            if long_labels:
                if self.my_graph_m.labels[j] in self.my_graph_m.exterior_nodes_reverse and int(self.my_graph_m.labels[j]) &lt; 10:
                    matrix_labelled = matrix_labelled + f&#34;{self.my_graph_m.labels[j]} {matrix.splitlines()[j]} \n&#34;
                    txt_text = txt_text + f&#34;{self.my_graph_m.labels[j]} {matrix.splitlines()[j]} \n&#34;
                else:
                    matrix_labelled = matrix_labelled + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j]} \n&#34;
                    txt_text = txt_text + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j]} \n&#34;
            else:
                if self.my_graph_m.labels[j] in self.my_graph_m.exterior_nodes_reverse and int(self.my_graph_m.labels[j]) &gt;= 10:
                    matrix_labelled = matrix_labelled + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j][1:]} \n&#34;
                    txt_text = txt_text + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j][1:]} \n&#34;
                else:
                    matrix_labelled = matrix_labelled + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j]} \n&#34;
                    txt_text = txt_text + f&#34;{self.my_graph_m.labels[j]}{matrix.splitlines()[j]} \n&#34;
        txt_text = txt_text + f&#34;\n&#34;
        vbox.addWidget(QtWidgets.QLabel(matrix_labelled))
    widget.setLayout(vbox)
    scrollArea.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
    scrollArea.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
    scrollArea.setWidgetResizable(True)
    scrollArea.setWidget(widget)
    scrollArea.setFixedSize(540, 405)
    save_button = QtWidgets.QPushButton(dlg)
    save_button.setStyleSheet(&#34;QPushButton {background-color: rgb(149, 221, 185); image: url(:/icons/save.svg);} QPushButton::pressed {background-color : rgb(90, 159, 123);}&#34;)
    save_button.setGeometry(QtCore.QRect(454, 359, 70, 30))
    save_button.clicked.connect(save_matrices)

    dlg.setWindowTitle(&#34;Adjacency Matrices&#34;)
    dlg.setFixedSize(545, 410)
    dlg.exec_()</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.show_multiple"><code class="name flex">
<span>def <span class="ident">show_multiple</span></span>(<span>self, widgets:list)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows multiple widgets at once, makes code a lot shorter because it unites several calls of the same function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>widgets</code></strong> :&ensp;<code>list</code></dt>
<dd>Widgets who should be showed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_multiple(self, widgets: list):
    &#34;&#34;&#34;Shows multiple widgets at once, makes code a lot shorter because it unites several calls of the same function.

    Args:
        widgets (list): Widgets who should be showed.
    &#34;&#34;&#34;
    for widget in widgets:
        widget.show()</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.stop_animation"><code class="name flex">
<span>def <span class="ident">stop_animation</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Stops the timer that is used for the animation.
Without this method the application would crash if the animation window would get closed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong></dt>
<dd>Close event of the window that shows animation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_animation(self, event):
    &#34;&#34;&#34;Stops the timer that is used for the animation.
    Without this method the application would crash if the animation window would get closed.
    Args:
        event: Close event of the window that shows animation.
    &#34;&#34;&#34;
    self.timer.disconnect()</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.submit_burst_clicked"><code class="name flex">
<span>def <span class="ident">submit_burst_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when user clicks button to submit burst(s).
Displays all possible traversals for the chosen burst/ all bursts.
Informs the user if no traversals exists for it/ them.
Otherwise all the necessary widgets for the user to choose a computed traversals and look at further information on it are revealed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submit_burst_clicked(self):
    &#34;&#34;&#34;Is called when user clicks button to submit burst(s).
    Displays all possible traversals for the chosen burst/ all bursts.
    Informs the user if no traversals exists for it/ them.
    Otherwise all the necessary widgets for the user to choose a computed traversals and look at further information on it are revealed.
    &#34;&#34;&#34;
    self.traversal_index = None # we need this variable later in show_animation_clicked
    self.traversals.clear()
    self.if_loops_m.setChecked(True)
    if self.all_bursts.isChecked():
        key = self.multi_automata.matrix_to_string(nx.to_numpy_array(self.my_graph_m.graph))
        self.found_traversals = self.multi_automata.states_plus_traversals[key][1]
        self.num_traversals_per_burst = self.multi_automata.states_plus_traversals[key][2]
    else:
        burst_index = int(self.burst.currentIndex())
        self.found_traversals = self.multi_automata.call_find_all_travs_given_burst(self.multi_automata.bursts_dicts[burst_index], self.my_graph_m)
        self.num_traversals_per_burst = None
    if self.found_traversals == []:
        self.hide_multiple([self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
        msg = QMessageBox(self.wid_mult)
        msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px;}&#34;)
        msg.setWindowTitle(&#34;No soliton paths found&#34;)
        msg.setText(&#34;With this burst(s), not all solitons can traverse the soliton graph successfully.&#34;)
        msg.setIcon(QMessageBox.Information)
        msg.setStandardButtons(QMessageBox.Retry)
        msg.setInformativeText(&#34;Please try again with different bursts.&#34;)
        x = msg.exec_()
    else:
        endless_loops = 0
        self.loops_indices_m = []
        for t, traversal in enumerate(self.found_traversals):
            if isinstance(traversal, Traversal): # if traversal is a real traversal and no endless loop
                this_traversal = &#34;&#34;
                for i, path in enumerate(traversal.traversal_for_user):
                    this_traversal = this_traversal + path
                    if i != len(traversal.traversal_for_user)-1:
                        this_traversal = this_traversal + &#34;, &#34;
                self.traversals.addItem(this_traversal)
            else:
                this_traversal = &#34;[!] &#34;
                for i, path in enumerate(traversal[0].traversal_for_user):
                    this_traversal = this_traversal + path + &#34; ...&#34;
                    if i != len(traversal[0].traversal_for_user)-1:
                        this_traversal = this_traversal + &#34;, &#34;
                self.traversals.addItem(this_traversal)
                endless_loops += 1
                self.loops_indices_m.append(t)
        self.traversals_label.setText(f&#34;Sets of paths ({len(self.found_traversals) - endless_loops}):&#34;)
        self.show_multiple([self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
        sep_index = 0
        if self.num_traversals_per_burst:
            for n, num in enumerate(self.num_traversals_per_burst): # add seperators to distinct which traversals resulted from which burst
                if num != 0 and n != len(self.num_traversals_per_burst)-1: # don&#39;t add if there is no traversal for this burst of if it&#39;s the last burst
                    sep_index += num
                    self.traversals.insertSeparator(sep_index)
                    self.found_traversals.insert(sep_index, None) # so the indices in found_traversals correspond with the indices of the combobox items
                    self.loops_indices_m = [(index + 1) if (index &gt;= sep_index) else index for index in self.loops_indices_m]
                    sep_index += 1 # indices got shifted by one because seperator was added</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.submit_exterior_nodes_clicked"><code class="name flex">
<span>def <span class="ident">submit_exterior_nodes_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when user clicks button to submit exterior nodes.
Displays all possible soliton paths between the two chosen nodes/ all pairs of exterior nodes.
Informs the user if no soliton path exists between them.
Otherwise all the necessary widgets for the user to choose a computed soliton path and look at further information on it are revealed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submit_exterior_nodes_clicked(self):
    &#34;&#34;&#34;Is called when user clicks button to submit exterior nodes.
    Displays all possible soliton paths between the two chosen nodes/ all pairs of exterior nodes.
    Informs the user if no soliton path exists between them.
    Otherwise all the necessary widgets for the user to choose a computed soliton path and look at further information on it are revealed.
    &#34;&#34;&#34;
    self.path_index = None # we need this variable later in show_animation_clicked
    self.paths.clear()
    self.if_loops.setChecked(True)
    if self.all_exterior_nodes.isChecked():
        key = self.automata.matrix_to_string(nx.to_numpy_array(self.my_graph.graph))
        self.found_paths = self.automata.states_plus_soliton_paths[key][1]
    else:
        node1 = self.my_graph.exterior_nodes_reverse[self.node_1.currentText()]
        node2 = self.my_graph.exterior_nodes_reverse[self.node_2.currentText()]
        self.found_paths = self.automata.call_find_all_paths_given_nodes(node1, node2, self.my_graph)
    if self.found_paths == []:
        self.hide_multiple([self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
        msg = QMessageBox(self.wid_single)
        msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px;}&#34;)
        msg.setWindowTitle(&#34;No path found&#34;)
        msg.setText(&#34;There exists no soliton path between these exterior nodes.&#34;)
        msg.setIcon(QMessageBox.Information)
        msg.setStandardButtons(QMessageBox.Retry)
        msg.setInformativeText(&#34;Please try again with different exterior nodes or a different soliton automata.&#34;)
        x = msg.exec_()
    else:
        endless_loops = 0
        self.loops_indices = []
        for p, soliton_path in enumerate(self.found_paths):
            if isinstance(soliton_path, SolitonPath): # if soliton path is a real soliton path and no endless loop
                self.paths.addItem(str(soliton_path.path_for_user))
            else:
                this_path = &#34;[!] &#34;
                this_path = this_path + soliton_path[0].path_for_user + &#34; ...&#34;
                self.paths.addItem(this_path)
                endless_loops += 1
                self.loops_indices.append(p)
        self.soliton_paths_label.setText(f&#34;Soliton paths ({len(self.found_paths) - endless_loops}):&#34;)
        self.show_multiple([self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.submit_molecule_clicked"><code class="name flex">
<span>def <span class="ident">submit_molecule_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when user clicks button to submit the specified molecule in single soliton widget.
Catches errors if user used the wrong syntax or specified a molecule that does not fulfill the requirements of a soliton graph.
If the user's molecule is valid it displays the graph of the molecule. It then also reveals a save button for the graph visualisation,
an info button and all the necessary widgets for the user to choose exterior nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submit_molecule_clicked(self):
    &#34;&#34;&#34;Is called when user clicks button to submit the specified molecule in single soliton widget.
    Catches errors if user used the wrong syntax or specified a molecule that does not fulfill the requirements of a soliton graph.
    If the user&#39;s molecule is valid it displays the graph of the molecule. It then also reveals a save button for the graph visualisation,
    an info button and all the necessary widgets for the user to choose exterior nodes.
    &#34;&#34;&#34;
    self.node_1.clear()
    self.node_2.clear()
    self.smiles_string = self.molecule_lineedit.text()
    self.stop_number = self.stop_number_spinbox.value()
    try:
        self.my_graph = SolitonGraph(self.smiles_string)
        errors = self.my_graph.validate_soliton_graph()
        self.automata = SolitonAutomata(self.my_graph, self.stop_number)
        self.graph_pic = Visualisation.visualize_soliton_graph(self.my_graph, self.my_graph.bindings, False, True)
        self.qim = ImageQt(self.graph_pic)
        self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(self.display_molecule.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
        if errors != []:
            self.hide_multiple([self.traversal_mode, self.row2, self.exterior_nodes_label, self.row4, self.submit_exterior_nodes, self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
            msg = QMessageBox(self.wid_single)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px;}&#34;)
            msg.setWindowTitle(&#34;No soliton graph&#34;)
            msg.setText(&#34;You specified a molecule that does not fulfill the requirements of a soliton graph.&#34;)
            msg.setIcon(QMessageBox.Warning)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;See details for all incorrect parts of your molecule.&#34;)
            details = &#34;&#34;
            for i, error in enumerate(errors):
                if i == len(errors) - 1:
                    details = details + f&#34;- {error}&#34;
                else:
                    details = details + f&#34;- {error}&#34; + &#34;\n&#34;
            msg.setDetailedText(details)
            x = msg.exec_() # show messagebox
        elif self.my_graph.exterior_nodes_name_collision() == True:
            self.hide_multiple([self.traversal_mode, self.row2, self.exterior_nodes_label, self.row4, self.submit_exterior_nodes, self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
            msg = QMessageBox(self.wid_single)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
            msg.setWindowTitle(&#34;Name collision&#34;)
            msg.setText(&#34;You specified two or more exterior nodes with the same name.&#34;)
            msg.setIcon(QMessageBox.Warning)
            msg.setStandardButtons(QMessageBox.Retry)
            x = msg.exec_()
        else:
            self.show_multiple([self.traversal_mode, self.row2, self.exterior_nodes_label, self.row4, self.submit_exterior_nodes])
            self.hide_multiple([self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
            for key in self.my_graph.exterior_nodes_reverse:
                self.node_1.addItem(key)
                self.node_2.addItem(key)
    except:
        self.hide_multiple([self.traversal_mode, self.row2, self.exterior_nodes_label, self.row4, self.submit_exterior_nodes, self.soliton_paths_label, self.paths, self.if_loops, self.row5, self.show_matrices, self.show_end_result, self.show_animation])
        msg = QMessageBox(self.wid_single)
        msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
        msg.setWindowTitle(&#34;Incorrect input&#34;)
        msg.setText(&#34;The syntax of your input is not correct.&#34;)
        msg.setIcon(QMessageBox.Warning)
        msg.setStandardButtons(QMessageBox.Retry)
        msg.setInformativeText(&#34;Please try again with another input string.&#34;)
        details = f&#34;Reminder - this is how you define a molecule: \n&#34;
        details = details + f&#34;- Carbon atoms are marked with &#39;C&#39; \n&#34;
        details = details + f&#34;- Single bonds are marked with &#39;-&#39; or no character at all \n&#34;
        details = details + f&#34;- Double bonds are marked with &#39;=&#39; \n&#34;
        details = details + f&#34;- Branches are embedded in round brackets (e.g. &#39;C(=CC=C)C&#39;)\n&#34;
        details = details + f&#34;- The two connecting atoms of a ring are marked with the same number (e.g. &#39;C1&#39; and &#39;C1&#39;) \n&#34;
        details = details + &#34;- Exterior nodes are marked with braces and a number (e.g. &#39;{=1}&#39;)&#34;
        msg.setDetailedText(details)
        x = msg.exec_()</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.submit_molecule_clicked_m"><code class="name flex">
<span>def <span class="ident">submit_molecule_clicked_m</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is called when user clicks button to submit the specified molecule in multi soliton widget.
Catches errors if user used the wrong syntax or specified a molecule that does not fulfill the requirements of a soliton graph.
If the user's molecule is valid it displays the graph of the molecule. It then also reveals a save button for the graph visualisation,
an info button and all the necessary widgets for the user to specify a set of bursts and a stop number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submit_molecule_clicked_m(self):
    &#34;&#34;&#34;Is called when user clicks button to submit the specified molecule in multi soliton widget.
    Catches errors if user used the wrong syntax or specified a molecule that does not fulfill the requirements of a soliton graph.
    If the user&#39;s molecule is valid it displays the graph of the molecule. It then also reveals a save button for the graph visualisation,
    an info button and all the necessary widgets for the user to specify a set of bursts and a stop number.
    &#34;&#34;&#34;
    self.smiles_string_m = self.molecule_lineedit_m.text()
    try:
        self.my_graph_m = SolitonGraph(self.smiles_string_m)
        errors = self.my_graph_m.validate_soliton_graph()
        self.graph_pic_m = Visualisation.visualize_soliton_graph(self.my_graph_m, self.my_graph_m.bindings, False, True)
        self.qim_m = ImageQt(self.graph_pic_m)
        self.display_molecule_m.setPixmap(QtGui.QPixmap.fromImage(self.qim_m).scaled(self.display_molecule_m.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
        self.set_of_bursts_lineedit.clear()
        if errors != []:
            self.hide_multiple([self.traversal_mode_m, self.save_m, self.mol_info_m, self.set_of_bursts_label, self.row4_m, self.row4_2_m, self.submit_set_of_bursts, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
            msg = QMessageBox(self.wid_mult)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
            msg.setWindowTitle(&#34;No soliton graph&#34;)
            msg.setText(&#34;You specified a molecule that does not fulfill the requirements of a soliton graph.&#34;)
            msg.setIcon(QMessageBox.Warning)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;See details for all incorrect parts of your molecule.&#34;)
            details = &#34;&#34;
            for i, error in enumerate(errors):
                if i == len(errors) - 1:
                    details = details + f&#34;- {error}&#34;
                else:
                    details = details + f&#34;- {error}&#34; + &#34;\n&#34;
            msg.setDetailedText(details)
            x = msg.exec_() # show messagebox
        elif self.my_graph_m.exterior_nodes_name_collision() == True:
            self.hide_multiple([self.traversal_mode_m, self.save_m, self.mol_info_m, self.set_of_bursts_label, self.row4_m, self.row4_2_m, self.submit_set_of_bursts, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
            msg = QMessageBox(self.wid_mult)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
            msg.setWindowTitle(&#34;Name collision&#34;)
            msg.setText(&#34;You specified two or more exterior nodes with the same name.&#34;)
            msg.setIcon(QMessageBox.Warning)
            msg.setStandardButtons(QMessageBox.Retry)
            x = msg.exec_()
        else:
            self.show_multiple([self.traversal_mode_m, self.save_m, self.set_of_bursts_label, self.row4_m, self.row4_2_m, self.submit_set_of_bursts])
            self.hide_multiple([self.mol_info_m, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
    except:
        self.hide_multiple([self.traversal_mode_m, self.save_m, self.mol_info_m, self.set_of_bursts_label, self.row4_m, self.row4_2_m, self.submit_set_of_bursts, self.mol_info_m, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
        msg = QMessageBox(self.wid_mult)
        msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
        msg.setWindowTitle(&#34;Incorrect input&#34;)
        msg.setText(&#34;The syntax of your input is not correct.&#34;)
        msg.setIcon(QMessageBox.Warning)
        msg.setStandardButtons(QMessageBox.Retry)
        msg.setInformativeText(&#34;Please try again with another input string.&#34;)
        details = f&#34;Reminder - this is how you define a molecule: \n&#34;
        details = details + f&#34;- Carbon atoms are marked with &#39;C&#39; \n&#34;
        details = details + f&#34;- Single bonds are marked with &#39;-&#39; or no character at all \n&#34;
        details = details + f&#34;- Double bonds are marked with &#39;=&#39; \n&#34;
        details = details + f&#34;- Branches are embedded in round brackets (e.g. &#39;C(=CC=C)C&#39;)\n&#34;
        details = details + f&#34;- The two connecting atoms of a ring are marked with the same number (e.g. &#39;C1&#39; and &#39;C1&#39;) \n&#34;
        details = details + &#34;- Exterior nodes are marked with braces and a number (e.g. &#39;{=1}&#39;)&#34;
        msg.setDetailedText(details)
        x = msg.exec_()</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.submit_set_of_bursts_clicked"><code class="name flex">
<span>def <span class="ident">submit_set_of_bursts_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that is called when user clicks button to submit a set of bursts.
Catches errors if user used the wrong syntax.
If the user's set of bursts is valid it all the necessary widgets for the user to choose a burst.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submit_set_of_bursts_clicked(self):
    &#34;&#34;&#34;Method that is called when user clicks button to submit a set of bursts.
    Catches errors if user used the wrong syntax.
    If the user&#39;s set of bursts is valid it all the necessary widgets for the user to choose a burst.
    &#34;&#34;&#34;
    bursts = self.set_of_bursts_lineedit.text()
    self.bursts = bursts
    self.burst.clear()
    self.stop_number_m = self.stop_number_spinbox_m.value()
    try:
        self.multi_automata = MultiwaveSolitonAutomata(self.my_graph_m, bursts, self.stop_number_m)
        bursts = bursts.split(&#34;;&#34;)
        for burst in bursts:
            burst = re.sub(r&#34;[{}]+&#34;, &#34;&#34;, burst)
            self.burst.addItem(burst)
        self.show_multiple([self.mol_info_m, self.bursts_label, self.row5_m, self.submit_burst])
        self.hide_multiple([self.traversals_label, self.traversals, self.if_loops_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
    except:
        self.hide_multiple([self.mol_info_m, self.bursts_label, self.row5_m, self.submit_burst, self.traversals_label, self.traversals, self.if_loops_m, self.row6_m, self.show_matrices_m, self.show_end_result_m, self.show_animation_m])
        msg = QMessageBox(self.wid_mult)
        msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px;}&#34;)
        msg.setWindowTitle(&#34;Incorrect input&#34;)
        msg.setText(&#34;The syntax of your input is not correct.&#34;)
        msg.setIcon(QMessageBox.Warning)
        msg.setStandardButtons(QMessageBox.Retry)
        msg.setInformativeText(&#34;Please try again with another input string.&#34;)
        details = f&#34;Reminder - this is how you define a set of bursts: \n&#34;
        details = details + f&#34;- Starting and end node of a soliton are embedded in round brackets (e.g. (3, 2))\n&#34;
        details = details + f&#34;- Solitons are seperated by &#39;||&#39;\n&#34;
        details = details + f&#34;- The number in front of a soliton&#39;s pair of exterior nodes defines how many timesteps later than the previous soliton this soliton enters the graph\n&#34;
        details = details + f&#34;- A set of bursts is embedded in braces, where individual bursts are seperated by &#39;;&#39;\n&#34;
        details = details + &#34;- Example: &#34; + &#34;{(3,1)||1(1,2); (3,2)||4(2,1)}\n&#34;
        msg.setDetailedText(details)
        x = msg.exec_()</code></pre>
</details>
</dd>
<dt id="soliton_automata.gui.main_window_ba.MainWindow.widthForHeight"><code class="name flex">
<span>def <span class="ident">widthForHeight</span></span>(<span>self, height)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes width for a given height.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code></dt>
<dd>Given height.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Computed width.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def widthForHeight(self, height):
    &#34;&#34;&#34;Computes width for a given height.

    Args:
        height (float): Given height.

    Returns:
        float: Computed width.
    &#34;&#34;&#34;
    width_for_height_factor = 1.0 * 688 / 519
    return math.ceil(height * width_for_height_factor)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="soliton_automata.gui" href="index.html">soliton_automata.gui</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="soliton_automata.gui.main_window_ba.MainWindow" href="#soliton_automata.gui.main_window_ba.MainWindow">MainWindow</a></code></h4>
<ul class="">
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.all_bursts_statechanged" href="#soliton_automata.gui.main_window_ba.MainWindow.all_bursts_statechanged">all_bursts_statechanged</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.all_exterior_nodes_statechanged" href="#soliton_automata.gui.main_window_ba.MainWindow.all_exterior_nodes_statechanged">all_exterior_nodes_statechanged</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.change_mode" href="#soliton_automata.gui.main_window_ba.MainWindow.change_mode">change_mode</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.change_mode_m" href="#soliton_automata.gui.main_window_ba.MainWindow.change_mode_m">change_mode_m</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.change_window" href="#soliton_automata.gui.main_window_ba.MainWindow.change_window">change_window</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.endless_loop_picked" href="#soliton_automata.gui.main_window_ba.MainWindow.endless_loop_picked">endless_loop_picked</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.endless_loop_picked_m" href="#soliton_automata.gui.main_window_ba.MainWindow.endless_loop_picked_m">endless_loop_picked_m</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.heightForWidth" href="#soliton_automata.gui.main_window_ba.MainWindow.heightForWidth">heightForWidth</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.hide_multiple" href="#soliton_automata.gui.main_window_ba.MainWindow.hide_multiple">hide_multiple</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.hide_retain_space" href="#soliton_automata.gui.main_window_ba.MainWindow.hide_retain_space">hide_retain_space</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.loops_onoff" href="#soliton_automata.gui.main_window_ba.MainWindow.loops_onoff">loops_onoff</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.loops_onoff_m" href="#soliton_automata.gui.main_window_ba.MainWindow.loops_onoff_m">loops_onoff_m</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.mol_info_clicked" href="#soliton_automata.gui.main_window_ba.MainWindow.mol_info_clicked">mol_info_clicked</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.mol_info_clicked_m" href="#soliton_automata.gui.main_window_ba.MainWindow.mol_info_clicked_m">mol_info_clicked_m</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.resizeEvent" href="#soliton_automata.gui.main_window_ba.MainWindow.resizeEvent">resizeEvent</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.retranslateUi" href="#soliton_automata.gui.main_window_ba.MainWindow.retranslateUi">retranslateUi</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.save_clicked" href="#soliton_automata.gui.main_window_ba.MainWindow.save_clicked">save_clicked</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.save_clicked_m" href="#soliton_automata.gui.main_window_ba.MainWindow.save_clicked_m">save_clicked_m</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.show_animation_clicked" href="#soliton_automata.gui.main_window_ba.MainWindow.show_animation_clicked">show_animation_clicked</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.show_end_result_clicked" href="#soliton_automata.gui.main_window_ba.MainWindow.show_end_result_clicked">show_end_result_clicked</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.show_end_result_clicked_m" href="#soliton_automata.gui.main_window_ba.MainWindow.show_end_result_clicked_m">show_end_result_clicked_m</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.show_matrices_clicked" href="#soliton_automata.gui.main_window_ba.MainWindow.show_matrices_clicked">show_matrices_clicked</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.show_matrices_clicked_m" href="#soliton_automata.gui.main_window_ba.MainWindow.show_matrices_clicked_m">show_matrices_clicked_m</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.show_multiple" href="#soliton_automata.gui.main_window_ba.MainWindow.show_multiple">show_multiple</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.stop_animation" href="#soliton_automata.gui.main_window_ba.MainWindow.stop_animation">stop_animation</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.submit_burst_clicked" href="#soliton_automata.gui.main_window_ba.MainWindow.submit_burst_clicked">submit_burst_clicked</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.submit_exterior_nodes_clicked" href="#soliton_automata.gui.main_window_ba.MainWindow.submit_exterior_nodes_clicked">submit_exterior_nodes_clicked</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.submit_molecule_clicked" href="#soliton_automata.gui.main_window_ba.MainWindow.submit_molecule_clicked">submit_molecule_clicked</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.submit_molecule_clicked_m" href="#soliton_automata.gui.main_window_ba.MainWindow.submit_molecule_clicked_m">submit_molecule_clicked_m</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.submit_set_of_bursts_clicked" href="#soliton_automata.gui.main_window_ba.MainWindow.submit_set_of_bursts_clicked">submit_set_of_bursts_clicked</a></code></li>
<li><code><a title="soliton_automata.gui.main_window_ba.MainWindow.widthForHeight" href="#soliton_automata.gui.main_window_ba.MainWindow.widthForHeight">widthForHeight</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>