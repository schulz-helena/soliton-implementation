<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mini_soliton_automata.gui.main_window API documentation</title>
<meta name="description" content="GUI of the software." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mini_soliton_automata.gui.main_window</code></h1>
</header>
<section id="section-intro">
<p>GUI of the software.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;GUI of the software.
 &#34;&#34;&#34;
import io
import math
import re

import mini_soliton_automata.res.resources
from mini_soliton_automata.gui.startscreen import Startscreen
from mini_soliton_automata.soliton_classes.soliton_automata import \
    MiniSolitonAutomata
from mini_soliton_automata.soliton_classes.soliton_graph import SolitonGraph
from mini_soliton_automata.soliton_classes.soliton_path import SolitonPath
from mini_soliton_automata.visualisations.animation import Animation
from mini_soliton_automata.visualisations.visualisation import Visualisation
from PIL.ImageQt import ImageQt
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QDialog, QMainWindow, QMessageBox, QScrollArea


class MainWindow(QMainWindow):
    &#34;&#34;&#34;Main Window of the GUI. Inherits from class `QMainWindow`.
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;Initializes the main window.
        Displays a welcoming text and all necessary widgets for the user to specify and submit a molecule.
        All other widgets are hidden for now and are revealed step by step, so user is guided through the use of the application.
        &#34;&#34;&#34;
        super(MainWindow, self).__init__()
        self.setObjectName(&#34;MainWindow&#34;)
        # move window to the top of the screen + to the center horizontally
        qt_rectangle = self.frameGeometry()
        center_point = QtWidgets.QDesktopWidget().availableGeometry().center()
        qt_rectangle.moveCenter(center_point)
        self.move(qt_rectangle.topLeft().x(), 0)

        self.centralwidget = QtWidgets.QWidget(self)
        self.centralwidget.setObjectName(&#34;centralwidget&#34;)
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName(&#34;gridLayout&#34;)
        self.show_animation = QtWidgets.QPushButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.show_animation.sizePolicy().hasHeightForWidth())
        self.show_animation.setSizePolicy(sizePolicy)
        self.show_animation.setMinimumSize(QtCore.QSize(0, 32))
        self.show_animation.setObjectName(&#34;show_animation&#34;)
        self.gridLayout.addWidget(self.show_animation, 6, 4, 1, 1)
        self.exterior_nodes_label2 = QtWidgets.QLabel(self.centralwidget)
        self.exterior_nodes_label2.setObjectName(&#34;exterior_nodes_label2&#34;)
        self.gridLayout.addWidget(self.exterior_nodes_label2, 4, 2, 1, 1)
        self.show_end_result = QtWidgets.QPushButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.show_end_result.sizePolicy().hasHeightForWidth())
        self.show_end_result.setSizePolicy(sizePolicy)
        self.show_end_result.setMinimumSize(QtCore.QSize(0, 32))
        self.show_end_result.setObjectName(&#34;show_end_result&#34;)
        self.gridLayout.addWidget(self.show_end_result, 6, 2, 1, 2)
        self.save = QtWidgets.QPushButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.save.sizePolicy().hasHeightForWidth())
        self.save.setSizePolicy(sizePolicy)
        self.save.setMaximumSize(QtCore.QSize(16777215, 32))
        self.save.setMinimumSize(QtCore.QSize(0, 32))
        self.save.setObjectName(&#34;save&#34;)
        self.gridLayout.addWidget(self.save, 2, 4, 1, 1)
        self.molecule_lineedit = QtWidgets.QLineEdit(self.centralwidget)
        self.molecule_lineedit.setObjectName(&#34;molecule_lineedit&#34;)
        self.gridLayout.addWidget(self.molecule_lineedit, 3, 1, 1, 3)
        self.show_matrices = QtWidgets.QPushButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.show_matrices.sizePolicy().hasHeightForWidth())
        self.show_matrices.setSizePolicy(sizePolicy)
        self.show_matrices.setMinimumSize(QtCore.QSize(0, 32))
        self.show_matrices.setObjectName(&#34;show_matrices&#34;)
        self.gridLayout.addWidget(self.show_matrices, 6, 1, 1, 1)
        self.molecule_label = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(14)
        self.molecule_label.setFont(font)
        self.molecule_label.setObjectName(&#34;molecule_label&#34;)
        self.gridLayout.addWidget(self.molecule_label, 3, 0, 1, 1)
        self.node_2 = QtWidgets.QComboBox(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.node_2.sizePolicy().hasHeightForWidth())
        self.node_2.setSizePolicy(sizePolicy)
        self.node_2.setObjectName(&#34;node_2&#34;)
        self.gridLayout.addWidget(self.node_2, 4, 3, 1, 1)
        self.soliton_paths_label = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(14)
        self.soliton_paths_label.setFont(font)
        self.soliton_paths_label.setObjectName(&#34;soliton_paths_label&#34;)
        self.gridLayout.addWidget(self.soliton_paths_label, 5, 0, 1, 1)
        self.paths = QtWidgets.QComboBox(self.centralwidget)
        self.paths.setObjectName(&#34;paths&#34;)
        self.gridLayout.addWidget(self.paths, 5, 1, 1, 4)
        self.submit_exterior_nodes = QtWidgets.QPushButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.submit_exterior_nodes.sizePolicy().hasHeightForWidth())
        self.submit_exterior_nodes.setSizePolicy(sizePolicy)
        self.submit_exterior_nodes.setMinimumSize(QtCore.QSize(0, 32))
        self.submit_exterior_nodes.setObjectName(&#34;submit_exterior_nodes&#34;)
        self.gridLayout.addWidget(self.submit_exterior_nodes, 4, 4, 1, 1)
        self.node_1 = QtWidgets.QComboBox(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.node_1.sizePolicy().hasHeightForWidth())
        self.node_1.setSizePolicy(sizePolicy)
        self.node_1.setObjectName(&#34;node_1&#34;)
        self.gridLayout.addWidget(self.node_1, 4, 1, 1, 1)
        self.exterior_nodes_label = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(14)
        self.exterior_nodes_label.setFont(font)
        self.exterior_nodes_label.setObjectName(&#34;exterior_nodes_label&#34;)
        self.gridLayout.addWidget(self.exterior_nodes_label, 4, 0, 1, 1)
        self.submit_molecule = QtWidgets.QPushButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.submit_molecule.sizePolicy().hasHeightForWidth())
        self.submit_molecule.setSizePolicy(sizePolicy)
        self.submit_molecule.setMinimumSize(QtCore.QSize(0, 32))
        self.submit_molecule.setObjectName(&#34;submit_molecule&#34;)
        self.gridLayout.addWidget(self.submit_molecule, 3, 4, 1, 1)

        self.display_molecule = QtWidgets.QLabel(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Ignored)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setWidthForHeight(self.display_molecule.sizePolicy().hasWidthForHeight())
        self.display_molecule.setSizePolicy(sizePolicy)
        self.display_molecule.setMinimumSize(QtCore.QSize(600, 450))
        self.display_molecule.setSizeIncrement(QtCore.QSize(0, 0))
        self.display_molecule.setBaseSize(QtCore.QSize(0, 0))
        self.display_molecule.setText(&#34;&#34;)
        startscreen = Startscreen().image
        self.qim = ImageQt(startscreen)
        self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(self.display_molecule.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
        self.display_molecule.setObjectName(&#34;display_molecule&#34;)
        self.gridLayout.addWidget(self.display_molecule, 0, 0, 2, 5, alignment = QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter)
        self.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(self)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 564, 24))
        self.menubar.setObjectName(&#34;menubar&#34;)
        self.setMenuBar(self.menubar)

        self.retranslateUi()
        QtCore.QMetaObject.connectSlotsByName(self)

        self.height_for_width_factor = 1.0 * 519 / 688
        self.width_for_height_factor = 1.0 * 688 / 519

        self.submit_molecule.clicked.connect(self.submit_molecule_clicked)
        self.submit_exterior_nodes.clicked.connect(self.submit_exterior_nodes_clicked)
        self.show_matrices.clicked.connect(self.show_matrices_clicked)
        self.show_end_result.clicked.connect(self.show_end_result_clicked)
        self.show_animation.clicked.connect(self.show_animation_clicked)
        self.save.clicked.connect(self.save_clicked)

        self.hide_retain_space(self.save)
        self.save.hide()
        self.hide_retain_space(self.exterior_nodes_label)
        self.exterior_nodes_label.hide()
        self.hide_retain_space(self.exterior_nodes_label2)
        self.exterior_nodes_label2.hide()
        self.hide_retain_space(self.node_1)
        self.node_1.hide()
        self.hide_retain_space(self.node_2)
        self.node_2.hide()
        self.hide_retain_space(self.submit_exterior_nodes)
        self.submit_exterior_nodes.hide()
        self.hide_retain_space(self.soliton_paths_label)
        self.soliton_paths_label.hide()
        self.hide_retain_space(self.paths)
        self.paths.hide()
        self.hide_retain_space(self.show_matrices)
        self.show_matrices.hide()
        self.hide_retain_space(self.show_end_result)
        self.show_end_result.hide()
        self.hide_retain_space(self.show_animation)
        self.show_animation.hide()


    def retranslateUi(self):
        &#34;&#34;&#34;Implements multi-language suppport. Is generated automatically when using PyQt5 UI code generator.
        &#34;&#34;&#34;
        _translate = QtCore.QCoreApplication.translate
        self.setWindowTitle(_translate(&#34;MainWindow&#34;, &#34;Mini Soliton Automata Software&#34;))
        self.show_animation.setText(_translate(&#34;MainWindow&#34;, &#34;Show animation&#34;))
        self.exterior_nodes_label2.setText(_translate(&#34;MainWindow&#34;, &#34;&amp;&#34;))
        self.show_end_result.setText(_translate(&#34;MainWindow&#34;, &#34;Show end result&#34;))
        self.save.setText(_translate(&#34;MainWindow&#34;, &#34;Save&#34;))
        self.show_matrices.setText(_translate(&#34;MainWindow&#34;, &#34;Show matrices&#34;))
        self.molecule_label.setText(_translate(&#34;MainWindow&#34;, &#34;Molecule:&#34;))
        self.soliton_paths_label.setText(_translate(&#34;MainWindow&#34;, &#34;Soliton paths:&#34;))
        self.submit_exterior_nodes.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
        self.exterior_nodes_label.setText(_translate(&#34;MainWindow&#34;, &#34;Exterior nodes:&#34;))
        self.submit_molecule.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))


    def submit_molecule_clicked(self):
        &#34;&#34;&#34;Method that is called when user clicks button to submit the specified molecule.
        Catches errors if user used the wrong syntax or specified a molecule that does not fulfill the requirements of a soliton graph.
        If the user&#39;s molecule is valid it displays the graph of the molecule. It then also reveals a save button for the graph visualisation and
        all the necessary widgets for the user to choose a pair of exterior nodes.
        &#34;&#34;&#34;
        self.node_1.clear()
        self.node_2.clear()
        self.smiles_string = self.molecule_lineedit.text()
        try:
            self.my_graph = SolitonGraph(self.smiles_string)
            errors = self.my_graph.validate_soliton_graph()
            self.graph_pic = Visualisation.visualize_soliton_graph(self.my_graph, self.my_graph.bindings, False, True)
            self.qim = ImageQt(self.graph_pic)
            self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(self.display_molecule.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
            if errors != []:
                self.save.hide()
                self.exterior_nodes_label.hide()
                self.exterior_nodes_label2.hide()
                self.node_1.hide()
                self.node_2.hide()
                self.submit_exterior_nodes.hide()
                self.soliton_paths_label.hide()
                self.paths.hide()
                self.show_matrices.hide()
                self.show_end_result.hide()
                self.show_animation.hide()
                msg = QMessageBox()
                msg.setWindowTitle(&#34;No soliton graph&#34;)
                msg.setText(&#34;You specified a molecule that does not fulfill the requirements of a soliton graph&#34;)
                msg.setIcon(QMessageBox.Warning)
                msg.setStandardButtons(QMessageBox.Retry)
                msg.setInformativeText(&#34;See details for all incorrect parts of your molecule.&#34;)
                msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px;}&#34;)
                details = &#34;&#34;
                for i, error in enumerate(errors):
                    if i == len(errors) - 1:
                        details = details + error
                    else:
                        details = details + error + &#34;\n&#34;
                msg.setDetailedText(details)
                x = msg.exec_() # show messagebox
            elif self.my_graph.exterior_nodes_name_collision() == True:
                self.save.hide()
                self.exterior_nodes_label.hide()
                self.exterior_nodes_label2.hide()
                self.node_1.hide()
                self.node_2.hide()
                self.submit_exterior_nodes.hide()
                self.soliton_paths_label.hide()
                self.paths.hide()
                self.show_matrices.hide()
                self.show_end_result.hide()
                self.show_animation.hide()
                msg = QMessageBox()
                msg.setWindowTitle(&#34;Name collision&#34;)
                msg.setText(&#34;You specified two or more exterior nodes with the same name&#34;)
                msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
                msg.setIcon(QMessageBox.Warning)
                msg.setStandardButtons(QMessageBox.Retry)
                x = msg.exec_()
            else:
                self.save.show()
                self.exterior_nodes_label.show()
                self.exterior_nodes_label2.show()
                self.node_1.show()
                self.node_2.show()
                self.submit_exterior_nodes.show()
                self.soliton_paths_label.hide()
                self.paths.hide()
                self.show_matrices.hide()
                self.show_end_result.hide()
                self.show_animation.hide()
                for key in self.my_graph.exterior_nodes_reverse:
                    self.node_1.addItem(key)
                    self.node_2.addItem(key)
        except:
            self.save.hide()
            self.exterior_nodes_label.hide()
            self.exterior_nodes_label2.hide()
            self.node_1.hide()
            self.node_2.hide()
            self.submit_exterior_nodes.hide()
            self.soliton_paths_label.hide()
            self.paths.hide()
            self.show_matrices.hide()
            self.show_end_result.hide()
            self.show_animation.hide()
            msg = QMessageBox()
            msg.setWindowTitle(&#34;Incorrect input&#34;)
            msg.setText(&#34;The syntax of your input is not correct&#34;)
            msg.setIcon(QMessageBox.Warning)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;Please try again with another input string.&#34;)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
            details = f&#34;Reminder - this is how you define a molecule: \n&#34;
            details = details + f&#34;- Carbon atoms are marked with &#39;C&#39; \n&#34;
            details = details + f&#34;- Single edges are marked with &#39;-&#39; or no character at all \n&#34;
            details = details + f&#34;- Double edges are marked with &#39;=&#39; \n&#34;
            details = details + f&#34;- The two connecting atoms of a ring are marked with the same number (e.g. &#39;C1&#39; and &#39;C1&#39;) \n&#34;
            details = details + &#34;- Exterior nodes are marked with braces and a number (e.g. &#39;{1}&#39;)&#34;
            msg.setDetailedText(details)
            x = msg.exec_()


    def save_clicked(self):
        &#34;&#34;&#34;Method that is called when user clicks button to save the graph visualisation.
        Opens a file dialog in which user can specify a path where the image should be saved.
        Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
        &#34;&#34;&#34;
        option = QtWidgets.QFileDialog.Options()
        name = QtWidgets.QFileDialog.getSaveFileName(self.centralwidget, &#39;Save File&#39;, &#39;graph.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
        if name != (&#39;&#39;, &#39;&#39;):
            path = name[0]
            # turn PIL Image into byte array 
            imgByteArr = io.BytesIO()
            self.graph_pic.save(imgByteArr, format=&#39;PNG&#39;)
            imgByteArr = imgByteArr.getvalue()
            # save image at specified path
            file = open(path, &#34;wb&#34;)
            file.write(imgByteArr) # before: file.write(data)
            file.close()


    def submit_exterior_nodes_clicked(self):
        &#34;&#34;&#34;Method that is called when user clicks button to submit a pair of exterior nodes.
        Computes all possible soliton paths between the two chosen nodes.
        Informs the user if no soliton path exists between them.
        Otherwise all the necessary widgets for the user to choose a computed soliton path and look at further information on it are revealed.
        &#34;&#34;&#34;
        self.path_index = None # we need this variable later in show_animation_clicked
        self.paths.clear()
        node1 = int(self.node_1.currentText())
        node2 = int(self.node_2.currentText())
        self.automata = MiniSolitonAutomata(self.my_graph, node1, node2)
        if self.automata.soliton_paths == []:
            self.soliton_paths_label.hide()
            self.paths.hide()
            self.show_matrices.hide()
            self.show_end_result.hide()
            self.show_animation.hide()
            msg = QMessageBox()
            msg.setWindowTitle(&#34;No path found&#34;)
            msg.setText(&#34;There exists no soliton path between these exterior nodes.&#34;)
            msg.setIcon(QMessageBox.Information)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;Please try again with different exterior nodes.&#34;)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
            x = msg.exec_()
        else:
            self.soliton_paths_label.setText(f&#34;Soliton paths ({len(self.automata.soliton_paths)}):&#34;)
            self.soliton_paths_label.show()
            self.paths.show()
            self.show_matrices.show()
            self.show_end_result.show()
            self.show_animation.show()
            for soliton_path in self.automata.soliton_paths:
                self.paths.addItem(str(soliton_path.path_for_user))
    

    def show_matrices_clicked(self):
        &#34;&#34;&#34;Method that is called when user clicks button to have the adjacency matrices of every timestep displayed.
        Makes a small window pop up that shows the labelled adjacency matrices and provides a save button.
        &#34;&#34;&#34;

        def save_matrices():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where a text file with all adjacency matrices should be saved.
            Text file also contains the input string representing the molecule and the soliton path.
            Only allows `.txt` file suffix.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.centralwidget, &#39;Save File&#39;, &#39;matrices.txt&#39;, &#39;Text files (*.txt)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;): # only do the following if user clicked on save button (without this line the application closes with an error if save action is cancelled)
                path = name[0]
                file = open(path, &#34;w&#34;)
                file.write(txt_text)
                file.close()

        index = self.paths.currentIndex()
        desired_path = self.automata.soliton_paths[index]
    
        dlg = QDialog()
        scrollArea = QScrollArea(dlg)
        widget = QtWidgets.QWidget()
        vbox = QtWidgets.QVBoxLayout()
        txt_text = f&#34;Molecule: {self.smiles_string} \n&#34;
        txt_text = txt_text + f&#34;Soliton path: {desired_path.path_for_user} \n \n&#34;
        # labelling of matrix depends on wether we have long node labels (&#34;aa&#34;, &#34;ab&#34;, ...) or short ones (&#34;a&#34;, &#34;b&#34;, ...)
        if (len(self.my_graph.labels) - len(self.my_graph.exterior_nodes)) &gt; 26:
            matrix_label_horizontal = &#34;    &#34;
            long_labels = True
        else:
            matrix_label_horizontal = &#34;   &#34;
            long_labels = False
        for key in self.my_graph.labels:
            if long_labels:
                if self.my_graph.labels[key] in self.my_graph.exterior_nodes_reverse:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]}  &#34;
                else:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]} &#34;
            else:
                matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]}  &#34;
        # for show-matrices-window the node labels are added to the matrix string and this labelled matrix is added to scroll area
        # for matrices.txt we add everything (horizontal label and every row of matrix) line by line
        for i in range(len(desired_path.adjacency_matrices_list)):
            txt_text = txt_text + f&#34;Timestep {i}: \n&#34;
            txt_text = txt_text + f&#34;{matrix_label_horizontal} \n&#34;
            matrix_labelled = &#34;&#34;
            matrix_labelled = matrix_labelled + f&#34;{matrix_label_horizontal}\n&#34;
            matrix = str(desired_path.adjacency_matrices_list[i])
            matrix = re.sub(r&#34;[matrix(]&#34;, &#34;&#34;, matrix)
            matrix = re.sub(r&#34;[)]&#34;, &#34;&#34;, matrix)
            for j in range(len(matrix.splitlines())):
                if long_labels:
                    if self.my_graph.labels[j] in self.my_graph.exterior_nodes_reverse:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]} {matrix.splitlines()[j]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph.labels[j]} {matrix.splitlines()[j]} \n&#34;
                    else:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
                else:
                    matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
                    txt_text = txt_text + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
            txt_text = txt_text + f&#34;\n&#34;
            vbox.addWidget(QtWidgets.QLabel(matrix_labelled))
        widget.setLayout(vbox)
        scrollArea.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        scrollArea.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        scrollArea.setWidgetResizable(True)
        scrollArea.setWidget(widget)
        scrollArea.setStyleSheet(&#34;font: 13pt Courier;&#34;)
        scrollArea.setFixedSize(540, 405)
        save_button = QtWidgets.QPushButton(&#34;Save&#34;, dlg)
        save_button.setGeometry(QtCore.QRect(454, 359, 70, 30))
        save_button.clicked.connect(save_matrices)

        dlg.setWindowTitle(&#34;Adjacency Matrices&#34;)
        dlg.setFixedSize(545, 410)
        dlg.exec_()
    

    def show_end_result_clicked(self):
        &#34;&#34;&#34;Method that is called when user clicks button to have the resulting graph (after soliton path is traversed) displayed.
        Makes a small window pop up that shows the graph visualisation and provides a save button.
        &#34;&#34;&#34;

        def save_end_result():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where the resulting graph should be saved.
            Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.centralwidget, &#39;Save File&#39;, &#39;result.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;):
                path = name[0]
                imgByteArr = io.BytesIO()
                result_pic.save(imgByteArr, format=&#39;PNG&#39;)
                imgByteArr = imgByteArr.getvalue()
                file = open(path, &#34;wb&#34;)
                file.write(imgByteArr)
                file.close()

        index = self.paths.currentIndex()
        desired_path = self.automata.soliton_paths[index]
        bindings_index = len(desired_path.path) - 1
        result_pic = Visualisation.visualize_soliton_graph(self.my_graph, desired_path.bindings_list[bindings_index], False, True)
        qim = ImageQt(result_pic)

        dlg = QDialog()
        label = QtWidgets.QLabel(dlg)
        label.setGeometry(QtCore.QRect(0, 0, 540, 405))
        label.setPixmap(QtGui.QPixmap.fromImage(qim))
        label.setScaledContents(True)
        save_button = QtWidgets.QPushButton(&#34;Save&#34;, dlg)
        save_button.setGeometry(QtCore.QRect(470, 375, 70, 30))
        save_button.clicked.connect(save_end_result)

        dlg.setWindowTitle(&#34;End result&#34;)
        dlg.setFixedSize(545, 410)
        dlg.exec_()


    def show_animation_clicked(self):
        &#34;&#34;&#34;Method that is called when user clicks button to have the animation of the soliton traversing the graph displayed.
        Makes a small window pop up that shows the animation and provides a save button.
        Instead of displaying the `gif` it uses a sequence of `PIL` images and always shows the next image after a certain time.
        &#34;&#34;&#34;
        
        def save_animation():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where the animation should be saved.
            Only allows `.gif` file suffix.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.centralwidget, &#39;Save File&#39;, &#39;animation.gif&#39;, &#39;Images (*.gif)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;):
                path = name[0]
                ani = self.my_animation.graph_animation()
                ani.save(path, writer=&#39;ffmpeg&#39;)

        dlg = QDialog()
        label = QtWidgets.QLabel(dlg)
        label.setGeometry(QtCore.QRect(0, 0, 540, 405))
        
        if self.path_index != self.paths.currentIndex():
            self.path_index = self.paths.currentIndex()
            self.desired_path = self.automata.soliton_paths[self.path_index]
            self.my_animation = Animation(self.my_graph, self.desired_path)
            self.pil_images = self.my_animation.pil_images

        self.step = 0
        self.timer = QtCore.QTimer(self)
        self.timer.timeout.connect(lambda: self.update_image(label, self.pil_images, self.desired_path))
        self.timer.start(800) # triggers event every 800 milliseconds
        self.update_image(label, self.pil_images, self.desired_path)
        save_button = QtWidgets.QPushButton(&#34;Save&#34;, dlg)
        save_button.setGeometry(QtCore.QRect(470, 375, 70, 30))
        save_button.clicked.connect(save_animation)

        dlg.setWindowTitle(&#34;Animation&#34;)
        dlg.setFixedSize(545, 410)
        dlg.closeEvent = self.stop_animation # stop timer when window is closed
        dlg.exec_()
    

    def update_image(self, label: QtWidgets.QLabel, pil_images: list, desired_path: SolitonPath):
        &#34;&#34;&#34;Displays next image of animation after a certain time (method is triggered by a timer).

        Args:
            label (QtWidgets.QLabel): Displays the animation&#39;s images.
            pil_images (list): `PIL` images that should be displayed step by step.
            desired_path (SolitonPath): Soliton path that is traversed in animation.
        &#34;&#34;&#34;
        im = pil_images[self.step]
        qim = ImageQt(im)
        label.setPixmap(QtGui.QPixmap.fromImage(qim))
        label.setScaledContents(True)
        self.step += 1
        if self.step == len(desired_path.path): # start animation all over again as soon as end is reached (endless loop)
            self.step = 0


    def stop_animation(self, event):
        &#34;&#34;&#34;Stops the timer that is used for the animation.
        Without this method the application would crash if the animation window would get closed.
        Args:
            event: Close event of the window that shows animation.
        &#34;&#34;&#34;
        self.timer.disconnect()


    def hide_retain_space(self, widget):
        &#34;&#34;&#34;Retains the space of a widget even when it&#39;s hidden.

        Args:
            widget (QtWidgets.QWidget ): Widget whose space should be retained.
        &#34;&#34;&#34;
        retain = widget.sizePolicy()
        retain.setRetainSizeWhenHidden(True)
        widget.setSizePolicy(retain)


    def heightForWidth(self, width: float):
        &#34;&#34;&#34;Computes height for a given width.

        Args:
            width (float): Given width.

        Returns:
            float: Computed height.
        &#34;&#34;&#34;
        return math.ceil(width * self.height_for_width_factor)


    def widthForHeight(self, height):
        &#34;&#34;&#34;Computes width for a given height.

        Args:
            height (float): Given height.

        Returns:
            float: Computed width.
        &#34;&#34;&#34;
        return math.ceil(height * self.width_for_height_factor)


    def resizeEvent(self, event: QtGui.QResizeEvent):
        &#34;&#34;&#34;Keeps the right aspect ratio of the graph visualisation image (or welcoming screen in the beginning) when window is resized.

        Args:
            event (QtGui.QResizeEvent): Resize event.
        &#34;&#34;&#34;
        super(MainWindow, self).resizeEvent(event)
        size = event.size()
        # window height minus height of all widgets below the label result in height of pixmap
        height = size.height() - self.save.height() - self.submit_molecule.height() - self.submit_exterior_nodes.height() - self.paths.height() - self.show_animation.height()
        if self.widthForHeight(height) &gt; size.width(): # pixmap width should be as most as big as width of whole window
            width = size.width()
        else:
            width = self.widthForHeight(height)
        self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(width, height, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mini_soliton_automata.gui.main_window.MainWindow"><code class="flex name class">
<span>class <span class="ident">MainWindow</span></span>
</code></dt>
<dd>
<div class="desc"><p>Main Window of the GUI. Inherits from class <code>QMainWindow</code>.</p>
<p>Initializes the main window.
Displays a welcoming text and all necessary widgets for the user to specify and submit a molecule.
All other widgets are hidden for now and are revealed step by step, so user is guided through the use of the application.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MainWindow(QMainWindow):
    &#34;&#34;&#34;Main Window of the GUI. Inherits from class `QMainWindow`.
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;Initializes the main window.
        Displays a welcoming text and all necessary widgets for the user to specify and submit a molecule.
        All other widgets are hidden for now and are revealed step by step, so user is guided through the use of the application.
        &#34;&#34;&#34;
        super(MainWindow, self).__init__()
        self.setObjectName(&#34;MainWindow&#34;)
        # move window to the top of the screen + to the center horizontally
        qt_rectangle = self.frameGeometry()
        center_point = QtWidgets.QDesktopWidget().availableGeometry().center()
        qt_rectangle.moveCenter(center_point)
        self.move(qt_rectangle.topLeft().x(), 0)

        self.centralwidget = QtWidgets.QWidget(self)
        self.centralwidget.setObjectName(&#34;centralwidget&#34;)
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName(&#34;gridLayout&#34;)
        self.show_animation = QtWidgets.QPushButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.show_animation.sizePolicy().hasHeightForWidth())
        self.show_animation.setSizePolicy(sizePolicy)
        self.show_animation.setMinimumSize(QtCore.QSize(0, 32))
        self.show_animation.setObjectName(&#34;show_animation&#34;)
        self.gridLayout.addWidget(self.show_animation, 6, 4, 1, 1)
        self.exterior_nodes_label2 = QtWidgets.QLabel(self.centralwidget)
        self.exterior_nodes_label2.setObjectName(&#34;exterior_nodes_label2&#34;)
        self.gridLayout.addWidget(self.exterior_nodes_label2, 4, 2, 1, 1)
        self.show_end_result = QtWidgets.QPushButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.show_end_result.sizePolicy().hasHeightForWidth())
        self.show_end_result.setSizePolicy(sizePolicy)
        self.show_end_result.setMinimumSize(QtCore.QSize(0, 32))
        self.show_end_result.setObjectName(&#34;show_end_result&#34;)
        self.gridLayout.addWidget(self.show_end_result, 6, 2, 1, 2)
        self.save = QtWidgets.QPushButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.save.sizePolicy().hasHeightForWidth())
        self.save.setSizePolicy(sizePolicy)
        self.save.setMaximumSize(QtCore.QSize(16777215, 32))
        self.save.setMinimumSize(QtCore.QSize(0, 32))
        self.save.setObjectName(&#34;save&#34;)
        self.gridLayout.addWidget(self.save, 2, 4, 1, 1)
        self.molecule_lineedit = QtWidgets.QLineEdit(self.centralwidget)
        self.molecule_lineedit.setObjectName(&#34;molecule_lineedit&#34;)
        self.gridLayout.addWidget(self.molecule_lineedit, 3, 1, 1, 3)
        self.show_matrices = QtWidgets.QPushButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.show_matrices.sizePolicy().hasHeightForWidth())
        self.show_matrices.setSizePolicy(sizePolicy)
        self.show_matrices.setMinimumSize(QtCore.QSize(0, 32))
        self.show_matrices.setObjectName(&#34;show_matrices&#34;)
        self.gridLayout.addWidget(self.show_matrices, 6, 1, 1, 1)
        self.molecule_label = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(14)
        self.molecule_label.setFont(font)
        self.molecule_label.setObjectName(&#34;molecule_label&#34;)
        self.gridLayout.addWidget(self.molecule_label, 3, 0, 1, 1)
        self.node_2 = QtWidgets.QComboBox(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.node_2.sizePolicy().hasHeightForWidth())
        self.node_2.setSizePolicy(sizePolicy)
        self.node_2.setObjectName(&#34;node_2&#34;)
        self.gridLayout.addWidget(self.node_2, 4, 3, 1, 1)
        self.soliton_paths_label = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(14)
        self.soliton_paths_label.setFont(font)
        self.soliton_paths_label.setObjectName(&#34;soliton_paths_label&#34;)
        self.gridLayout.addWidget(self.soliton_paths_label, 5, 0, 1, 1)
        self.paths = QtWidgets.QComboBox(self.centralwidget)
        self.paths.setObjectName(&#34;paths&#34;)
        self.gridLayout.addWidget(self.paths, 5, 1, 1, 4)
        self.submit_exterior_nodes = QtWidgets.QPushButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.submit_exterior_nodes.sizePolicy().hasHeightForWidth())
        self.submit_exterior_nodes.setSizePolicy(sizePolicy)
        self.submit_exterior_nodes.setMinimumSize(QtCore.QSize(0, 32))
        self.submit_exterior_nodes.setObjectName(&#34;submit_exterior_nodes&#34;)
        self.gridLayout.addWidget(self.submit_exterior_nodes, 4, 4, 1, 1)
        self.node_1 = QtWidgets.QComboBox(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.node_1.sizePolicy().hasHeightForWidth())
        self.node_1.setSizePolicy(sizePolicy)
        self.node_1.setObjectName(&#34;node_1&#34;)
        self.gridLayout.addWidget(self.node_1, 4, 1, 1, 1)
        self.exterior_nodes_label = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(14)
        self.exterior_nodes_label.setFont(font)
        self.exterior_nodes_label.setObjectName(&#34;exterior_nodes_label&#34;)
        self.gridLayout.addWidget(self.exterior_nodes_label, 4, 0, 1, 1)
        self.submit_molecule = QtWidgets.QPushButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.submit_molecule.sizePolicy().hasHeightForWidth())
        self.submit_molecule.setSizePolicy(sizePolicy)
        self.submit_molecule.setMinimumSize(QtCore.QSize(0, 32))
        self.submit_molecule.setObjectName(&#34;submit_molecule&#34;)
        self.gridLayout.addWidget(self.submit_molecule, 3, 4, 1, 1)

        self.display_molecule = QtWidgets.QLabel(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Ignored)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setWidthForHeight(self.display_molecule.sizePolicy().hasWidthForHeight())
        self.display_molecule.setSizePolicy(sizePolicy)
        self.display_molecule.setMinimumSize(QtCore.QSize(600, 450))
        self.display_molecule.setSizeIncrement(QtCore.QSize(0, 0))
        self.display_molecule.setBaseSize(QtCore.QSize(0, 0))
        self.display_molecule.setText(&#34;&#34;)
        startscreen = Startscreen().image
        self.qim = ImageQt(startscreen)
        self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(self.display_molecule.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
        self.display_molecule.setObjectName(&#34;display_molecule&#34;)
        self.gridLayout.addWidget(self.display_molecule, 0, 0, 2, 5, alignment = QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter)
        self.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(self)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 564, 24))
        self.menubar.setObjectName(&#34;menubar&#34;)
        self.setMenuBar(self.menubar)

        self.retranslateUi()
        QtCore.QMetaObject.connectSlotsByName(self)

        self.height_for_width_factor = 1.0 * 519 / 688
        self.width_for_height_factor = 1.0 * 688 / 519

        self.submit_molecule.clicked.connect(self.submit_molecule_clicked)
        self.submit_exterior_nodes.clicked.connect(self.submit_exterior_nodes_clicked)
        self.show_matrices.clicked.connect(self.show_matrices_clicked)
        self.show_end_result.clicked.connect(self.show_end_result_clicked)
        self.show_animation.clicked.connect(self.show_animation_clicked)
        self.save.clicked.connect(self.save_clicked)

        self.hide_retain_space(self.save)
        self.save.hide()
        self.hide_retain_space(self.exterior_nodes_label)
        self.exterior_nodes_label.hide()
        self.hide_retain_space(self.exterior_nodes_label2)
        self.exterior_nodes_label2.hide()
        self.hide_retain_space(self.node_1)
        self.node_1.hide()
        self.hide_retain_space(self.node_2)
        self.node_2.hide()
        self.hide_retain_space(self.submit_exterior_nodes)
        self.submit_exterior_nodes.hide()
        self.hide_retain_space(self.soliton_paths_label)
        self.soliton_paths_label.hide()
        self.hide_retain_space(self.paths)
        self.paths.hide()
        self.hide_retain_space(self.show_matrices)
        self.show_matrices.hide()
        self.hide_retain_space(self.show_end_result)
        self.show_end_result.hide()
        self.hide_retain_space(self.show_animation)
        self.show_animation.hide()


    def retranslateUi(self):
        &#34;&#34;&#34;Implements multi-language suppport. Is generated automatically when using PyQt5 UI code generator.
        &#34;&#34;&#34;
        _translate = QtCore.QCoreApplication.translate
        self.setWindowTitle(_translate(&#34;MainWindow&#34;, &#34;Mini Soliton Automata Software&#34;))
        self.show_animation.setText(_translate(&#34;MainWindow&#34;, &#34;Show animation&#34;))
        self.exterior_nodes_label2.setText(_translate(&#34;MainWindow&#34;, &#34;&amp;&#34;))
        self.show_end_result.setText(_translate(&#34;MainWindow&#34;, &#34;Show end result&#34;))
        self.save.setText(_translate(&#34;MainWindow&#34;, &#34;Save&#34;))
        self.show_matrices.setText(_translate(&#34;MainWindow&#34;, &#34;Show matrices&#34;))
        self.molecule_label.setText(_translate(&#34;MainWindow&#34;, &#34;Molecule:&#34;))
        self.soliton_paths_label.setText(_translate(&#34;MainWindow&#34;, &#34;Soliton paths:&#34;))
        self.submit_exterior_nodes.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
        self.exterior_nodes_label.setText(_translate(&#34;MainWindow&#34;, &#34;Exterior nodes:&#34;))
        self.submit_molecule.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))


    def submit_molecule_clicked(self):
        &#34;&#34;&#34;Method that is called when user clicks button to submit the specified molecule.
        Catches errors if user used the wrong syntax or specified a molecule that does not fulfill the requirements of a soliton graph.
        If the user&#39;s molecule is valid it displays the graph of the molecule. It then also reveals a save button for the graph visualisation and
        all the necessary widgets for the user to choose a pair of exterior nodes.
        &#34;&#34;&#34;
        self.node_1.clear()
        self.node_2.clear()
        self.smiles_string = self.molecule_lineedit.text()
        try:
            self.my_graph = SolitonGraph(self.smiles_string)
            errors = self.my_graph.validate_soliton_graph()
            self.graph_pic = Visualisation.visualize_soliton_graph(self.my_graph, self.my_graph.bindings, False, True)
            self.qim = ImageQt(self.graph_pic)
            self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(self.display_molecule.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
            if errors != []:
                self.save.hide()
                self.exterior_nodes_label.hide()
                self.exterior_nodes_label2.hide()
                self.node_1.hide()
                self.node_2.hide()
                self.submit_exterior_nodes.hide()
                self.soliton_paths_label.hide()
                self.paths.hide()
                self.show_matrices.hide()
                self.show_end_result.hide()
                self.show_animation.hide()
                msg = QMessageBox()
                msg.setWindowTitle(&#34;No soliton graph&#34;)
                msg.setText(&#34;You specified a molecule that does not fulfill the requirements of a soliton graph&#34;)
                msg.setIcon(QMessageBox.Warning)
                msg.setStandardButtons(QMessageBox.Retry)
                msg.setInformativeText(&#34;See details for all incorrect parts of your molecule.&#34;)
                msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px;}&#34;)
                details = &#34;&#34;
                for i, error in enumerate(errors):
                    if i == len(errors) - 1:
                        details = details + error
                    else:
                        details = details + error + &#34;\n&#34;
                msg.setDetailedText(details)
                x = msg.exec_() # show messagebox
            elif self.my_graph.exterior_nodes_name_collision() == True:
                self.save.hide()
                self.exterior_nodes_label.hide()
                self.exterior_nodes_label2.hide()
                self.node_1.hide()
                self.node_2.hide()
                self.submit_exterior_nodes.hide()
                self.soliton_paths_label.hide()
                self.paths.hide()
                self.show_matrices.hide()
                self.show_end_result.hide()
                self.show_animation.hide()
                msg = QMessageBox()
                msg.setWindowTitle(&#34;Name collision&#34;)
                msg.setText(&#34;You specified two or more exterior nodes with the same name&#34;)
                msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
                msg.setIcon(QMessageBox.Warning)
                msg.setStandardButtons(QMessageBox.Retry)
                x = msg.exec_()
            else:
                self.save.show()
                self.exterior_nodes_label.show()
                self.exterior_nodes_label2.show()
                self.node_1.show()
                self.node_2.show()
                self.submit_exterior_nodes.show()
                self.soliton_paths_label.hide()
                self.paths.hide()
                self.show_matrices.hide()
                self.show_end_result.hide()
                self.show_animation.hide()
                for key in self.my_graph.exterior_nodes_reverse:
                    self.node_1.addItem(key)
                    self.node_2.addItem(key)
        except:
            self.save.hide()
            self.exterior_nodes_label.hide()
            self.exterior_nodes_label2.hide()
            self.node_1.hide()
            self.node_2.hide()
            self.submit_exterior_nodes.hide()
            self.soliton_paths_label.hide()
            self.paths.hide()
            self.show_matrices.hide()
            self.show_end_result.hide()
            self.show_animation.hide()
            msg = QMessageBox()
            msg.setWindowTitle(&#34;Incorrect input&#34;)
            msg.setText(&#34;The syntax of your input is not correct&#34;)
            msg.setIcon(QMessageBox.Warning)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;Please try again with another input string.&#34;)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
            details = f&#34;Reminder - this is how you define a molecule: \n&#34;
            details = details + f&#34;- Carbon atoms are marked with &#39;C&#39; \n&#34;
            details = details + f&#34;- Single edges are marked with &#39;-&#39; or no character at all \n&#34;
            details = details + f&#34;- Double edges are marked with &#39;=&#39; \n&#34;
            details = details + f&#34;- The two connecting atoms of a ring are marked with the same number (e.g. &#39;C1&#39; and &#39;C1&#39;) \n&#34;
            details = details + &#34;- Exterior nodes are marked with braces and a number (e.g. &#39;{1}&#39;)&#34;
            msg.setDetailedText(details)
            x = msg.exec_()


    def save_clicked(self):
        &#34;&#34;&#34;Method that is called when user clicks button to save the graph visualisation.
        Opens a file dialog in which user can specify a path where the image should be saved.
        Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
        &#34;&#34;&#34;
        option = QtWidgets.QFileDialog.Options()
        name = QtWidgets.QFileDialog.getSaveFileName(self.centralwidget, &#39;Save File&#39;, &#39;graph.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
        if name != (&#39;&#39;, &#39;&#39;):
            path = name[0]
            # turn PIL Image into byte array 
            imgByteArr = io.BytesIO()
            self.graph_pic.save(imgByteArr, format=&#39;PNG&#39;)
            imgByteArr = imgByteArr.getvalue()
            # save image at specified path
            file = open(path, &#34;wb&#34;)
            file.write(imgByteArr) # before: file.write(data)
            file.close()


    def submit_exterior_nodes_clicked(self):
        &#34;&#34;&#34;Method that is called when user clicks button to submit a pair of exterior nodes.
        Computes all possible soliton paths between the two chosen nodes.
        Informs the user if no soliton path exists between them.
        Otherwise all the necessary widgets for the user to choose a computed soliton path and look at further information on it are revealed.
        &#34;&#34;&#34;
        self.path_index = None # we need this variable later in show_animation_clicked
        self.paths.clear()
        node1 = int(self.node_1.currentText())
        node2 = int(self.node_2.currentText())
        self.automata = MiniSolitonAutomata(self.my_graph, node1, node2)
        if self.automata.soliton_paths == []:
            self.soliton_paths_label.hide()
            self.paths.hide()
            self.show_matrices.hide()
            self.show_end_result.hide()
            self.show_animation.hide()
            msg = QMessageBox()
            msg.setWindowTitle(&#34;No path found&#34;)
            msg.setText(&#34;There exists no soliton path between these exterior nodes.&#34;)
            msg.setIcon(QMessageBox.Information)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;Please try again with different exterior nodes.&#34;)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
            x = msg.exec_()
        else:
            self.soliton_paths_label.setText(f&#34;Soliton paths ({len(self.automata.soliton_paths)}):&#34;)
            self.soliton_paths_label.show()
            self.paths.show()
            self.show_matrices.show()
            self.show_end_result.show()
            self.show_animation.show()
            for soliton_path in self.automata.soliton_paths:
                self.paths.addItem(str(soliton_path.path_for_user))
    

    def show_matrices_clicked(self):
        &#34;&#34;&#34;Method that is called when user clicks button to have the adjacency matrices of every timestep displayed.
        Makes a small window pop up that shows the labelled adjacency matrices and provides a save button.
        &#34;&#34;&#34;

        def save_matrices():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where a text file with all adjacency matrices should be saved.
            Text file also contains the input string representing the molecule and the soliton path.
            Only allows `.txt` file suffix.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.centralwidget, &#39;Save File&#39;, &#39;matrices.txt&#39;, &#39;Text files (*.txt)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;): # only do the following if user clicked on save button (without this line the application closes with an error if save action is cancelled)
                path = name[0]
                file = open(path, &#34;w&#34;)
                file.write(txt_text)
                file.close()

        index = self.paths.currentIndex()
        desired_path = self.automata.soliton_paths[index]
    
        dlg = QDialog()
        scrollArea = QScrollArea(dlg)
        widget = QtWidgets.QWidget()
        vbox = QtWidgets.QVBoxLayout()
        txt_text = f&#34;Molecule: {self.smiles_string} \n&#34;
        txt_text = txt_text + f&#34;Soliton path: {desired_path.path_for_user} \n \n&#34;
        # labelling of matrix depends on wether we have long node labels (&#34;aa&#34;, &#34;ab&#34;, ...) or short ones (&#34;a&#34;, &#34;b&#34;, ...)
        if (len(self.my_graph.labels) - len(self.my_graph.exterior_nodes)) &gt; 26:
            matrix_label_horizontal = &#34;    &#34;
            long_labels = True
        else:
            matrix_label_horizontal = &#34;   &#34;
            long_labels = False
        for key in self.my_graph.labels:
            if long_labels:
                if self.my_graph.labels[key] in self.my_graph.exterior_nodes_reverse:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]}  &#34;
                else:
                    matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]} &#34;
            else:
                matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]}  &#34;
        # for show-matrices-window the node labels are added to the matrix string and this labelled matrix is added to scroll area
        # for matrices.txt we add everything (horizontal label and every row of matrix) line by line
        for i in range(len(desired_path.adjacency_matrices_list)):
            txt_text = txt_text + f&#34;Timestep {i}: \n&#34;
            txt_text = txt_text + f&#34;{matrix_label_horizontal} \n&#34;
            matrix_labelled = &#34;&#34;
            matrix_labelled = matrix_labelled + f&#34;{matrix_label_horizontal}\n&#34;
            matrix = str(desired_path.adjacency_matrices_list[i])
            matrix = re.sub(r&#34;[matrix(]&#34;, &#34;&#34;, matrix)
            matrix = re.sub(r&#34;[)]&#34;, &#34;&#34;, matrix)
            for j in range(len(matrix.splitlines())):
                if long_labels:
                    if self.my_graph.labels[j] in self.my_graph.exterior_nodes_reverse:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]} {matrix.splitlines()[j]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph.labels[j]} {matrix.splitlines()[j]} \n&#34;
                    else:
                        matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
                        txt_text = txt_text + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
                else:
                    matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
                    txt_text = txt_text + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
            txt_text = txt_text + f&#34;\n&#34;
            vbox.addWidget(QtWidgets.QLabel(matrix_labelled))
        widget.setLayout(vbox)
        scrollArea.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        scrollArea.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        scrollArea.setWidgetResizable(True)
        scrollArea.setWidget(widget)
        scrollArea.setStyleSheet(&#34;font: 13pt Courier;&#34;)
        scrollArea.setFixedSize(540, 405)
        save_button = QtWidgets.QPushButton(&#34;Save&#34;, dlg)
        save_button.setGeometry(QtCore.QRect(454, 359, 70, 30))
        save_button.clicked.connect(save_matrices)

        dlg.setWindowTitle(&#34;Adjacency Matrices&#34;)
        dlg.setFixedSize(545, 410)
        dlg.exec_()
    

    def show_end_result_clicked(self):
        &#34;&#34;&#34;Method that is called when user clicks button to have the resulting graph (after soliton path is traversed) displayed.
        Makes a small window pop up that shows the graph visualisation and provides a save button.
        &#34;&#34;&#34;

        def save_end_result():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where the resulting graph should be saved.
            Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.centralwidget, &#39;Save File&#39;, &#39;result.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;):
                path = name[0]
                imgByteArr = io.BytesIO()
                result_pic.save(imgByteArr, format=&#39;PNG&#39;)
                imgByteArr = imgByteArr.getvalue()
                file = open(path, &#34;wb&#34;)
                file.write(imgByteArr)
                file.close()

        index = self.paths.currentIndex()
        desired_path = self.automata.soliton_paths[index]
        bindings_index = len(desired_path.path) - 1
        result_pic = Visualisation.visualize_soliton_graph(self.my_graph, desired_path.bindings_list[bindings_index], False, True)
        qim = ImageQt(result_pic)

        dlg = QDialog()
        label = QtWidgets.QLabel(dlg)
        label.setGeometry(QtCore.QRect(0, 0, 540, 405))
        label.setPixmap(QtGui.QPixmap.fromImage(qim))
        label.setScaledContents(True)
        save_button = QtWidgets.QPushButton(&#34;Save&#34;, dlg)
        save_button.setGeometry(QtCore.QRect(470, 375, 70, 30))
        save_button.clicked.connect(save_end_result)

        dlg.setWindowTitle(&#34;End result&#34;)
        dlg.setFixedSize(545, 410)
        dlg.exec_()


    def show_animation_clicked(self):
        &#34;&#34;&#34;Method that is called when user clicks button to have the animation of the soliton traversing the graph displayed.
        Makes a small window pop up that shows the animation and provides a save button.
        Instead of displaying the `gif` it uses a sequence of `PIL` images and always shows the next image after a certain time.
        &#34;&#34;&#34;
        
        def save_animation():
            &#34;&#34;&#34;Opens a file dialog in which user can specify a path where the animation should be saved.
            Only allows `.gif` file suffix.
            &#34;&#34;&#34;
            option = QtWidgets.QFileDialog.Options()
            name = QtWidgets.QFileDialog.getSaveFileName(self.centralwidget, &#39;Save File&#39;, &#39;animation.gif&#39;, &#39;Images (*.gif)&#39;, options = option)
            if name != (&#39;&#39;, &#39;&#39;):
                path = name[0]
                ani = self.my_animation.graph_animation()
                ani.save(path, writer=&#39;ffmpeg&#39;)

        dlg = QDialog()
        label = QtWidgets.QLabel(dlg)
        label.setGeometry(QtCore.QRect(0, 0, 540, 405))
        
        if self.path_index != self.paths.currentIndex():
            self.path_index = self.paths.currentIndex()
            self.desired_path = self.automata.soliton_paths[self.path_index]
            self.my_animation = Animation(self.my_graph, self.desired_path)
            self.pil_images = self.my_animation.pil_images

        self.step = 0
        self.timer = QtCore.QTimer(self)
        self.timer.timeout.connect(lambda: self.update_image(label, self.pil_images, self.desired_path))
        self.timer.start(800) # triggers event every 800 milliseconds
        self.update_image(label, self.pil_images, self.desired_path)
        save_button = QtWidgets.QPushButton(&#34;Save&#34;, dlg)
        save_button.setGeometry(QtCore.QRect(470, 375, 70, 30))
        save_button.clicked.connect(save_animation)

        dlg.setWindowTitle(&#34;Animation&#34;)
        dlg.setFixedSize(545, 410)
        dlg.closeEvent = self.stop_animation # stop timer when window is closed
        dlg.exec_()
    

    def update_image(self, label: QtWidgets.QLabel, pil_images: list, desired_path: SolitonPath):
        &#34;&#34;&#34;Displays next image of animation after a certain time (method is triggered by a timer).

        Args:
            label (QtWidgets.QLabel): Displays the animation&#39;s images.
            pil_images (list): `PIL` images that should be displayed step by step.
            desired_path (SolitonPath): Soliton path that is traversed in animation.
        &#34;&#34;&#34;
        im = pil_images[self.step]
        qim = ImageQt(im)
        label.setPixmap(QtGui.QPixmap.fromImage(qim))
        label.setScaledContents(True)
        self.step += 1
        if self.step == len(desired_path.path): # start animation all over again as soon as end is reached (endless loop)
            self.step = 0


    def stop_animation(self, event):
        &#34;&#34;&#34;Stops the timer that is used for the animation.
        Without this method the application would crash if the animation window would get closed.
        Args:
            event: Close event of the window that shows animation.
        &#34;&#34;&#34;
        self.timer.disconnect()


    def hide_retain_space(self, widget):
        &#34;&#34;&#34;Retains the space of a widget even when it&#39;s hidden.

        Args:
            widget (QtWidgets.QWidget ): Widget whose space should be retained.
        &#34;&#34;&#34;
        retain = widget.sizePolicy()
        retain.setRetainSizeWhenHidden(True)
        widget.setSizePolicy(retain)


    def heightForWidth(self, width: float):
        &#34;&#34;&#34;Computes height for a given width.

        Args:
            width (float): Given width.

        Returns:
            float: Computed height.
        &#34;&#34;&#34;
        return math.ceil(width * self.height_for_width_factor)


    def widthForHeight(self, height):
        &#34;&#34;&#34;Computes width for a given height.

        Args:
            height (float): Given height.

        Returns:
            float: Computed width.
        &#34;&#34;&#34;
        return math.ceil(height * self.width_for_height_factor)


    def resizeEvent(self, event: QtGui.QResizeEvent):
        &#34;&#34;&#34;Keeps the right aspect ratio of the graph visualisation image (or welcoming screen in the beginning) when window is resized.

        Args:
            event (QtGui.QResizeEvent): Resize event.
        &#34;&#34;&#34;
        super(MainWindow, self).resizeEvent(event)
        size = event.size()
        # window height minus height of all widgets below the label result in height of pixmap
        height = size.height() - self.save.height() - self.submit_molecule.height() - self.submit_exterior_nodes.height() - self.paths.height() - self.show_animation.height()
        if self.widthForHeight(height) &gt; size.width(): # pixmap width should be as most as big as width of whole window
            width = size.width()
        else:
            width = self.widthForHeight(height)
        self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(width, height, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mini_soliton_automata.gui.main_window.MainWindow.heightForWidth"><code class="name flex">
<span>def <span class="ident">heightForWidth</span></span>(<span>self, width:float)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes height for a given width.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code></dt>
<dd>Given width.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Computed height.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def heightForWidth(self, width: float):
    &#34;&#34;&#34;Computes height for a given width.

    Args:
        width (float): Given width.

    Returns:
        float: Computed height.
    &#34;&#34;&#34;
    return math.ceil(width * self.height_for_width_factor)</code></pre>
</details>
</dd>
<dt id="mini_soliton_automata.gui.main_window.MainWindow.hide_retain_space"><code class="name flex">
<span>def <span class="ident">hide_retain_space</span></span>(<span>self, widget)</span>
</code></dt>
<dd>
<div class="desc"><p>Retains the space of a widget even when it's hidden.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>widget</code></strong> :&ensp;<code>QtWidgets.QWidget </code></dt>
<dd>Widget whose space should be retained.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hide_retain_space(self, widget):
    &#34;&#34;&#34;Retains the space of a widget even when it&#39;s hidden.

    Args:
        widget (QtWidgets.QWidget ): Widget whose space should be retained.
    &#34;&#34;&#34;
    retain = widget.sizePolicy()
    retain.setRetainSizeWhenHidden(True)
    widget.setSizePolicy(retain)</code></pre>
</details>
</dd>
<dt id="mini_soliton_automata.gui.main_window.MainWindow.resizeEvent"><code class="name flex">
<span>def <span class="ident">resizeEvent</span></span>(<span>self, event:PyQt5.QtGui.QResizeEvent)</span>
</code></dt>
<dd>
<div class="desc"><p>Keeps the right aspect ratio of the graph visualisation image (or welcoming screen in the beginning) when window is resized.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>QtGui.QResizeEvent</code></dt>
<dd>Resize event.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resizeEvent(self, event: QtGui.QResizeEvent):
    &#34;&#34;&#34;Keeps the right aspect ratio of the graph visualisation image (or welcoming screen in the beginning) when window is resized.

    Args:
        event (QtGui.QResizeEvent): Resize event.
    &#34;&#34;&#34;
    super(MainWindow, self).resizeEvent(event)
    size = event.size()
    # window height minus height of all widgets below the label result in height of pixmap
    height = size.height() - self.save.height() - self.submit_molecule.height() - self.submit_exterior_nodes.height() - self.paths.height() - self.show_animation.height()
    if self.widthForHeight(height) &gt; size.width(): # pixmap width should be as most as big as width of whole window
        width = size.width()
    else:
        width = self.widthForHeight(height)
    self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(width, height, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))</code></pre>
</details>
</dd>
<dt id="mini_soliton_automata.gui.main_window.MainWindow.retranslateUi"><code class="name flex">
<span>def <span class="ident">retranslateUi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Implements multi-language suppport. Is generated automatically when using PyQt5 UI code generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retranslateUi(self):
    &#34;&#34;&#34;Implements multi-language suppport. Is generated automatically when using PyQt5 UI code generator.
    &#34;&#34;&#34;
    _translate = QtCore.QCoreApplication.translate
    self.setWindowTitle(_translate(&#34;MainWindow&#34;, &#34;Mini Soliton Automata Software&#34;))
    self.show_animation.setText(_translate(&#34;MainWindow&#34;, &#34;Show animation&#34;))
    self.exterior_nodes_label2.setText(_translate(&#34;MainWindow&#34;, &#34;&amp;&#34;))
    self.show_end_result.setText(_translate(&#34;MainWindow&#34;, &#34;Show end result&#34;))
    self.save.setText(_translate(&#34;MainWindow&#34;, &#34;Save&#34;))
    self.show_matrices.setText(_translate(&#34;MainWindow&#34;, &#34;Show matrices&#34;))
    self.molecule_label.setText(_translate(&#34;MainWindow&#34;, &#34;Molecule:&#34;))
    self.soliton_paths_label.setText(_translate(&#34;MainWindow&#34;, &#34;Soliton paths:&#34;))
    self.submit_exterior_nodes.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))
    self.exterior_nodes_label.setText(_translate(&#34;MainWindow&#34;, &#34;Exterior nodes:&#34;))
    self.submit_molecule.setText(_translate(&#34;MainWindow&#34;, &#34;Submit&#34;))</code></pre>
</details>
</dd>
<dt id="mini_soliton_automata.gui.main_window.MainWindow.save_clicked"><code class="name flex">
<span>def <span class="ident">save_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that is called when user clicks button to save the graph visualisation.
Opens a file dialog in which user can specify a path where the image should be saved.
Only allows <code>.jpg</code>, <code>.png</code> and <code>.jpeg</code> file suffixes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_clicked(self):
    &#34;&#34;&#34;Method that is called when user clicks button to save the graph visualisation.
    Opens a file dialog in which user can specify a path where the image should be saved.
    Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
    &#34;&#34;&#34;
    option = QtWidgets.QFileDialog.Options()
    name = QtWidgets.QFileDialog.getSaveFileName(self.centralwidget, &#39;Save File&#39;, &#39;graph.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
    if name != (&#39;&#39;, &#39;&#39;):
        path = name[0]
        # turn PIL Image into byte array 
        imgByteArr = io.BytesIO()
        self.graph_pic.save(imgByteArr, format=&#39;PNG&#39;)
        imgByteArr = imgByteArr.getvalue()
        # save image at specified path
        file = open(path, &#34;wb&#34;)
        file.write(imgByteArr) # before: file.write(data)
        file.close()</code></pre>
</details>
</dd>
<dt id="mini_soliton_automata.gui.main_window.MainWindow.show_animation_clicked"><code class="name flex">
<span>def <span class="ident">show_animation_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that is called when user clicks button to have the animation of the soliton traversing the graph displayed.
Makes a small window pop up that shows the animation and provides a save button.
Instead of displaying the <code>gif</code> it uses a sequence of <code>PIL</code> images and always shows the next image after a certain time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_animation_clicked(self):
    &#34;&#34;&#34;Method that is called when user clicks button to have the animation of the soliton traversing the graph displayed.
    Makes a small window pop up that shows the animation and provides a save button.
    Instead of displaying the `gif` it uses a sequence of `PIL` images and always shows the next image after a certain time.
    &#34;&#34;&#34;
    
    def save_animation():
        &#34;&#34;&#34;Opens a file dialog in which user can specify a path where the animation should be saved.
        Only allows `.gif` file suffix.
        &#34;&#34;&#34;
        option = QtWidgets.QFileDialog.Options()
        name = QtWidgets.QFileDialog.getSaveFileName(self.centralwidget, &#39;Save File&#39;, &#39;animation.gif&#39;, &#39;Images (*.gif)&#39;, options = option)
        if name != (&#39;&#39;, &#39;&#39;):
            path = name[0]
            ani = self.my_animation.graph_animation()
            ani.save(path, writer=&#39;ffmpeg&#39;)

    dlg = QDialog()
    label = QtWidgets.QLabel(dlg)
    label.setGeometry(QtCore.QRect(0, 0, 540, 405))
    
    if self.path_index != self.paths.currentIndex():
        self.path_index = self.paths.currentIndex()
        self.desired_path = self.automata.soliton_paths[self.path_index]
        self.my_animation = Animation(self.my_graph, self.desired_path)
        self.pil_images = self.my_animation.pil_images

    self.step = 0
    self.timer = QtCore.QTimer(self)
    self.timer.timeout.connect(lambda: self.update_image(label, self.pil_images, self.desired_path))
    self.timer.start(800) # triggers event every 800 milliseconds
    self.update_image(label, self.pil_images, self.desired_path)
    save_button = QtWidgets.QPushButton(&#34;Save&#34;, dlg)
    save_button.setGeometry(QtCore.QRect(470, 375, 70, 30))
    save_button.clicked.connect(save_animation)

    dlg.setWindowTitle(&#34;Animation&#34;)
    dlg.setFixedSize(545, 410)
    dlg.closeEvent = self.stop_animation # stop timer when window is closed
    dlg.exec_()</code></pre>
</details>
</dd>
<dt id="mini_soliton_automata.gui.main_window.MainWindow.show_end_result_clicked"><code class="name flex">
<span>def <span class="ident">show_end_result_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that is called when user clicks button to have the resulting graph (after soliton path is traversed) displayed.
Makes a small window pop up that shows the graph visualisation and provides a save button.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_end_result_clicked(self):
    &#34;&#34;&#34;Method that is called when user clicks button to have the resulting graph (after soliton path is traversed) displayed.
    Makes a small window pop up that shows the graph visualisation and provides a save button.
    &#34;&#34;&#34;

    def save_end_result():
        &#34;&#34;&#34;Opens a file dialog in which user can specify a path where the resulting graph should be saved.
        Only allows `.jpg`, `.png` and `.jpeg` file suffixes.
        &#34;&#34;&#34;
        option = QtWidgets.QFileDialog.Options()
        name = QtWidgets.QFileDialog.getSaveFileName(self.centralwidget, &#39;Save File&#39;, &#39;result.jpg&#39;, &#39;Images (*.jpg *.png *.jpeg)&#39;, options = option)
        if name != (&#39;&#39;, &#39;&#39;):
            path = name[0]
            imgByteArr = io.BytesIO()
            result_pic.save(imgByteArr, format=&#39;PNG&#39;)
            imgByteArr = imgByteArr.getvalue()
            file = open(path, &#34;wb&#34;)
            file.write(imgByteArr)
            file.close()

    index = self.paths.currentIndex()
    desired_path = self.automata.soliton_paths[index]
    bindings_index = len(desired_path.path) - 1
    result_pic = Visualisation.visualize_soliton_graph(self.my_graph, desired_path.bindings_list[bindings_index], False, True)
    qim = ImageQt(result_pic)

    dlg = QDialog()
    label = QtWidgets.QLabel(dlg)
    label.setGeometry(QtCore.QRect(0, 0, 540, 405))
    label.setPixmap(QtGui.QPixmap.fromImage(qim))
    label.setScaledContents(True)
    save_button = QtWidgets.QPushButton(&#34;Save&#34;, dlg)
    save_button.setGeometry(QtCore.QRect(470, 375, 70, 30))
    save_button.clicked.connect(save_end_result)

    dlg.setWindowTitle(&#34;End result&#34;)
    dlg.setFixedSize(545, 410)
    dlg.exec_()</code></pre>
</details>
</dd>
<dt id="mini_soliton_automata.gui.main_window.MainWindow.show_matrices_clicked"><code class="name flex">
<span>def <span class="ident">show_matrices_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that is called when user clicks button to have the adjacency matrices of every timestep displayed.
Makes a small window pop up that shows the labelled adjacency matrices and provides a save button.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_matrices_clicked(self):
    &#34;&#34;&#34;Method that is called when user clicks button to have the adjacency matrices of every timestep displayed.
    Makes a small window pop up that shows the labelled adjacency matrices and provides a save button.
    &#34;&#34;&#34;

    def save_matrices():
        &#34;&#34;&#34;Opens a file dialog in which user can specify a path where a text file with all adjacency matrices should be saved.
        Text file also contains the input string representing the molecule and the soliton path.
        Only allows `.txt` file suffix.
        &#34;&#34;&#34;
        option = QtWidgets.QFileDialog.Options()
        name = QtWidgets.QFileDialog.getSaveFileName(self.centralwidget, &#39;Save File&#39;, &#39;matrices.txt&#39;, &#39;Text files (*.txt)&#39;, options = option)
        if name != (&#39;&#39;, &#39;&#39;): # only do the following if user clicked on save button (without this line the application closes with an error if save action is cancelled)
            path = name[0]
            file = open(path, &#34;w&#34;)
            file.write(txt_text)
            file.close()

    index = self.paths.currentIndex()
    desired_path = self.automata.soliton_paths[index]

    dlg = QDialog()
    scrollArea = QScrollArea(dlg)
    widget = QtWidgets.QWidget()
    vbox = QtWidgets.QVBoxLayout()
    txt_text = f&#34;Molecule: {self.smiles_string} \n&#34;
    txt_text = txt_text + f&#34;Soliton path: {desired_path.path_for_user} \n \n&#34;
    # labelling of matrix depends on wether we have long node labels (&#34;aa&#34;, &#34;ab&#34;, ...) or short ones (&#34;a&#34;, &#34;b&#34;, ...)
    if (len(self.my_graph.labels) - len(self.my_graph.exterior_nodes)) &gt; 26:
        matrix_label_horizontal = &#34;    &#34;
        long_labels = True
    else:
        matrix_label_horizontal = &#34;   &#34;
        long_labels = False
    for key in self.my_graph.labels:
        if long_labels:
            if self.my_graph.labels[key] in self.my_graph.exterior_nodes_reverse:
                matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]}  &#34;
            else:
                matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]} &#34;
        else:
            matrix_label_horizontal = matrix_label_horizontal + f&#34;{self.my_graph.labels[key]}  &#34;
    # for show-matrices-window the node labels are added to the matrix string and this labelled matrix is added to scroll area
    # for matrices.txt we add everything (horizontal label and every row of matrix) line by line
    for i in range(len(desired_path.adjacency_matrices_list)):
        txt_text = txt_text + f&#34;Timestep {i}: \n&#34;
        txt_text = txt_text + f&#34;{matrix_label_horizontal} \n&#34;
        matrix_labelled = &#34;&#34;
        matrix_labelled = matrix_labelled + f&#34;{matrix_label_horizontal}\n&#34;
        matrix = str(desired_path.adjacency_matrices_list[i])
        matrix = re.sub(r&#34;[matrix(]&#34;, &#34;&#34;, matrix)
        matrix = re.sub(r&#34;[)]&#34;, &#34;&#34;, matrix)
        for j in range(len(matrix.splitlines())):
            if long_labels:
                if self.my_graph.labels[j] in self.my_graph.exterior_nodes_reverse:
                    matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]} {matrix.splitlines()[j]} \n&#34;
                    txt_text = txt_text + f&#34;{self.my_graph.labels[j]} {matrix.splitlines()[j]} \n&#34;
                else:
                    matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
                    txt_text = txt_text + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
            else:
                matrix_labelled = matrix_labelled + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
                txt_text = txt_text + f&#34;{self.my_graph.labels[j]}{matrix.splitlines()[j]} \n&#34;
        txt_text = txt_text + f&#34;\n&#34;
        vbox.addWidget(QtWidgets.QLabel(matrix_labelled))
    widget.setLayout(vbox)
    scrollArea.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
    scrollArea.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
    scrollArea.setWidgetResizable(True)
    scrollArea.setWidget(widget)
    scrollArea.setStyleSheet(&#34;font: 13pt Courier;&#34;)
    scrollArea.setFixedSize(540, 405)
    save_button = QtWidgets.QPushButton(&#34;Save&#34;, dlg)
    save_button.setGeometry(QtCore.QRect(454, 359, 70, 30))
    save_button.clicked.connect(save_matrices)

    dlg.setWindowTitle(&#34;Adjacency Matrices&#34;)
    dlg.setFixedSize(545, 410)
    dlg.exec_()</code></pre>
</details>
</dd>
<dt id="mini_soliton_automata.gui.main_window.MainWindow.stop_animation"><code class="name flex">
<span>def <span class="ident">stop_animation</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Stops the timer that is used for the animation.
Without this method the application would crash if the animation window would get closed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong></dt>
<dd>Close event of the window that shows animation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_animation(self, event):
    &#34;&#34;&#34;Stops the timer that is used for the animation.
    Without this method the application would crash if the animation window would get closed.
    Args:
        event: Close event of the window that shows animation.
    &#34;&#34;&#34;
    self.timer.disconnect()</code></pre>
</details>
</dd>
<dt id="mini_soliton_automata.gui.main_window.MainWindow.submit_exterior_nodes_clicked"><code class="name flex">
<span>def <span class="ident">submit_exterior_nodes_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that is called when user clicks button to submit a pair of exterior nodes.
Computes all possible soliton paths between the two chosen nodes.
Informs the user if no soliton path exists between them.
Otherwise all the necessary widgets for the user to choose a computed soliton path and look at further information on it are revealed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submit_exterior_nodes_clicked(self):
    &#34;&#34;&#34;Method that is called when user clicks button to submit a pair of exterior nodes.
    Computes all possible soliton paths between the two chosen nodes.
    Informs the user if no soliton path exists between them.
    Otherwise all the necessary widgets for the user to choose a computed soliton path and look at further information on it are revealed.
    &#34;&#34;&#34;
    self.path_index = None # we need this variable later in show_animation_clicked
    self.paths.clear()
    node1 = int(self.node_1.currentText())
    node2 = int(self.node_2.currentText())
    self.automata = MiniSolitonAutomata(self.my_graph, node1, node2)
    if self.automata.soliton_paths == []:
        self.soliton_paths_label.hide()
        self.paths.hide()
        self.show_matrices.hide()
        self.show_end_result.hide()
        self.show_animation.hide()
        msg = QMessageBox()
        msg.setWindowTitle(&#34;No path found&#34;)
        msg.setText(&#34;There exists no soliton path between these exterior nodes.&#34;)
        msg.setIcon(QMessageBox.Information)
        msg.setStandardButtons(QMessageBox.Retry)
        msg.setInformativeText(&#34;Please try again with different exterior nodes.&#34;)
        msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
        x = msg.exec_()
    else:
        self.soliton_paths_label.setText(f&#34;Soliton paths ({len(self.automata.soliton_paths)}):&#34;)
        self.soliton_paths_label.show()
        self.paths.show()
        self.show_matrices.show()
        self.show_end_result.show()
        self.show_animation.show()
        for soliton_path in self.automata.soliton_paths:
            self.paths.addItem(str(soliton_path.path_for_user))</code></pre>
</details>
</dd>
<dt id="mini_soliton_automata.gui.main_window.MainWindow.submit_molecule_clicked"><code class="name flex">
<span>def <span class="ident">submit_molecule_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that is called when user clicks button to submit the specified molecule.
Catches errors if user used the wrong syntax or specified a molecule that does not fulfill the requirements of a soliton graph.
If the user's molecule is valid it displays the graph of the molecule. It then also reveals a save button for the graph visualisation and
all the necessary widgets for the user to choose a pair of exterior nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submit_molecule_clicked(self):
    &#34;&#34;&#34;Method that is called when user clicks button to submit the specified molecule.
    Catches errors if user used the wrong syntax or specified a molecule that does not fulfill the requirements of a soliton graph.
    If the user&#39;s molecule is valid it displays the graph of the molecule. It then also reveals a save button for the graph visualisation and
    all the necessary widgets for the user to choose a pair of exterior nodes.
    &#34;&#34;&#34;
    self.node_1.clear()
    self.node_2.clear()
    self.smiles_string = self.molecule_lineedit.text()
    try:
        self.my_graph = SolitonGraph(self.smiles_string)
        errors = self.my_graph.validate_soliton_graph()
        self.graph_pic = Visualisation.visualize_soliton_graph(self.my_graph, self.my_graph.bindings, False, True)
        self.qim = ImageQt(self.graph_pic)
        self.display_molecule.setPixmap(QtGui.QPixmap.fromImage(self.qim).scaled(self.display_molecule.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))
        if errors != []:
            self.save.hide()
            self.exterior_nodes_label.hide()
            self.exterior_nodes_label2.hide()
            self.node_1.hide()
            self.node_2.hide()
            self.submit_exterior_nodes.hide()
            self.soliton_paths_label.hide()
            self.paths.hide()
            self.show_matrices.hide()
            self.show_end_result.hide()
            self.show_animation.hide()
            msg = QMessageBox()
            msg.setWindowTitle(&#34;No soliton graph&#34;)
            msg.setText(&#34;You specified a molecule that does not fulfill the requirements of a soliton graph&#34;)
            msg.setIcon(QMessageBox.Warning)
            msg.setStandardButtons(QMessageBox.Retry)
            msg.setInformativeText(&#34;See details for all incorrect parts of your molecule.&#34;)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px;}&#34;)
            details = &#34;&#34;
            for i, error in enumerate(errors):
                if i == len(errors) - 1:
                    details = details + error
                else:
                    details = details + error + &#34;\n&#34;
            msg.setDetailedText(details)
            x = msg.exec_() # show messagebox
        elif self.my_graph.exterior_nodes_name_collision() == True:
            self.save.hide()
            self.exterior_nodes_label.hide()
            self.exterior_nodes_label2.hide()
            self.node_1.hide()
            self.node_2.hide()
            self.submit_exterior_nodes.hide()
            self.soliton_paths_label.hide()
            self.paths.hide()
            self.show_matrices.hide()
            self.show_end_result.hide()
            self.show_animation.hide()
            msg = QMessageBox()
            msg.setWindowTitle(&#34;Name collision&#34;)
            msg.setText(&#34;You specified two or more exterior nodes with the same name&#34;)
            msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
            msg.setIcon(QMessageBox.Warning)
            msg.setStandardButtons(QMessageBox.Retry)
            x = msg.exec_()
        else:
            self.save.show()
            self.exterior_nodes_label.show()
            self.exterior_nodes_label2.show()
            self.node_1.show()
            self.node_2.show()
            self.submit_exterior_nodes.show()
            self.soliton_paths_label.hide()
            self.paths.hide()
            self.show_matrices.hide()
            self.show_end_result.hide()
            self.show_animation.hide()
            for key in self.my_graph.exterior_nodes_reverse:
                self.node_1.addItem(key)
                self.node_2.addItem(key)
    except:
        self.save.hide()
        self.exterior_nodes_label.hide()
        self.exterior_nodes_label2.hide()
        self.node_1.hide()
        self.node_2.hide()
        self.submit_exterior_nodes.hide()
        self.soliton_paths_label.hide()
        self.paths.hide()
        self.show_matrices.hide()
        self.show_end_result.hide()
        self.show_animation.hide()
        msg = QMessageBox()
        msg.setWindowTitle(&#34;Incorrect input&#34;)
        msg.setText(&#34;The syntax of your input is not correct&#34;)
        msg.setIcon(QMessageBox.Warning)
        msg.setStandardButtons(QMessageBox.Retry)
        msg.setInformativeText(&#34;Please try again with another input string.&#34;)
        msg.setStyleSheet(&#34; QPushButton{ height: 32px; width: 130px}&#34;)
        details = f&#34;Reminder - this is how you define a molecule: \n&#34;
        details = details + f&#34;- Carbon atoms are marked with &#39;C&#39; \n&#34;
        details = details + f&#34;- Single edges are marked with &#39;-&#39; or no character at all \n&#34;
        details = details + f&#34;- Double edges are marked with &#39;=&#39; \n&#34;
        details = details + f&#34;- The two connecting atoms of a ring are marked with the same number (e.g. &#39;C1&#39; and &#39;C1&#39;) \n&#34;
        details = details + &#34;- Exterior nodes are marked with braces and a number (e.g. &#39;{1}&#39;)&#34;
        msg.setDetailedText(details)
        x = msg.exec_()</code></pre>
</details>
</dd>
<dt id="mini_soliton_automata.gui.main_window.MainWindow.update_image"><code class="name flex">
<span>def <span class="ident">update_image</span></span>(<span>self, label:PyQt5.QtWidgets.QLabel, pil_images:list, desired_path:<a title="mini_soliton_automata.soliton_classes.soliton_path.SolitonPath" href="../soliton_classes/soliton_path.html#mini_soliton_automata.soliton_classes.soliton_path.SolitonPath">SolitonPath</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays next image of animation after a certain time (method is triggered by a timer).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>label</code></strong> :&ensp;<code>QtWidgets.QLabel</code></dt>
<dd>Displays the animation's images.</dd>
<dt><strong><code>pil_images</code></strong> :&ensp;<code>list</code></dt>
<dd><code>PIL</code> images that should be displayed step by step.</dd>
<dt><strong><code>desired_path</code></strong> :&ensp;<code>SolitonPath</code></dt>
<dd>Soliton path that is traversed in animation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_image(self, label: QtWidgets.QLabel, pil_images: list, desired_path: SolitonPath):
    &#34;&#34;&#34;Displays next image of animation after a certain time (method is triggered by a timer).

    Args:
        label (QtWidgets.QLabel): Displays the animation&#39;s images.
        pil_images (list): `PIL` images that should be displayed step by step.
        desired_path (SolitonPath): Soliton path that is traversed in animation.
    &#34;&#34;&#34;
    im = pil_images[self.step]
    qim = ImageQt(im)
    label.setPixmap(QtGui.QPixmap.fromImage(qim))
    label.setScaledContents(True)
    self.step += 1
    if self.step == len(desired_path.path): # start animation all over again as soon as end is reached (endless loop)
        self.step = 0</code></pre>
</details>
</dd>
<dt id="mini_soliton_automata.gui.main_window.MainWindow.widthForHeight"><code class="name flex">
<span>def <span class="ident">widthForHeight</span></span>(<span>self, height)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes width for a given height.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code></dt>
<dd>Given height.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Computed width.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def widthForHeight(self, height):
    &#34;&#34;&#34;Computes width for a given height.

    Args:
        height (float): Given height.

    Returns:
        float: Computed width.
    &#34;&#34;&#34;
    return math.ceil(height * self.width_for_height_factor)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mini_soliton_automata.gui" href="index.html">mini_soliton_automata.gui</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mini_soliton_automata.gui.main_window.MainWindow" href="#mini_soliton_automata.gui.main_window.MainWindow">MainWindow</a></code></h4>
<ul class="">
<li><code><a title="mini_soliton_automata.gui.main_window.MainWindow.heightForWidth" href="#mini_soliton_automata.gui.main_window.MainWindow.heightForWidth">heightForWidth</a></code></li>
<li><code><a title="mini_soliton_automata.gui.main_window.MainWindow.hide_retain_space" href="#mini_soliton_automata.gui.main_window.MainWindow.hide_retain_space">hide_retain_space</a></code></li>
<li><code><a title="mini_soliton_automata.gui.main_window.MainWindow.resizeEvent" href="#mini_soliton_automata.gui.main_window.MainWindow.resizeEvent">resizeEvent</a></code></li>
<li><code><a title="mini_soliton_automata.gui.main_window.MainWindow.retranslateUi" href="#mini_soliton_automata.gui.main_window.MainWindow.retranslateUi">retranslateUi</a></code></li>
<li><code><a title="mini_soliton_automata.gui.main_window.MainWindow.save_clicked" href="#mini_soliton_automata.gui.main_window.MainWindow.save_clicked">save_clicked</a></code></li>
<li><code><a title="mini_soliton_automata.gui.main_window.MainWindow.show_animation_clicked" href="#mini_soliton_automata.gui.main_window.MainWindow.show_animation_clicked">show_animation_clicked</a></code></li>
<li><code><a title="mini_soliton_automata.gui.main_window.MainWindow.show_end_result_clicked" href="#mini_soliton_automata.gui.main_window.MainWindow.show_end_result_clicked">show_end_result_clicked</a></code></li>
<li><code><a title="mini_soliton_automata.gui.main_window.MainWindow.show_matrices_clicked" href="#mini_soliton_automata.gui.main_window.MainWindow.show_matrices_clicked">show_matrices_clicked</a></code></li>
<li><code><a title="mini_soliton_automata.gui.main_window.MainWindow.stop_animation" href="#mini_soliton_automata.gui.main_window.MainWindow.stop_animation">stop_animation</a></code></li>
<li><code><a title="mini_soliton_automata.gui.main_window.MainWindow.submit_exterior_nodes_clicked" href="#mini_soliton_automata.gui.main_window.MainWindow.submit_exterior_nodes_clicked">submit_exterior_nodes_clicked</a></code></li>
<li><code><a title="mini_soliton_automata.gui.main_window.MainWindow.submit_molecule_clicked" href="#mini_soliton_automata.gui.main_window.MainWindow.submit_molecule_clicked">submit_molecule_clicked</a></code></li>
<li><code><a title="mini_soliton_automata.gui.main_window.MainWindow.update_image" href="#mini_soliton_automata.gui.main_window.MainWindow.update_image">update_image</a></code></li>
<li><code><a title="mini_soliton_automata.gui.main_window.MainWindow.widthForHeight" href="#mini_soliton_automata.gui.main_window.MainWindow.widthForHeight">widthForHeight</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>